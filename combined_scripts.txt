@tool
extends EditorPlugin

var filesystem_tree: Tree
var buttons: Array[Button] = []

func _enter_tree():
	var fs_dock := EditorInterface.get_file_system_dock()
	filesystem_tree = find_filesystem_tree(fs_dock)
	var fs_button_containers := find_button_container(fs_dock)

	for container in fs_button_containers:
		var button = Button.new()
		button.tooltip_text = "Collapse All"
		button.flat = true
		button.icon = preload("res://addons/collapse_folders/collapse-all.svg")
		button.pressed.connect(collapse_files)
		container.add_child(button)
		container.move_child(button, container.get_child_count() - 2)
		buttons.append(button)

func _exit_tree():
	for button in buttons:
		button.queue_free()
	buttons.clear()

func collapse_files():
	if !filesystem_tree: return
	var tree_root := filesystem_tree.get_root()
	
	for i in tree_root.get_child_count():
		var item := tree_root.get_child(i)
		item.set_collapsed_recursive(true)
		
		if i == tree_root.get_child_count() - 1:
			# Uncollapse only res://
			item.collapsed = false
		
		
# Util functions
func find_filesystem_tree(node: Node) -> Tree:
	for child in node.get_children():
		if child is Tree and node is SplitContainer:
			return child
		var ret := find_filesystem_tree(child)
		if ret:
			return ret
	return null


func find_button_container(node: Node) -> Array[Container]:
	var containers: Array[Container] = []
	for child in node.get_children():
		if child is MenuButton and child.tooltip_text == tr("Sort Files"):
			containers.append(node)
		
		for container in find_button_container(child):
			containers.append(container)

	return containers
class_name Storage2D
extends StaticBody2D
## 2D game object that represents a storable item_container inventory within the game world
## and can be selected. Show selectability if input_pickable is true.

## The item container that holds the information about what items are 
## stored in the storage
@export var item_container : ItemContainer
@export var sprite : Sprite2D
@export var selectable_shape : CollisionShape2D
@export var selectable_color = Color.SEA_GREEN

## Whether the mouse is inside the pickable region
var is_mouse_over = false

func _ready():
	validate()
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)
	
	if input_pickable != true:
		push_warning("Storage should be pickable, forcing setting to true. Correct at [input_pickable].")
		input_pickable = true
	
func validate() -> bool:
	var passing = true
	
	if item_container == null:
		push_warning("[item_container] should be a valid ItemContainer.")
		passing = false
		
	return passing

func _on_mouse_entered():
	sprite.self_modulate = selectable_color
	is_mouse_over = true

func _on_mouse_exited():
	sprite.self_modulate = Color.WHITE
	is_mouse_over = false
	
@icon("../art/basket.png")
class_name FlexInventoryNode
extends Node
@icon("../art/basket.png")
class_name InventoryResource
extends Resource

signal illegal_count_detected(report: IllegalCountReport)

## Emitted when the parent reference changes
signal parent_changed(old_parent: InventoryResource, new_parent: InventoryResource)

## Emitted when the root reference changes
signal root_changed(old_root: InventoryResource, new_root: InventoryResource)

## Reference to the parent resource which should be higher up in the hierarchy
var parent : InventoryResource:
	set(value):
		if parent == value:
			return
		var old_parent = parent
		parent = value
		parent_changed.emit(old_parent, value)
		_update_root()

## Cached reference to root inventory resource
var root: InventoryResource:
	set(value):
		if root == value:
			return
		var old_root = root
		root = value
		root_changed.emit(old_root, value)

## Optional direct settings reference for testing/standalone use
var _settings: InventorySettings

## Handles redistribution of items across the inventory hierarchy
var _redistribution_manager: StackRedistributionManager

func set_redistribution_manager(manager: StackRedistributionManager) -> void:
	_redistribution_manager = manager
	illegal_count_detected.connect(manager._on_illegal_count_detected)

func report_illegal_count(item: FlexItem, count: int, max_count: int) -> void:
	var report := IllegalCountReport.new(self, item, count, max_count)
	illegal_count_detected.emit(report)

## Gets the settings from the root inventory resource or direct reference
func get_inventory_settings() -> InventorySettings:
	# First try direct settings
	if _settings:
		return _settings
	# Fall back to hierarchy lookup
	return root.settings if root != null else null

## Checks if partial adds are allowed based on root inventory settings
## Returns false if no settings are found
func allows_partial_adds() -> bool:
	var inventory_settings := get_inventory_settings()
	return inventory_settings != null and inventory_settings.allow_partial_adds

## Attempts to add items to this resource without validation
## Returns the number of items successfully added
## Warning: Should only be called after has_space_for_items() returns true
func add_items(p_item: FlexItem, p_count: int) -> int:
	push_warning("add_items not implemented in %s" % self)
	return 0

## Removes items from this resource without validation
## Returns the number of items successfully removed
func get_space(p_item : FlexItem) -> int:
	push_warning("Virtual function. Implement in derived classes.")
	return 0

## Checks if this resource allows the given item type
## Override in derived classes to implement specific type validation
## Returns true by default in base class
func allows_type(p_item: FlexItem) -> bool:
	push_warning("allows_type not implemented in %s" % self)
	return true

## Checks if this resource allows swapping stacks with another resource
## Override in derived classes (like FlexStack) to enable swapping
## Returns false by default in base class
func can_swap(p_selection : StackSelection) -> bool:
	return false

## Check if the type is allowed and there is space for the item (or partial if partial adds allowed)
func can_add_items(p_item: FlexItem, p_count: int) -> bool:
	if not allows_type(p_item):
		return false

	var space := get_space(p_item)
	if allows_partial_adds():
		return space > 0  # Allow partial adds if any space available
	return space >= p_count  # Require space for all items

## Gets the total count of a specific item type in this resource
## Override in derived classes to implement specific counting logic
## Returns 0 by default in base class
func get_item_count(p_item: FlexItem) -> int:
	push_warning("get_item_count not implemented in %s" % self)
	return 0

## Returns the root inventory resource by traversing up the parent hierarchy
## If this resource has no parent, returns itself
func _get_root() -> InventoryResource:
	if root != null:
		return root
		
	# Start with current resource
	var current_resource = self
	
	# Keep going up until we reach a resource with no parent
	while current_resource.parent != null:
		current_resource = current_resource.parent
	
	root = current_resource
	return root

## Updates the cached root reference when parent changes
func _update_root() -> void:
	var new_root = _get_root()
	if root != new_root:
		self.root = new_root  # Use setter to trigger signal
class_name InventoryBus
extends Resource
## Signals for an inventory communicating with UI or other game objects
class_name FlexListItemData
extends RefCounted
## Holds the data association between a FlexItemList and
## the item container that holds the associated item stack

## The stack holding the item(s) that are considered for transfer
var stack : FlexStack

## Amount of item to exchange from stack
var amount : int

## The item index of the ItemList that represents the selected data
## visually
var list_index : int

func _init(p_stack : FlexStack, p_amount : int, p_list_index : int):
	stack = p_stack
	amount = p_amount
	list_index = p_list_index
extends Node
## Handles communication of events and data between objects in the game

## Emitted when a new StackTransfer is created
signal transfer_started(transfer : StackTransfer)

signal handler_changed(new : Object, old : Object)
# signal data_changed(data : ItemsTransferBus)
signal initiator_changed(initiator : Object)
signal target_changed(target : Object)

## Emit to let all interested parties know that a trade has started
signal trade_initiated(data : Trade)

signal trade_succeeded(trade : Trade)

signal trade_failed(trade : Trade)

signal shop_opened(shop : Shop)

## The handler that handles transferring of items data between containers and UI
## Set object must implement handle(data : StackTransfer)
var handler : Object :
	set(value):
		var old = handler
		handler = value
		handler_changed.emit(handler, old)
		
### The object that started the current transaction
#var initiator : Object :
	#set(value):
		#if(transferring):
			#push_error("Can't change initiator while transferring")
			#return
		#
		#initiator = value
		#initiator_changed.emit(initiator)
#
### The object that the initiator is trying to communicate with
#var target : Object :
	#set(value):
		#if(transferring):
			#push_error("Can't change target while transferring")
			#return
		#
		#target = value
		#target_changed.emit(target)
		#
### The current data being considered for transferring but not sent yet
#var transfer_data : StackTransfer :
	#set(value):
		#if(transfer_data == value):
			#return
		#
		#transfer_data = value
		#data_changed.emit(transfer_data)
#
#var transferring = false :
	#set(value):
		#transferring = value
		#
		#if(transferring == false):
			#transfer_data = null
#
### Request handling of a transfer
###
### Returns OK if successful or another error message
#func send(p_data : StackTransfer) -> Error:
	#if transferring:
		#return ERR_ALREADY_IN_USE
	#
	#transfer_data = p_data
	#transferring = true
	#assert(is_instance_valid(handler), "A handler must be set on the bus before transfers can be processed.")
	#var confirmed = await handler.handle(transfer_data)
	#var success = await transfer(transfer_data)
	#transferring = false
	#
	#return OK
	

## Creates a trade 
func trade(send_data : StackTransfer, receive_data : StackTransfer, inflow_money : float) -> Trade:
	var trade = Trade.new(send_data, receive_data, inflow_money)
	
	trade_initiated.emit(trade)
	
	var result = trade.trade()
	
	if result:
		trade_succeeded.emit(trade)
	else:
		trade_failed.emit(trade)
	
	return trade
	
## Tries to send item data from one container to another if confirmed
##
## Returns true if successful
func send(p_data : StackTransfer) -> bool:
	var confirmed : bool = await handler.get_confirmation(p_data)

	if confirmed:
		return p_data.execute()
	
	return false

### Given a participant in the current transaction, get the corresponding
### exchange partner - the other side of the exchange. Returns null
### if the participant is not valid
#func get_exchange_partner(participant : Object) -> Object:
	#if participant == initiator:
		#return target
	#
	#if participant == target:
		#return initiator
	#
	#push_warning(str(participant) + " is not a participant in the current transaction.")
	#return null

### Changes the initiator and participant on the bus if a transfer is not
### in progress
###
### Returns OK or an error code
#func set_transferer(p_initiator : Object, p_target : Object) -> Error:
	#if transferring:
		#return ERR_ALREADY_IN_USE
	#if not _validate_transferer(p_initiator):
		#return ERR_INVALID_PARAMETER
	#if not _validate_transferer(p_target):
		#return ERR_INVALID_PARAMETER
	#
	#initiator = p_initiator
	#target = p_target
	#
	#return OK
	
func _validate_transferer(transferer : Object) -> bool:
	var no_issues = true
	
	if not transferer.has_method("receive"):
		push_warning("Transferer " + str(transferer) + " has no receive(data : StackTransfer) -> Error method to accept StackTransfer")
		no_issues = false
		
	return no_issues
## Report data for bubbling up information about an illegal number of items belonging in a InventoryResource
class_name IllegalCountReport
extends RefCounted

var source: InventoryResource
var item: FlexItem
var current_count: int
var maximum_count: int

func _init(p_source: InventoryResource, p_item: FlexItem, p_current: int, p_max: int) -> void:
    source = p_source
    item = p_item
    current_count = p_current
    maximum_count = p_max## Represents an event where the count of an item in a container has changed.
## This class is used to encapsulate data about the item and its count changes.
class_name ItemCountChangedData
extends Object

## The item whose count has changed in the container.
var item: FlexItem

## The new count of the item after the change.
var new_count: int

## Initializes the event with the item that changed and its old and new counts.
## @param p_item The FlexItem whose countchanged.
## @param p_new_count The updated count of the item after the change.
func _init(p_item: FlexItem, p_new_count: int) -> void:
	item = p_item
	new_count = p_new_count
class_name Trade
extends Object
## For executing a trade between two objects
## TradeResult should be set when complete

enum Results { 
	SUCCESS, 
	CANCELED,
	ALREADY_EXECUTED,
	INITIATOR_INSUFFICIENT_MONEY, 
	TARGET_INSUFFICIENT_MONEY, 
	NO_ITEM_DATA 
	}

## The object considered to have started the trade
var initiator : ItemContainer

## The other side of the trade that was initiated
var target : ItemContainer

## The data to send to the target
var send_data : StackTransfer

## The data received from the target to the initiator
var receive_data : StackTransfer

## The expected difference in money as a result of the trade
## A positive number means more money is coming into the initiator
## out of the target than vise versa. Negative numbers are valid
## to add money to the target and remove from the initiator
var inflow_money : float

## For executing the trade, the enum messages that contribute to the outcome
## A proper success will only have the SUCCESS enum and nothing else
var reasons : Array[Results] = []

## The items that were sent to the target
var sent_items : StackTransfer

## The items that were received by the initiator
var received_items : StackTransfer

## Whether the trade has already been executed
var executed = false

func _init(
		p_send_data : StackTransfer,
		p_receive_data : StackTransfer, 
		p_inflow_money : float):
	send_data = p_send_data
	receive_data = p_receive_data
	inflow_money = p_inflow_money

## Executes a trade between parties
##
## Returns whether it was successful or not
func execute() -> bool:
	## TODO Implement where it will actually execute the trade if there are no invalid reasons
	reasons = get_invalid_reasons()
	
	if reasons.size() != 0:
		return false
		
	# Exchange money
	initiator.money += inflow_money
	target.money -= inflow_money
	initiator.receive(receive_data)
	target.receive(send_data)
	reasons.append(Results.SUCCESS)
	executed = true
	
	return true

## Validates the trade data given the current state of relevant objects
## If failed, results a trade result otherwise null
func get_invalid_reasons() -> Array[Results]:
	var invalid_reasons : Array[Results] = []
	
	if executed:
		invalid_reasons.append(Results.ALREADY_EXECUTED)
	
	var initiator_post_money = initiator.money + inflow_money
	
	if initiator_post_money < 0:
		invalid_reasons.append(Results.INITIATOR_INSUFFICIENT_MONEY)
	
	var target_post_money = target.money - inflow_money
	
	if target_post_money < 0:
		invalid_reasons.append(Results.TARGET_INSUFFICIENT_MONEY)
		
	if send_data == null && receive_data == null:
		invalid_reasons.append(Results.NO_ITEM_DATA)
		
	return invalid_reasons
	
class_name FlexActions
extends Resource
## A resource containing configurable action string names

## Increase the amount on the targeted or hovered UI control
@export var increase : StringName = "increase"

## Decrease the amount on the targeted or hovered UI control
@export var decrease : StringName = "decrease"

## Stronger increase action
@export var increase_more : StringName = "increase_more"

## Stronger decrease action
@export var decrease_more : StringName = "decrease_more"

## Action to toggle the inventory window on or off for the controlled character
@export var inventory : StringName = "inventory"

## Whether to enable shift as a modifier for numeric action input like increase or decrease.
## This is a workaround for situations like Mouse Wheel + Shift to increase more or decrease more.
@export var shift_modifier : bool = true
class_name FlexArrayExtensions
## Collection of static functions for organizing and modifying arrays

## Compares two arrays and finds all index positions
## where the two arrays do not match identically
##
## Returns an array of all unmatched indexes
static func find_unmatching_indexes(array_1 : Array, array_2 : Array) -> Array[int]:
	var unmatched : Array[int] = []
	var size_1 = array_1.size()
	var size_2 = array_2.size()
	var bigger_count = max(size_1, size_2)
	
	for i in range(0, bigger_count, 1):
		var value_1 = null
		var value_2 = null
		
		if i < size_1:
			value_1 = array_1[i]
		
		if i < size_2:
			value_2 = array_2[i]
			
		if value_1 != value_2:
			unmatched.append(i)
	
	return unmatched

## Simple swap of the data between two array index positions.
##
## Returns an updated array but does not modify the original.
static func swap(index_1 : int, index_2 : int, array : Array):
	var modified = array.duplicate()
	var stack_1 = modified[index_1]
	modified[index_1] = modified[index_2]
	modified[index_2] = stack_1
	return modified

## Moves an index data from one spot to before a target_index
##
## Returns the modified array
static func move(move_index : int, target_index : int, array : Array):
	var modified = array.duplicate()
	var moved_data = modified.pop_at(move_index)
	var modified_target_index = target_index
	
	if move_index < target_index:
		modified_target_index -= 1
	
	modified.insert(target_index, moved_data)
	
	return modified

## Moves data from indexes to target index and following spaces in the case of more move_indexes
## Pushes everything else in the array forward until null spaces are occupied
## 
## Returns the modified array
static func move_multi(target_index : int, move_indexes : Array[int], array : Array, move_in_front : bool):
	var modified = array.duplicate()
	
	# Extract data
	var move_datas = []
	move_datas.resize(move_indexes.size())
	
	var adjusted_target = target_index
	
	if move_in_front: 
		adjusted_target += 1
	
	var move_indexes_end_to_start = move_indexes.duplicate()
	move_indexes_end_to_start.sort()
	move_indexes_end_to_start.reverse()
	
	for i in move_indexes_end_to_start:
		var popped_data = modified.pop_at(i)
		var order = move_indexes.find(i)
		move_datas[order] = popped_data
		
		if i < target_index:
			adjusted_target -= 1  # Target shifts forward towards start
	
	move_datas.reverse() # Make last insert first
	adjusted_target = min(adjusted_target, modified.size()) # Cap adjusted target at array end
	
	for move_data in move_datas: 
		modified.insert(adjusted_target, move_data)
	
	return modified
		
## Inserts new null positions into the array at a start position pushing
## all positions after forwards in the array. This creates new spaces.
##
## Returns the modified array without effecting the original
static func insert_new_nulls(start: int, push_amount : int, array : Array):
	var modified = array.duplicate()
	var original_size = modified.size()
	modified.resize(original_size + push_amount)
	
	for i in range(modified.size() -1, start, -1):
		modified[i] = modified[i - push_amount]
		
	for i in range(start, start + push_amount, 1):
		modified[i] = null
	
	return modified
	
## Makes sure that all index values are actually in an array
static func validate_indexes_array(indexes : Array[int], array_size : int):
	var all_valid = true
	
	for index in indexes:
		if index >= 0 && index < array_size:
			continue
		else:
			push_error("Index value " + str(index) + " is not within array size of " + str(array_size))
			all_valid = false
	
	return all_valid
## A flexible inventory system that manages multiple ItemContainers.
## Handles item distribution, space management, and container organization.
class_name FlexInventory
extends InventoryResource

var _is_loading := false

signal money_changed(money: float)

## Settings that control inventory-wide behavior
@export var settings : InventorySettings :
	set(value):
		if settings == value:
			return
		
		settings = value
		_settings = settings # Set the InventoryResource settings reference for faster cached access

## All ItemContainers that the inventory holds [br][br]
## Use add_container / remove_container methods to modify so the inventory property updates on the container
@export var item_containers: Array[ItemContainer] :
	set(value):
		item_containers = value
		
		# Set the inventory reference for each ItemContainer
		for container in item_containers:
			if container:
				container.parent = self
				container.root = self  # Set root to this inventory

## Amount of money stored in the container
@export var money: float :
	set(value):
		if money == value:
			return
		money = value
		money_changed.emit(money)

## The game object that manages this inventory
var manager: Object

func _init(p_item_containers: Array[ItemContainer] = [], p_money: float = 0.0):
	root_changed.connect(_on_root_changed)  # Connect to root change signal
	item_containers = p_item_containers # Automatically handles setting Inventory reference for each item container
	money = p_money

## Call before loading inventory state
func begin_loading() -> void:
	_is_loading = true

## Call after inventory state is fully loaded
## This triggers validation and redistribution if needed
func end_loading() -> void:
	_is_loading = false
	_validate_and_redistribute()

## Validates all stacks and attempts redistribution if needed
func _validate_and_redistribute() -> void:
	_redistribution_manager.validate_and_redistribute(self)

func _on_redistribution_failed(resource: InventoryResource, stack: FlexStack, overflow: int) -> void:
	push_error("Failed to redistribute %d items from stack %s in %s" % [
		overflow,
		stack.resource_name,
		resource.resource_path
	])

func _on_redistribution_completed(_resource: InventoryResource) -> void:
	push_warning("Completed redistribution for inventory %s" % resource_path)

## Tries to add the items to the Inventory. Will do a partial add if
## there is not enough space.
##
## Returns the total amount added
func add_items(p_item: FlexItem, p_count: int) -> int:
	var total_space: int = get_item_space(p_item)
	var remaining: int = p_count
	var transferred: int = 0
	
	for container in item_containers:
		var added = container.add_items(p_item, remaining)
		remaining -= added
		transferred += added
		
		if remaining == 0:
			break
	
	return transferred

## Gets the total count of a specific item type across all containers
func get_item_count(p_item: FlexItem) -> int:
	var total := 0
	for container in item_containers:
		var count = container.get_item_count(p_item)

		if count == InventoryConstants.INFINITE:
			return InventoryConstants.INFINITE
			
		total += count
	return total

## Tries to remove the item from the inventory. Returns the count removed.
func remove_items(p_item: FlexItem, p_count: int, p_partial_remove := false) -> int:
	var remainder := p_count
	var total: int = 0
	
	# Validate total item count first if partial remove is not allowed
	if not p_partial_remove:
		if get_item_count(p_item) < p_count:
			return 0  # Fail if not enough items available
	
	# Proceed with removal if validation passes
	for container in item_containers:
		var removed := container.remove_items(p_item, remainder, p_partial_remove)
		total += removed
		remainder -= removed
		if remainder == 0:
			break
		
	return total

## Get the maximum number of items that can currently be transferred into the inventory of the FlexItem type
func get_item_space(p_type: FlexItem) -> int:
	var space: int = 0
	
	for container in item_containers:
		space += container.get_space(p_type)

	return space

## Get the total number of possible stacks across all ItemContainers within the inventory
func get_total_stacks() -> int:
	var total = 0
	
	for container in item_containers:
		total += container.type.size
	
	return total

## Gets the total number of items in the inventory that have the matching tag or any of its subcategories
## across all item_containers. Matches are based on tag instance reference and hierarchy.
func get_item_count_with_tag(p_tag: ItemTag) -> int:
	if p_tag == null:
		return 0  # No tag to match
	var total = 0
	for container in item_containers:
		for stack in container.get_stacks():  # Direct access to stacks
			if stack.item and stack.item.tags.any(func(t): return t == p_tag or t.is_subcategory_of(p_tag)):
				total += stack.count
	return total

## Adds an ItemContainer to the inventory and sets its inventory reference
func add_container(container: ItemContainer) -> void:
	if not item_containers.has(container):
		container.parent = self
		container.root = self  # Set root directly
		item_containers.append(container)

## Removes an item_container from the Inventory if it exists [br][br]
## Returns whether remove was successfuly
func remove_container(container: ItemContainer) -> bool:
	if item_containers.has(container):
		item_containers.erase(container)
		container.parent = null
		container.root = null  # Clear root reference
		return true
	return false

# Get the total space available for a FlexItem across all ItemContainers
func get_space(p_item : FlexItem) -> int:
	var space := 0
	
	for container in item_containers:
		var container_space = container.get_space(p_item)

		## Return the maximum INFINITE value for remaining space
		if container_space == InventoryConstants.INFINITE:
			return InventoryConstants.INFINITE

		space += container_space

	return space

## Checks if any of the contained ItemContainers allow the given item type
## Returns true if at least one container accepts the item type
func allows_type(p_item: FlexItem) -> bool:
	# Check if any container allows this item type
	for container in item_containers:
		if container.allows_type(p_item):
			return true
	
	return false

## Updates container root references when inventory root changes
func _on_root_changed(_old_root: InventoryResource, new_root: InventoryResource) -> void:
	for container in item_containers:
		if container:
			container.root = new_root

## Loading the inventory state should set up the data and then report that the loading has finished
## Only then should it try to redistribute illegal stacks
func load_state(data: Dictionary) -> void:
	push_error("NOT IMPLEMENTED") # This is a placeholder for the actual implementation

	# Prevent validation and redistribution during loading until finished
	begin_loading()
	
	# Load all container/stack data...
	var loaded_containers : Array[ItemContainer] = data.containers

	for item_container_data in data["item_containers"]:
		var container = ItemContainer.new()
		container.load_state(item_container_data)
		loaded_containers.append(container)
	
	end_loading()  # Triggers validation and redistribution
@icon("../art/settings.png")
class_name InventorySettings
extends Resource

## Whether to allow partial item additions when there isn't space for the full amount
## Set to true to allow adding as many items as possible
## Set to false to require space for all items or none will be added
@export var allow_partial_adds: bool = true

# Number high enough to represent infinite items in the inventory
const INFINITE = 10000000
## A flexible inventory container for managing FlexStacks of FlexItems in games.
## Handles item stacking, space management, and item validation.
class_name ItemContainer
extends InventoryResource

## Emitted when the count of an item type changes, providing detailed change data.
signal item_count_changed(change: ItemCountChangedData)

## Emitted when the number or type of an item that a stack is having changes
signal stack_modified(stack: FlexStack)

## Emitted when a new FlexStack is added to the container’s slots.
signal stack_added(stack: FlexStack)

## Emitted when a FlexStack is completely removed from the container’s slots.
signal stack_removed(stack: FlexStack)

## Emitted when a FlexItem is added to the item_container for the first time.
signal item_added(item: FlexItem)

## Emitted when a FlexItem is fully removed from the item_container (count reaches zero).
signal item_removed(item: FlexItem)

## Emitted when the _slots array is directly modified or replaced.
signal slots_changed(slots: Array[FlexStack])

## Defines the container’s rules and capabilities (e.g., size, allowed tags).
@export var type: ItemContainerType :
	set(value):
		if type == value:
			return
		type = value
		var issues = validate()
		if not issues.is_empty():
			for problem in issues:
				push_warning(problem)

## Material stack slots for the item_container [br][br]
## Access via add_items and remove_items, not directly
@export var _slots: Array[FlexStack] = []:
	set(value):
		if _slots == value: 
			return
			
		# Remove parent reference from old slots if this container is their parent
		for stack in _slots:
			if stack and stack.parent == self:
				stack.parent = null
				stack.root = null  # Clear root when removing
				
		_slots = value
		
		# Update each stack's references
		for i in _slots.size():
			if _slots[i]:
				_setup_stack_references(_slots[i], i)
		
		slots_changed.emit(_slots)

func _init(p_type: ItemContainerType = null, p_parent: FlexInventory = null) -> void:
	if p_type: 
		type = p_type
	else:
		push_warning("ItemContainer created without type at %s" % resource_path)
	
	parent = p_parent  # Parent is FlexInventory
	handle_empty_space(_slots)
	root_changed.connect(_on_root_changed)  # Connect to root change signal
	
	# Validate initial setup
	var issues = validate()
	if not issues.is_empty():
		for problem in issues:
			push_warning(problem)

func _ready() -> void:
	stack_added.connect(_on_stack_added)
	stack_removed.connect(_on_stack_removed)

## Adds items to stacks if room exists and item matches or is null
## Returns the total amount added
func add_to_stacks(stacks: Array[FlexStack], max_to_add: int, item: FlexItem) -> int:
	if max_to_add < 0:
		push_error("Negative amount to add: %d" % max_to_add)
		return 0
	var remaining = max_to_add
	for stack in stacks:
		if remaining <= 0: break
		if stack.item == null: stack.item = item
		if stack.item == item:
			var added = min(remaining, stack.item.stack_maximum - stack.count)
			stack.count += added
			stack_modified.emit(stack)  # Notify stack modification
			remaining -= added
			
			if not type.allow_multiple_stacks:
				break
			
	return max_to_add - remaining

## Gets the maximum remaining space for a given item
## Returns the number of items that can be added
func get_space(p_item: FlexItem) -> int:
	if type.has_unlimited_space:
		return InventoryConstants.INFINITE

	var space = 0
	
	if not does_it_allow(p_item):
		return 0
	
	# Count space in existing stacks
	for slot in _slots:
		if slot.item == p_item || slot.item == null:  # Only count matching or empty slots
			var found_space = slot.get_space(p_item)
			space += found_space

			# For non-multiple stacks, return after first available space
			if not type.allow_multiple_stacks && space > 0:
				return min(space, p_item.stack_maximum)
	
	if type.has_unlimited_space:
		return int(INF)  # Direct use of INF, no abs() needed
		
	# Add space from undeclared slots (only those beyond current _slots.size())
	var undeclared_slots = max(0, type.size - _slots.size())
	space += undeclared_slots * p_item.stack_maximum
	
	# Account for single stack limit
	if not type.allow_multiple_stacks:
		space = min(space, p_item.stack_maximum)
	
	assert(space >= 0, "Space should not be negative")
	return space

## Gets the stacks that currently contain the p_item FlexItem type
func get_stacks_with_item(p_item: FlexItem) -> Array[FlexStack]:
	var matching: Array[FlexStack] = []
	
	for stack in _slots:
		# Stack must have the type assigned and have a count above 0 to be a stack with the item
		if stack.item == p_item && stack.count > 0:
			matching.append(stack)
	
	# Validate
	if not type.allow_multiple_stacks && matching.size() > 1:
		push_warning("Container does not allow multiple stacks of the same item but has %s" % matching)
	
	return matching

## The count of an item type across all tested stacks (the item_container's _slots by default)
func get_item_count(item: FlexItem, stacks: Array[FlexStack] = _slots) -> int:
	var total : int = 0
	
	for slot in stacks:
		if slot.item == item and slot.infinite:
			return InventoryConstants.INFINITE

		if slot.item == item: 
			total += slot.count
			
	return total

## Gets all FlexStack slots declared in the item_container but are empty (0 count)
func get_empty_stacks() -> Array[FlexStack]:
	var empty: Array[FlexStack] = []
	for slot in _slots:
		if slot.item == null or slot.count == 0:
			empty.append(slot)
	return empty

## Gets the number of unused slots (empty or extra space not declared in _slots)
func get_unused_count() -> int:
	var total = get_empty_stacks().size()		# Declared but empty
	total += max(0, type.size - _slots.size())	# Undeclared
	return total

## Returns the ItemStacks in the item_container slots
func get_stacks() -> Array[FlexStack]:
	return _slots

## Returns the index of an item stack if it exists
func get_index(stack: FlexStack) -> int:
	return _slots.find(stack)

## Gets the index of each stack in p_stacks as a dictionary
func get_indexes(stacks: Array[FlexStack]) -> Dictionary[FlexStack, int]:
	var indexes: Dictionary[FlexStack, int] = {}
	for stack in stacks:
		var index = get_index(stack)
		if index < 0:
			push_warning("Stack %s not in %s" % [stack, self])
		indexes[stack] = index
	return indexes



## Adds an amount of an item to the item_container, creating new stacks if needed
## Returns the amount successfully added
func add_items(item: FlexItem, amount: int) -> int:
	if not _can_add_items(item, amount):
		return 0

	var remaining = amount
	remaining = _fill_existing_stacks(item, remaining)
	
	if remaining == amount || type.allow_multiple_stacks: # Stop if remaining changed and not allowing multiple stacks
		remaining = _add_to_unused_stacks(item, remaining)
	
	if remaining == amount || type.allow_multiple_stacks:
		remaining = _create_new_stacks(item, remaining)

	var added = amount - remaining
	_notify_items_added(item, added)
	return added

## Tries to remove materials, fails if not enough without partial removal
## Returns the amount removed
func remove_items(item: FlexItem, amount: int, allow_partial_remove: bool = false) -> int:
	if !validate_item(item, amount): return 0 # If not valid for inventory, do nothing
	if has_infinite(item): return amount # If infinite, remove nothing
	
	var positions = find_positions_of_item(item, _slots)
	if positions.is_empty(): return 0
	var total = get_item_count(item)
	if not allow_partial_remove and total < amount: return 0
	var remaining = amount
	var removed = 0
	var reversed = positions.duplicate()
	reversed.reverse()
	
	for pos in reversed:
		var slot = _slots[pos]
		var to_remove = min(slot.count, remaining)
		slot.count -= to_remove
		remaining -= to_remove
		removed += to_remove
		stack_modified.emit(slot)  # Notify stack modification
		if remaining == 0: break
		
	if removed > 0:
		var data = ItemCountChangedData.new(item, get_item_count(item))
		item_count_changed.emit(data)  # Updated to match signal signature
		handle_empty_space(_slots)
		if get_item_count(item) == 0: item_removed.emit(item)
		
	return removed

## Returns the array positions of all stacks matching the item
func find_positions_of_item(item: FlexItem, stacks: Array[FlexStack]) -> Array[int]:
	var positions: Array[int] = []
	for i in stacks.size():
		if stacks[i].item == item:
			positions.append(i)
	assert(does_it_allow(item) or positions.is_empty())
	return positions

## Determines whether the item’s tags are in the allowed tags list
func does_it_allow(item: FlexItem) -> bool:
	if not item: return false
	if type.allowed_tags.is_empty(): return true
	for tag in type.allowed_tags:
		if item.tags.has(tag): return true
	return false

## Removes data from each stack in the item_container and then
## handles the empty stacks appropriately
func clear() -> int:
	var cleared: int = 0
	for stack in _slots:
		stack.clear()
		cleared += 1
	handle_empty_space(_slots) # Depending on setup, ignore or remove the cleared stacks
	return cleared

## Returns an array of item types in the item_container
func get_item_types(stacks: Array[FlexStack] = _slots) -> Array[FlexItem]:
	var items: Array[FlexItem] = []
	for stack in stacks:
		if stack.item and not items.has(stack.item):
			items.append(stack.item)
	return items

## Determine whether any stack has an infinite amount of the item
func has_infinite(item: FlexItem) -> bool:
	for stack in _slots:
		if stack.item == item and stack.infinite: return true
	return false

## Gets stacks with counts of items that have a specific tag
func get_stacks_with_tag(tag: ItemTag) -> Array[FlexStack]:
	var stacks: Array[FlexStack] = []
	for item in get_item_types():
		if item and item.tags.has(tag):
			stacks.append(FlexStack.new(item, get_item_count(item)))
	return stacks

## Gets the total count of items with a given tag
func get_item_count_with_tag(tag: ItemTag) -> int:
	var total = 0
	for stack in get_stacks_with_tag(tag):
		total += stack.count
	return total

## Ensure the ItemContainer has proper setup
## Returns an array of problem descriptions
func validate() -> Array[String]:
	var issues: Array[String] = []
	
	if not type:
		issues.append("No type assigned to ItemContainer %s" % resource_path)
		return issues
	
	# Validate stacks
	for stack in _slots:
		if not stack.validate():
			issues.append("Stack %s failed validation" % stack.resource_name)
		
		if stack.item_container != self:
			issues.append("Stack %s has incorrect item_container reference" % stack.resource_name)
		
		if stack.slot != _slots.find(stack):
			issues.append("Stack %s has incorrect slot %d, expected %d" % [
				stack.resource_name, 
				stack.slot, 
				_slots.find(stack)
			])
	
	return issues

## Validates an item and amount for use in the item_container
## Returns true if valid, false otherwise
func validate_item(item: FlexItem, amount: int) -> bool:
	var no_issues = true
	
	if amount < 0 and not has_infinite(item):
		push_warning("Negative amount to %s. If item_container %s has none of the item %s, it probably should not be in the item_container." % [resource_path, resource_path, item.resource_path])
		no_issues = false
	if not item:
		push_error("Null item in item_container %s" % resource_path)
		no_issues = false
	if not does_it_allow(item):
		var item_path: String = "NULL Item" if item == null else item.resource_path 
		push_warning("Item not allowed: %s" % item_path)
		no_issues = false
		
	return no_issues

## Handles empty slots based on the ContainerType’s EmptyMode
func handle_empty_space(p_stacks: Array[FlexStack]) -> void:
	if type == null:
		return # No type defined to know how to handle empty space
	
	match type.empty_mode:
		ItemContainerType.EmptyMode.FILL: _fill_empty_space()
		ItemContainerType.EmptyMode.REMOVE: _remove_empty_stacks(p_stacks)
		ItemContainerType.EmptyMode.IGNORE: pass

## Removes empty stacks from the item_container
func _remove_empty_stacks(p_stacks: Array[FlexStack]) -> void:
	for stack in p_stacks:
		if stack == null:
			continue
		
		var has_stack = _slots.has(stack)
		
		if not has_stack: # Expected to be the case for swaps
			continue 
		
		if stack.count <= 0 || stack.item == null:
			_slots.erase(stack)
			if stack.parent == self:  # Only clear if we're the parent
				stack.parent = null
			stack.item_container = null
			stack.slot = -1
			stack_removed.emit(stack)

## Fills empty space with no-item, zero-count stacks
func _fill_empty_space() -> void:
	while _slots.size() < type.size:
		var new_stack = FlexStack.new(null, 0, self, _slots.size())
		_setup_stack_references(new_stack, _slots.size())
		_slots.append(new_stack)
		stack_added.emit(new_stack)

## Checks if the item and amount can be added based on validation and item_container rules
func _can_add_items(item: FlexItem, amount: int) -> bool:
	if not validate_item(item, amount):
		return false
	if not allows_partial_adds():
		var space := get_space(item)
		return space >= amount
		
	return true

## Fills existing stacks with matching items, returning remaining amount
func _fill_existing_stacks(item: FlexItem, remaining: int) -> int:
	for slot in _slots:
		if slot.item == item && slot.count < item.stack_maximum:
			var to_add = min(remaining, item.stack_maximum - slot.count)
			slot.count += to_add
			stack_modified.emit(slot)  # Notify stack modification
			remaining -= to_add
			
			if not type.allow_multiple_stacks:
				return remaining # Only use the first stack found
	return remaining

## Fills empty slots with the item, returning remaining amount
func _add_to_unused_stacks(item: FlexItem, remaining: int) -> int:
	var empty_slots = get_empty_stacks()
	for stack in empty_slots:
		if stack.slot != _slots.find(stack):  # Ensure slot is correct
			stack.slot = _slots.find(stack)
	return remaining - add_to_stacks(empty_slots, remaining, item)

## Creates new stacks for the item if space allows, returning remaining amount
func _create_new_stacks(item: FlexItem, remaining: int) -> int:
	var max_new_slots = type.size - _slots.size() if type.allow_multiple_stacks else 1
	var slots_left = max_new_slots
	
	while remaining > 0 and slots_left > 0:
		var new_stack = FlexStack.new(item, 0, self, _slots.size())
		_setup_stack_references(new_stack, _slots.size())
		var to_add = min(remaining, item.stack_maximum)
		new_stack.count = to_add
		_slots.append(new_stack)
		stack_added.emit(new_stack)
		stack_modified.emit(new_stack)
		remaining -= to_add
		slots_left -= 1
		new_stack.count_changed.connect(_on_stack_count_changed)
		new_stack.item_changed.connect(_on_stack_item_changed)
			
	return remaining

## Emits signals if items were added
func _notify_items_added(item: FlexItem, added: int) -> void:
	assert(added >= 0)
	if added > 0:
		var data = ItemCountChangedData.new(item, get_item_count(item))
		item_count_changed.emit(data)  # Updated to match signal signature
		if not get_item_types().has(item):
			item_added.emit(item)

func _on_stack_count_changed(p_stack: FlexStack) -> void:
	handle_empty_space([p_stack] as Array[FlexStack])
	stack_modified.emit(p_stack)  # Notify external listeners

func _on_stack_item_changed(p_stack: FlexStack) -> void:
	handle_empty_space([p_stack] as Array[FlexStack])
	stack_modified.emit(p_stack)  # Notify external listeners

## Set the stack's parent to the item container
func _on_stack_added(stack: FlexStack) -> void:
	stack.parent = self

## Removes the ItemContainer as the stack's parent if it is set to this container on remove
func _on_stack_removed(stack: FlexStack) -> void:
	if stack.parent == self:
		stack.parent = null

## Moves a stack to a new slot index within the item_container
func move_stack(stack: FlexStack, new_slot_index: int) -> bool:
	var current_index = _slots.find(stack)
	if current_index == -1:
		push_warning("Stack %s not found in item_container" % stack)
		return false
	if new_slot_index < 0 or new_slot_index >= type.size:
		push_warning("Invalid slot index %d for item_container size %d" % [new_slot_index, type.size])
		return false
	if current_index == new_slot_index:
		return true  # No move needed
	
	# Remove from current position
	_slots.remove_at(current_index)
	
	# Insert at new position, adjusting for shifted indices
	if new_slot_index > current_index:
		new_slot_index -= 1  # Adjust for removal
	_slots.insert(new_slot_index, stack)
	
	# Update stack's slot and item_container references
	stack.slot = new_slot_index
	stack.item_container = self
	
	# Update slots of all affected stacks
	for i in _slots.size():
		if _slots[i] and _slots[i].slot != i:
			_slots[i].slot = i
	
	slots_changed.emit(_slots)
	return true

## Checks if this container allows the given item type based on container type settings
## Returns true if:
## - Container type exists and has no tag restrictions (empty allowed_tags)
## - Item has a tag that matches or is a subcategory of any allowed tag
## Returns false if:
## - No container type is set
## - Item doesn't match any allowed tags or their subcategories
func allows_type(p_item: FlexItem) -> bool:
	# No container type means no validation possible
	if not type:
		push_warning("No container type set for %s" % self)
		return false
		
	# Empty allowed_tags means any item is allowed
	if type.allowed_tags.is_empty():
		return true
		
	# Check if any of item's tags match or inherit from allowed tags
	for item_tag in p_item.tags:
		for allowed_tag in type.allowed_tags:
			if item_tag.matches(allowed_tag):
				return true
	
	return false

## Updates a stack's references when added to this container 
func _setup_stack_references(stack: FlexStack, slot_index: int) -> void:
	stack.parent = self
	stack.root = root  # Pass down our root reference
	stack.item_container = self 
	stack.slot = slot_index
	
	# Skip validation during loading
	if root and root is FlexInventory and (root as FlexInventory)._is_loading:
		return

## Updates stack root references when container root changes
func _on_root_changed(_old_root: InventoryResource, new_root: InventoryResource) -> void:
	for stack in _slots:
		if stack:
			stack.root = new_root
class_name ItemContainerType
extends Resource
## Defines details about a type of ItemContainer within the game for reusability

## How the item container should handle empty (Defined as null FlexItem or <= 0 count) FlexStacks 
enum EmptyMode { 
	FILL, 		## Auto fill _slots until every slot has an item stack (up to maximum stacks even if unlimited space)
	IGNORE, 	## Do nothing
	REMOVE, 	## Auto remove any empty ItemStacks
}

## Display name for the ItemContainer
@export var name : StringName

## Texture that represents the item_container
@export var icon : Texture

## Allowed items to be stored in the container. Allows any if not set.
@export var allowed_tags : Array[ItemTag] = []

## Limits the maximum number of stacks that can be created in the container
@export var size : int = 12

## Whether to allow multiple stacks of the same item in the container or not
@export var allow_multiple_stacks : bool = true

## If set, will limit the container by the maximum stacks to be the number
## of possible spaces
@export var has_unlimited_space : bool = false

## Determines how the container handles empty slots or stacks
@export var empty_mode : EmptyMode
class_name FlexItem
extends Resource
## Base class for an resource that can be added to and removed from
## flex inventories

## The gameplay name representation for the item name
@export var name : String

## The display image that represents the item in ui
@export var icon : Texture2D

## Marker resources that indicate which categories this
## item qualifies for. Used for comparisons. This can be any
## resource but should be stored as a file in the project so you can
## reference it between different objects that use tags
@export var tags: Array[ItemTag] = []

## The base currency value of the item within the game
@export var value : float
	   
## The maximum number of a material that can exist in one item_stack
@export_range(0,1000, 1, "or_greater") var stack_maximum : int = 1

func _init(p_name : String = "", p_icon : Texture2D = null, 
p_tags : Array[ItemTag] = [], p_stack_maximum : int = 1):
	name = p_name
	icon = p_icon
	tags = p_tags
	stack_maximum = p_stack_maximum

func _to_string() -> String:
	return name
class_name FlexStack
extends InventoryResource

## Emitted when the item value changes on the stack
signal item_changed(stack: FlexStack)

## Emitted when the count of items changes on the stack
signal count_changed(stack: FlexStack)

## The type of FlexItem that is held in the stack
@export var item: FlexItem :
	set(value):
		if item == value:
			return
		
		item = value
		item_changed.emit(self)

## How many of the item that the stack represents
@export var count: int :
	set(value):
		if count == value:
			return
			
		count = value
		count_changed.emit(self)
		
		if count <= 0:
			item = null
			return
			
		# Report illegal count but don't modify
		if item and not infinite and count > item.stack_maximum:
			report_illegal_count(item, count, item.stack_maximum)


## Whether the stack represents an infinite number of the item regardless of what the count value is
@export var infinite: bool = false

## The ItemContainer that this stack is stored within
var item_container: ItemContainer :
	set(value):
		item_container = value
		# Optionally validate or update state when item_container changes
		if item_container and item and not item_container.does_it_allow(item):
			push_warning("Item %s not allowed in item_container %s" % [item.resource_path if item else "null", item_container.resource_path if item_container else "null"])

## The slot index within the item_container where this stack resides
var slot: int = -1  # -1 indicates unassigned

func _init(p_item: FlexItem = null, p_count: int = 0, p_item_container: ItemContainer = null, p_slot: int = -1):
	## Initializes the stack with an item, count, and optional item_container and slot.
	item = p_item
	count = p_count
	item_container = p_item_container
	slot = p_slot

## Removes the item data in the stack making it become an empty stack
## but note that the stack resource still exists.
func clear() -> void:
	item = null
	count = 0
	# Note: item_container and slot are not cleared, as the stack may still occupy a slot

## Gets the count of infinite placeholder
func get_effective_count() -> int:
	if infinite:
		return InventoryConstants.INFINITE
	return count

## Returns the number that can fit inside of the stack
func get_space(p_item: FlexItem) -> int:
	if not allows_type(p_item):
		return 0

	if infinite:
		return int(INF)

	if item == null:
		return p_item.stack_maximum
		
	if item == p_item:
		return p_item.stack_maximum - count
	
	return 0 # Different type

## Checks if this stack can accept the given item type by validating with parent
## Returns false if no parent exists or if item type is not allowed
func allows_type(p_item: FlexItem) -> bool:
	# Constrained by parent unless no parent is set, else default true
	return parent.allows_type(p_item) if parent != null else true

## Override to enable stack swapping with validation
## Returns true if the selection represents a full stack or empty stack
func can_swap(p_selection: StackSelection) -> bool:
	## The amount on the selection must be 0 or equal to the stack count
	if not p_selection.amount == 0 or p_selection.amount == p_selection.stack.count:
		return false

	## Both stacks must be able to accept each others items
	if not allows_type(p_selection.get_item()) and p_selection.stack.allows_type(item):
		return false
		
	return true

## Adds items to this stack
## Returns the number of items successfully added
func add_items(p_item: FlexItem, p_count: int) -> int:
	
	# Check if we can accept this item type
	if not allows_type(p_item):
		return 0
	
	# Handle empty stack case
	if item == null:
		item = p_item
		count = min(p_count, p_item.stack_maximum)
		return count
	
	# Must be same item type to add
	if item != p_item:
		return 0
	
	# Handle infinite stack case
	if infinite:
		count += p_count
		return p_count
	
	# Calculate how many can fit
	var space_available := item.stack_maximum - count
	var amount_to_add := min(space_available, p_count)
	
	if amount_to_add > 0:
		count += amount_to_add
	else:
		push_warning("FlexStack.add_items - No space available")
	
	return amount_to_add

## Gets the total count of a specific item type in this stack
## Returns stack count if item matches, 0 otherwise
func get_item_count(p_item: FlexItem) -> int:
	if infinite:
		return InventoryConstants.INFINITE

	return count if item == p_item else 0

## Validates the stack to make sure it is configured correctly
func validate() -> bool:
	if infinite:
		return true
	
	return count >= 0 and (item == null or count <= item.stack_maximum)

## Checks that the number of items in the stack is valid given the FlexItem type
func _validate_count() -> bool:
	if infinite:
		return true  # Infinite stacks are always valid
	
	var below_0 = count < 0
	var violates_item_max = item != null && count > item.stack_maximum
	
	if below_0 || violates_item_max:
		push_warning("Count of stack %s is set to unallowed value of %d" % [resource_path, count])
		return false
		
	return true

## Returns this stack as the swap target
## Used during stack swap operations
func get_swap_target(_other_stack: FlexStack) -> FlexStack:
	return self

## Bubble up a signal to report the illegal count for redistribution
func _report_illegal_count(item: FlexItem, count: int, max_count: int) -> void:
	var report := IllegalCountReport.new(self, item, count, max_count)
	illegal_count_detected.emit(report)
class_name ItemTag
extends Resource
## Tag resource to categorize items inside and outside of the flex_inventory system.
## Each tag instance represents a category, with 'name' as its textual representation.

## Textual representation of the tag for display purposes (e.g., "Weapon", "Armor").
@export var name: StringName = ""

## Human-readable description of the tag’s purpose or meaning.
@export var description: String = ""

## Optional parent tag defining this tag as a subcategory (e.g., "Weapon" under "Equipment").
@export var parent: ItemTag = null

## Optional color for UI representation or debugging.
@export var color: Color = Color.WHITE

func _init(p_name: StringName = "", p_parent: ItemTag = null) -> void:
	name = p_name
	parent = p_parent

## Default equality operator uses reference comparison.
## Tags are considered equal if they are the same instance, not based on name.
func _eq(other: Variant) -> bool:
	return is_same(self, other)

## String representation for debugging or display, using the name property.
func _to_string() -> String:
	if parent:
		return "ItemTag('%s', parent: '%s')" % [name, parent.name]
	return "ItemTag('%s')" % name

## Checks if this tag is a subcategory of the given tag (direct or indirect).
func is_subcategory_of(tag: ItemTag) -> bool:
	if tag == null:
		return false
	var current = self
	while current != null:
		if is_same(current, tag):  # Reference comparison
			return true
		current = current.parent
	return false

## Checks if this tag matches the given tag (directly or via inheritance)
## Returns true if this tag is either:
## - The same as the given tag
## - A subcategory (direct or indirect) of the given tag
func matches(tag: ItemTag) -> bool:
	if tag == null:
		return false
	var current = self
	while current != null:
		if is_same(current, tag):  # Reference comparison
			return true
		current = current.parent
	return false
@tool
extends EditorPlugin

const FLEX_STATE = "FlexState"

func _enter_tree():
	self.add_autoload_singleton(FLEX_STATE, "res://addons/flex_inventory/flex_state.tscn")

func _exit_tree():
	# Clean-up of the plugin goes here.
	if Engine.has_singleton(FLEX_STATE):
		self.remove_autoload_singleton(FLEX_STATE)
class_name InventoryConstants

# Maximum 32-bit signed integer
const INFINITE: int = 2147483647class_name Shop
extends FlexInventoryNode
## Shop component that emits signals for shop open and closing for the shop inventory

signal shopper_changed(shopper: Node)
signal shopper_inventory_changed(item_container: ItemContainer)
signal buy_multiplier_changed(new_value: float)
signal sell_multiplier_changed(new_value: float)

## The FlexInventory holding the items for what the shop can sell
@export var inventory_stock: FlexInventory

## OPTIONAL. The FlexInventory where items sold to the shop go if any.
## If null, items disappear into the void after selling.
@export var inventory_buy_back: FlexInventory

## The display name of the shop. Should show in the UI.
@export var display_name : StringName = "Shop"

@export var stats = ShopStats.new()

## The owning character of the shop
@export var manager: Node

## Calculates trades for the shop
var trade_calculator: TradeCalculator

## Calculates buybacks at the sell price
var buy_back_calculator: TradeCalculator

### Items to buy back
#var buy_back_selection: StackTransfer :
	#set(value):
		#if is_instance_valid(buy_back_selection):
			#buy_back_selection.transfer_data_changed.disconnect(_on_transfer_data_changed)
			#
		#buy_back_selection = value
		#
		#if is_instance_valid(buy_back_calculator):
			#buy_back_calculator.buy_data = buy_back_selection
		#
		#if is_instance_valid(buy_back_selection):
			#buy_back_selection.transfer_data_changed.connect(_on_transfer_data_changed)
#
### Items to buy from the shop
#var buy_selection: StackTransfer :
	#set(value):
		#if is_instance_valid(buy_selection):
			#buy_selection.transfer_data_changed.disconnect(_on_transfer_data_changed)
			#
		#buy_selection = value
		#
		#if is_instance_valid(trade_calculator):
			#trade_calculator.buy_data = buy_selection
		#
		#if is_instance_valid(buy_selection):
			#buy_selection.transfer_data_changed.connect(_on_transfer_data_changed)

## Items to sell to the shop
#var sell_selection: StackTransfer :
	#set(value):
		#if is_instance_valid(sell_selection):
			#sell_selection.transfer_data_changed.disconnect(_on_transfer_data_changed)
			#
		#sell_selection = value
		#
		#if is_instance_valid(trade_calculator):
			#trade_calculator.sell_data = sell_selection
		#
		#if is_instance_valid(sell_selection):
			#sell_selection.transfer_data_changed.connect(_on_transfer_data_changed)

## The character doing the shopping at the shop
var shopper: Node :
	set(value):
		if shopper == value:
			return
			
		shopper = value
		shopper_changed.emit(shopper)

## The inventory of the character doing the shopping at the shop
var shopper_inventory: FlexInventory :
	set(value):
		if shopper_inventory == value:
			return
			
		shopper_inventory = value
		
		# Reset the transfer data with the new container
		# _reset_selections()
		shopper_inventory_changed.emit(shopper_inventory)

func _ready() -> void:
	_create_sub_objects()
	validate()

# Modifies the shopper and selected shopper inventory for interacting with the
# shop
func change_shopper(p_shopper: Node, p_shopper_inventory: FlexInventory):
	shopper = p_shopper
	shopper_inventory = p_shopper_inventory
	
## Clears the current shopper and transactions
func clear():
	shopper = null
	shopper_inventory = null
	# buy_selection.clear()
	# sell_selection.clear()

## Receives data from a shopper, either adding it to the sell list
## or instantly selling it to the shop
func receive(data: StackTransfer) -> Error:
	if not validate_receive_data(data):
		return ERR_INVALID_PARAMETER
	
	#if sell_selection != null:
		#sell_selection.combine(data)
		#return OK
		
	## Execute the trade otherwise
	var result = trade(null, data)
	
	if result != null:
		return OK
	else:
		return ERR_INVALID_DATA

## Checks data to see whether it is valid for receiving into the shop or not
func validate_receive_data(data: StackTransfer) -> bool:
	if data.source == shopper_inventory:
		return true
	else:
		return false

## Executes a trade between buy_data and sell_data from/to the shop
func trade(buy_data: StackTransfer, sell_data: StackTransfer) -> Trade:
	var total_spend = trade_calculator.calculate_trade(buy_data, sell_data)
	
	# Adjust buy_data target to inventory_stock if available
	if buy_data and buy_data.target == null and inventory_stock != null:
		buy_data.target = inventory_stock
	# Adjust sell_data target to inventory_buy_back if available
	if sell_data and sell_data.target == null and inventory_buy_back != null:
		sell_data.target = inventory_buy_back
	
	var result: Trade = FlexState.exchange(buy_data, sell_data, total_spend)
	return result
	
## Validate the state of the shop
func validate() -> bool:
	var no_issues = true
	
	if inventory_stock == null:
		push_warning("No stock inventory defined.")
		no_issues = false
	
	#if buy_back_selection == null:
		#push_warning("There is no [buy_back_selection] object.")
		#no_issues = false
		#
	#if buy_selection == null:
		#push_warning("There is no [buy_selection] object.")
		#no_issues = false
		
	#if sell_selection == null:
		#push_warning("There is no [sell_selection] object.")
		#no_issues = false
		#
	return no_issues

## Set up all the needed objects for the shop to operate
func _create_sub_objects():
	# buy_back_selection = StackTransfer.new([])
	# buy_selection = StackTransfer.new([])
	trade_calculator = TradeCalculator.new(stats.buy_multiplier, stats.sell_multiplier)
	buy_back_calculator = TradeCalculator.new(stats.sell_multiplier, stats.sell_multiplier)

### Reset the buyback, buy, and sell selections for the shop
#func _reset_selections():
	## buy_back_selection.transfer_stacks = []
	## buy_selection.transfer_stacks = []
	##
	##if sell_selection: # May not exist if no shopper yet
		##sell_selection.transfer_stacks = []

## Recalculate buyback trade whenever buyback selection changes
#func _on_buy_back_contents_changed(contents: StackTransfer):
	## buy_back_calculator.calculate_trade(buy_back_selection, null)
#
### Recalculate buy/sell trade price whenever buy selection changes
#func _on_buy_contents_changed(contents: StackTransfer):
	##trade_calculator.calculate_trade(buy_selection, sell_selection)
#
### Recalculate buy/sell trade price whenever sell selection changes
#func _on_sell_contents_changed(contents: StackTransfer):
	#trade_calculator.calculate_trade(buy_selection, sell_selection)

### Handles whenever the Buy Back or Buy Selection transfer list changes to recalculate
### the price of the transaction
#func _on_transfer_data_changed(transfer : StackTransfer):
	#match transfer.source:
		#buy_back_selection:
			#buy_back_calculator.calculate_trade(buy_back_selection, null)
		#buy_selection:
			#trade_calculator.calculate_trade(buy_selection, sell_selection)
		#_:
			#push_warning("Connected to transfer %s that is not handeled by the shop" % transfer)
class_name ShopBus
extends Resource
## Communicates when the active shop changes within the context of a player's UI & gameplay

signal shop_changed(shop : Shop)

var shop : Shop :
	set(value):
		if shop == value:
			return
		
		shop = value
		shop_changed.emit(shop)
class_name ShopDropContainer
extends Container
## UI Container that can drop data into the shop sell or buy selection

## The root of the shop UI holding reference to the currently active shop
@export var shop_ui : ShopUI :
	set(value):
		if(is_instance_valid(shop_ui)):
			shop_ui.shop_changed.disconnect(_on_shop_changed)
			
		shop_ui = value
		
		if(is_instance_valid(shop_ui)):
			shop_ui.shop_changed.connect(_on_shop_changed)

enum DropLocations { SELL, BUY }
	
@export var drop_to_data_list : DropLocations

## The shop currently being used for this UI display
var shop : Shop

func _ready():
	validate()

## Checks whether the shop UI can handle the data being dragged into it
##
## Returns if the data can be handled by the shop control
func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if(data is StackTransfer):
		return true
		
	return false

## Starts a sell prompt for data being dropped into it
func _drop_data(at_position: Vector2, data: Variant):
	if(data is StackTransfer):
		# Sell from player inventory
		if(drop_to_data_list == DropLocations.SELL && data.container == shop.shopper_container):
			shop.sell_selection.combine(data)
		## Buy from shop inventory
		elif(drop_to_data_list == DropLocations.BUY && data.container == shop.shop_container):
			shop.buy_selection.combine(data)

func _on_shop_changed(p_shop : Shop):
	shop = p_shop

func validate():
	var no_issues = true
	
	if(mouse_filter == MOUSE_FILTER_IGNORE):
		push_warning("Unable to receive drop data because mouse filter is set to ignore.")
	
	return no_issues
extends Label
## Shows the active shop name

## The root of the shop UI holding reference to the currently active shop
@export var shop_bus : ShopBus :
	set(value):
		if is_instance_valid(shop_bus):
			shop_bus.shop_changed.disconnect(_on_shop_changed)
			
		shop_bus = value
		
		if is_instance_valid(shop_bus):
			shop_bus.shop_changed.connect(_on_shop_changed)
		
func _on_shop_changed(p_shop : Shop):
	text = p_shop.name
class_name ShopStats
extends InventoryResource

## Display name for currency values within the shop
@export var currency_name : StringName = " GP"

## Amount multiplied by the value of the item to get the buy price
## for transferring items from the shop to the shopper
@export var buy_multiplier = 1.0

## Amount multiplied by the value of the item to get the sell price
## for transferring items from the shopper to the shop
@export var sell_multiplier = 0.5
class_name ShopUI
extends Control

signal shop_changed(shop : Shop)
			
@export var shopper_ui : Control

## Holds reference to the active shop bus that this UI displays
@export var shop_bus : ShopBus :
	set(value):
		if shop_bus != null:
			shop_bus.shop_changed.disconnect(_on_shop_changed)
		
		shop_bus = value
		
		if shop_bus != null:
			shop_bus.shop_changed.connect(_on_shop_changed)

## Button for closing the menu
@export var close_button : Button :
	set(value):
		if close_button != null:
			close_button.pressed.disconnect(_on_close_pressed)

		close_button = value

		if close_button != null:
			close_button.pressed.connect(_on_close_pressed)

@export var stock_view : ItemContainerView
@export var buyback_view : ItemContainerView

var shop_container : ItemContainer

func _ready() -> void:
	validate()

## Closes the shop UI and clears the current shop instance
func close():
	if shop_bus.shop != null:
		shop_bus.shop.clear()
		
	hide()

## Ensures that the UI is ready to be used by checking critical components
func validate() -> bool:
	var no_issues = true

	if close_button == null:
		push_warning("No close button set on %s" % get_path())
		no_issues = false
	
	return no_issues

## Toggles visibility of the shop UI and shopper UI based on shop validity
func _set_visibility(p_shop : Shop):
	if is_instance_valid(shop_bus.shop):
		show()
		shopper_ui.show()
	else:
		hide()
		shopper_ui.hide()

## Determines if the dropped data is valid for this UI (e.g., drag-and-drop support)
func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if data is StackTransfer:
		return true
		
	return false

## Handles the drop action by processing valid StackTransfer data
func _drop_data(at_position: Vector2, data: Variant):
	if data is StackTransfer:
		# Check if the dropped data originates from the shopper's container
		if data.source == shop_bus.shop.shopper_container:
			# Combine the dropped items into the shop's sell selection
			shop_bus.shop.sell_selection.combine(data)

## Updates the UI when a new shop is opened or changed
func _on_shop_changed(p_shop : Shop):
	_set_visibility(p_shop)
	if stock_view: stock_view.item_container = p_shop.stock
	if buyback_view: buyback_view.item_container = p_shop.buy_back

## Triggers the close function when the close button is pressed
func _on_close_pressed():
	close()
class_name TradeButton
extends Button
## Shows the current trade amount for a shop trade and executes traades on the shop

# Receive singals from the bus when the shop is changed
@export var shop_bus : ShopBus

## The active trade
var trade : Trade

@export var gain_color = Color.GREEN
@export var loss_color = Color.RED
@export var price_prefix = "Trade: " 
@export var price_suffix = ""

var initial_color : Color

## The current shop received through the shop bus
var shop : Shop :
	set(value):
		shop = value
		
		if is_instance_valid(shop):
			calculator = shop.trade_calculator
			
			if is_instance_valid(calculator):
				_on_price_updated(calculator.trade_price)
		else:
			calculator = null

## The calculator used to calculate trade prices
var calculator : TradeCalculator :
	set(value):
		if(is_instance_valid(calculator)):
			calculator.price_updated.disconnect(_on_price_updated)

		calculator = value
		
		if(is_instance_valid(calculator)):
			calculator.price_updated.connect(_on_price_updated)

func _init():
	initial_color = self_modulate

func _ready():
	pressed.connect(_on_pressed)
	
## When the total price is recalculated on the calculator, update the shown trade amount
func _on_price_updated(p_new_price : float):
	text = price_prefix + str(p_new_price) + shop.currency_name + price_suffix
	
	if p_new_price > 0:
		self_modulate = gain_color
	elif p_new_price < 0:
		self_modulate = loss_color
	else:
		self_modulate = initial_color

## Sells the items on the list and adds to the buyback list
func _on_pressed():
	if trade != null:
		trade.execute()
class_name TradeCalculator
extends Object
## Makes the trade between a ItemContainer and a shop

signal price_updated(net_price : float)

var trade_price : float : 
	set(value):
		if(trade_price == value):
			return
		
		trade_price = value
		price_updated.emit(trade_price)

## Multiplier of the item value to determine the final sell price
var sell_multiplier : float

## Multiplier of the item value to determine the final buy price
var buy_multiplier : float
		
func _init(p_buy_multiplier : float, p_sell_multiplier : float):
	sell_multiplier = p_sell_multiplier
	buy_multiplier = p_buy_multiplier

## Calculates the net cost or profit of an exchange
## Updates & returns the trade_price
func calculate_trade(buy_data : StackTransfer, sell_data : StackTransfer) -> float:
	trade_price = get_total_sell_price(sell_data) - get_total_buy_price(buy_data)
	return trade_price

## Gets the sum total value of all items to be sold after the sell multiplier modifier applies
func get_total_sell_price(sell_data : StackTransfer) -> float:
	if(not is_instance_valid(sell_data) || sell_data.stack_moves.is_empty()):
		return 0
		
	var total_sell_price = 0.0
	
	for stack_move in sell_data.stack_moves:
		total_sell_price += stack_move.get_item_value() * stack_move.amount * sell_multiplier
	
	return total_sell_price

## Gets the sum total value of all items to be bought after the buy multiplier modifier applies
func get_total_buy_price(buy_data : StackTransfer) -> float:
	if(not is_instance_valid(buy_data) || buy_data.stack_moves.is_empty()):
		return 0
		
	var total_buy_price = 0.0
	
	for stack_move in buy_data.stack_moves:
		total_buy_price += stack_move.get_item_value() * stack_move.amount * buy_multiplier
	
	return total_buy_price
## Handles the redistribution of items across an InventoryResource hierarchy
class_name StackRedistributionManager
extends RefCounted

## Emitted when redistribution is completed
signal redistribution_completed(resource: InventoryResource)

## Emitted when redistribution fails
signal redistribution_failed(resource: InventoryResource, stack: FlexStack, overflow: int)

var _is_redistributing := false

## Checks if redistribution is needed for the given resource and item count
func needs_redistribution(resource: InventoryResource, item: FlexItem, count: int) -> bool:
	if not item or count <= 0:
		return false
	return count > resource.current_max_held(item)

## Checks if a specific inventory level can handle the given item count
func can_handle_at_level(resource: InventoryResource, item: FlexItem, count: int) -> bool:
	var space := resource.get_space(item)
	var current := resource.get_item_count(item)
	return (space + current) >= count

## Attempts to redistribute items across the inventory hierarchy
func redistribute_items(source: InventoryResource, item: FlexItem, count: int) -> bool:
	if not _validate_redistribution_start(source, item, count):
		return true  # Early return for invalid or no-op cases
	
	var stack: FlexStack = source as FlexStack
	var overflow := _calculate_overflow(stack, count)
	if overflow <= 0:
		_reset_redistribution_state()
		return true
	
	var initial_total := get_total_item_count(item, stack)
	if _attempt_redistribution(stack, item, overflow):
		if _verify_item_conservation(stack, item, initial_total):
			_complete_redistribution(stack)
			return true
		else:
			_revert_redistribution(stack, item, overflow)
	
	_fail_redistribution(stack, overflow)
	return false

## Validates preconditions and sets redistribution state
func _validate_redistribution_start(source: InventoryResource, item: FlexItem, count: int) -> bool:
	if _is_redistributing or not item or count <= 0:
		_is_redistributing = false
		return false
	
	if not source is FlexStack:
		push_error("Source must be a FlexStack, got %s" % source.get_class())
		_is_redistributing = false
		redistribution_failed.emit(source, null, 0)
		return false
	
	_is_redistributing = true
	return true

## Calculates the overflow amount to redistribute
func _calculate_overflow(stack: FlexStack, count: int) -> int:
	return min(count, stack.count - stack.item.stack_maximum)

## Attempts to redistribute overflow to a parent container
func _attempt_redistribution(stack: FlexStack, item: FlexItem, overflow: int) -> bool:
	var current_resource: InventoryResource = stack.parent
	while current_resource != null:
		if can_handle_at_level(current_resource, item, overflow):
			push_warning("Redistributing %d items of type %s to %s" % [
				overflow, item.resource_name, current_resource.resource_name
			])
			
			var original_count := stack.count
			stack.count = stack.item.stack_maximum
			var added := current_resource.add_items(item, overflow)
			
			if added == overflow:
				return true
			else:
				stack.count = original_count
				push_warning("Failed to add %d items to %s" % [overflow, current_resource.resource_name])
		
		current_resource = current_resource.parent
	return false

## Verifies that total items remain conserved after redistribution
func _verify_item_conservation(stack: FlexStack, item: FlexItem, initial_total: int) -> bool:
	var final_total := get_total_item_count(item, stack)
	if final_total != initial_total:
		push_error("Item conservation failed - expected %d, got %d" % [initial_total, final_total])
		return false
	return true

## Reverts changes if conservation fails
func _revert_redistribution(stack: FlexStack, item: FlexItem, overflow: int) -> void:
	var parent: InventoryResource = stack.parent
	while parent != null:
		var current_count := parent.get_item_count(item)
		if current_count > 0:
			parent.remove_items(item, overflow)
			stack.count += overflow
			break
		parent = parent.parent

## Completes successful redistribution
func _complete_redistribution(stack: FlexStack) -> void:
	_is_redistributing = false
	redistribution_completed.emit(stack)

## Handles redistribution failure
func _fail_redistribution(stack: FlexStack, overflow: int) -> void:
	push_error("No level could handle %d overflow items from %s" % [overflow, stack.resource_name])
	_is_redistributing = false
	redistribution_failed.emit(stack, stack, overflow)

## Resets the redistribution state
func _reset_redistribution_state() -> void:
	_is_redistributing = false

## Helper function to count items across the hierarchy
func get_total_item_count(item: FlexItem, source: InventoryResource) -> int:
	var total := source.get_item_count(item)
	var current: InventoryResource = source.parent
	while current != null:
		total += current.get_item_count(item)
		current = current.parent
	return total

func _init(inventory: FlexInventory) -> void:
	inventory.illegal_count_detected.connect(_on_illegal_count_detected)

func _on_illegal_count_detected(report: IllegalCountReport) -> void:
	var overflow = report.current_count - report.maximum_count
	redistribute_items(report.source, report.item, overflow)

## Validates and redistributes items across an InventoryResource hierarchy
func validate_and_redistribute(p_resource: InventoryResource) -> void:
	if _is_redistributing:
		push_error("Redistribution already in progress")
		return
		
	_is_redistributing = true
	var invalid_stacks := _collect_invalid_stacks(p_resource)
	
	for stack in invalid_stacks:
		var overflow = stack.count - stack.item.stack_maximum
		if p_resource.needs_redistribution(stack.item, overflow):
			push_error("Cannot redistribute %d items from stack %s - insufficient space" % [
				overflow,
				stack.resource_name
			])
			redistribution_failed.emit(p_resource, stack, overflow)
			continue
			
		push_warning("Redistributing %d overflow items from stack %s" % [
			overflow,
			stack.resource_name
		])
		
		var original_count = stack.count
		stack.count = stack.item.stack_maximum
		
		if not p_resource.redistribute_items(stack.item, overflow):
			stack.count = original_count
			redistribution_failed.emit(p_resource, stack, overflow)
			continue
			
	_is_redistributing = false
	redistribution_completed.emit(p_resource)

## Collects all stacks that exceed their maximum count
func _collect_invalid_stacks(p_resource: InventoryResource) -> Array[FlexStack]:
	var invalid_stacks: Array[FlexStack] = []
	
	if p_resource is FlexInventory:
		for container in p_resource.item_containers:
			for stack in container._slots:
				if _is_stack_invalid(stack):
					invalid_stacks.append(stack)
	elif p_resource is ItemContainer:
		for stack in p_resource._slots:
			if _is_stack_invalid(stack):
				invalid_stacks.append(stack)
				
	return invalid_stacks

## Checks if a stack exceeds its maximum count
func _is_stack_invalid(p_stack: FlexStack) -> bool:
	return p_stack and p_stack.item and not p_stack.infinite and p_stack.count > p_stack.item.stack_maximum
class_name StackSelection
extends RefCounted
## Represents a selection of items from a FlexStack for transfer or swap.

## Signal emitted when the selected amount to move changes
signal amount_changed(new_amount : int)  # Added new signal

## The source stack to pull from
var stack: FlexStack :
	set(value):
		if stack != null:
			stack.count_changed.disconnect(_on_count_changed)
			
		stack = value
		
		if stack != null:
			stack.count_changed.connect(_on_count_changed)

## Number of items to move, clamped unless infinite
## Note: A 0 amount is expected to be treated as a full stack in a move since no amount was indicated
var amount: int :  
	set(value):
		if amount == value:
			return
		
		if stack and not stack.infinite:
			amount = clamp(value, 0, stack.count)
		else:
			amount = max(value, 0)  # No upper limit if infinite, but prevent negative

		amount_changed.emit(amount)

func _init(p_stack: FlexStack, p_amount: int):
	stack = p_stack
	amount = p_amount  # Setter handles clamping

## Checks for potential issues and returns any found as an Array[String]
func validate() -> Array[String]:
	var issues : Array[String] = []

	if stack == null:
		issues.append("Invalid stack set in selection")
		return issues
	
	if not stack.infinite && stack.count <= 0:
		issues.append("Cannot select from empty stack")
	
	if amount > stack.count:
		issues.append("Cannot select more than stack count")
	
	return issues

func get_item() -> FlexItem:
	return stack.item if stack else null

## Update the amount to transfer if the stack count changes
func _on_count_changed(p_stack : FlexStack):
	if p_stack.infinite:
		return
	
	amount = clamp(amount, 0, p_stack.count)
## Manages the transfer of a single stack into different types of inventory resources
## 
## Handles the following transfer types:
## - Stack swapping between two FlexStacks
## - Partial merging of compatible stacks
## - Adding items to general inventory resources
##
## Usage:
## - Create with a source StackSelection
## - Set the target inventory resource
## - Execute the transfer
## - Check result and handle completion/failure signals
class_name StackTransfer
extends RefCounted

signal transfer_completed(transfer: StackTransfer)
signal transfer_failed(transfer: StackTransfer, error: String)

enum Result { 
	SUCCESS,           # Transfer completed successfully
	INVALID_TARGET,    # Target cannot accept the item
	NO_SPACE,         # Target has no space for items
	FAILED            # General failure
}

## The source stack selection to transfer
var source: StackSelection

## The target resource for the transfer
var target: InventoryResource

## The result of the last transfer attempt
var result: Result

## Whether to print debug messages
var _debug : bool = true

func _init(p_source: StackSelection) -> void:
	source = p_source

	if _debug:
		transfer_completed.connect(_on_transfer_completed)
		transfer_failed.connect(_on_transfer_failed)

func execute() -> Result:
	if _debug: 
		print_debug("Execute transfer - Source stack: ", source.stack.item.resource_name if source.stack.item else "empty", " (", source.stack.count, "), Selected: ", source.amount)

	var validation : Array[String] = validate()

	if validation.size() > 0: # Any results indicate a failed validation
		transfer_failed.emit(self, str(validation))
		return Result.FAILED
	
	# Try swap if target is FlexStack and conditions allow
	if target.can_swap(source):
		return _swap_stacks()
	
	# For all other cases, treat as resource transfer
	var results = _transfer()
	return Result.SUCCESS if results.size() > 0 else Result.FAILED

## Checks the transfer setup to make sure all conditions are met for a transfer to occur
func validate() -> Array[String]:
	var issues: Array[String] = []

	# Ensure source is valid
	if not source:
		issues.append("Invalid source selection")
	else:
		issues.append_array(source.validate())

	# Ensure target is valid
	if not is_instance_valid(target):
		issues.append("Invalid target")

	# Ensure source has items to transfer
	if not source.get_item():
		issues.append("Cannot transfer null item type")

	if not target.can_add_items(source.get_item(), source.amount):
		issues.append("Target cannot accept items")

	return issues

## Conducts the transfer
## Expects that validation has already been done
func _transfer() -> Dictionary[FlexItem, int]:
	var results : Dictionary[FlexItem, int] = {}
	
	# Perform transfer
	var item_type = source.get_item()
	var to_transfer = source.amount if source.amount > 0 else source.stack.count # If 0, transfer the full stack as default
	var transferred = target.add_items(item_type, to_transfer)
	results[item_type] = transferred
	
	# Remove the moved amount from the source container
	if not source.stack.infinite:
		source.stack.count -= transferred
		
	source.amount = 0  # Reset selection amount after transfer
	
	if _debug:
		print_debug("Source Stack Remainder: %d " % source.stack.count)
		
	transfer_completed.emit(self)
	return results

func _swap_stacks() -> Result:
	var target_stack : FlexStack = target.get_swap_target(source.stack)
	
	# Store original values
	var temp_item := target_stack.item
	var temp_count := target_stack.count
	
	# Swap data
	target_stack.item = source.get_item()
	target_stack.count = source.stack.count
	source.stack.item = temp_item
	source.stack.count = temp_count

	transfer_completed.emit(self)
	return Result.SUCCESS

func _on_transfer_completed(transfer: StackTransfer) -> void:
	if _debug:
		print_debug("Transfer completed - Source: %s(x%d) -> Target: %s(x%d)" % [
			source.get_item().resource_name if source.get_item() else "none",
			source.amount,
			target.item.resource_name if target is FlexStack and target.item else "none",
			target.count if target is FlexStack else 0
		])

func _on_transfer_failed(transfer: StackTransfer, error: String) -> void:
	if _debug:
		print_debug("Transfer failed: %s - Source: %s(x%d) -> Target: %s(x%d)" % [
			error,
			source.get_item().resource_name if source.get_item() else "none",
			source.amount,
			target.item.resource_name if target is FlexStack and target.item else "none",
			target.count if target is FlexStack else 0
		])
class_name MoneyLabel
extends Label
## Shows the current amount of money in the inventory

## The inventory to show the money in
@export var inventory : FlexInventory :
	set(value):
		if inventory != null:
			inventory.money_changed.disconnect(_on_money_changed)
		
		inventory = value
		
		if inventory != null:
			inventory.money_changed.connect(_on_money_changed)

@export var text_format : String = "Money: %d"

func _ready():
	update_text(inventory.money)

func update_text(p_money : float):
	text = text_format % p_money

func _on_money_changed(p_money : float) -> void:
	update_text(p_money)
class_name InventoryController
extends Node

## The inventory to be manipulated by action input
@export var inventory_view : InventoryView

## Whether the view should always open at the mouse location when shown
@export var open_at_mouse = false

## Define input map actions for controlling FlexInventory UI
@export var actions : FlexActions

func _unhandled_input(event: InputEvent) -> void:
	if event.is_action_pressed(actions.inventory):
		toggle()
		
func toggle():
	if inventory_view.visible:
		inventory_view.hide()
	else:
		inventory_view.show()
		
	if open_at_mouse:
		inventory_view.global_position = inventory_view.get_global_mouse_position()
class_name ItemContainerSelector
extends Control
## Used to select input_pickable collision objects for item_container opening if they have one

enum Mode { Game2D, Game3D }

@export var mode : Mode
@export var view : ItemContainerView
@export var track_target_position = false

var hover_target : Node :
	set(value):
		hover_target = value
		
var view_position_target : Node
var starting_position : Vector2

func _ready():
	starting_position = view.global_position
	clear()
		
func _process(delta: float) -> void:
	if track_target_position && view_position_target != null:
		var set_position = view_position_target.get_global_transform_with_canvas().get_origin()
		view.global_position = set_position

func _input(event: InputEvent) -> void:
	if event is InputEventMouseMotion:
		match(mode):
			Mode.Game2D:
				hover_target = get_2d_pickable_collider_under_mouse()
			Mode.Game3D:
				push_error("Hover target not implemented for 3D games.")
		
func _unhandled_input(event: InputEvent) -> void:
	if event.is_action_pressed("ui_select"):
		update_view()
	elif event.is_action_pressed("ui_cancel"):
		clear()
		
func clear():
	view.item_container = null
	view_position_target = null
	view.hide()
			
## Updates or creates a selected item container view nested under the hover target
## and sets the item_container to it's item_container
func update_view():
	if hover_target == null:
		clear()
		return
	
	var item_container : ItemContainer = hover_target.get("item_container")
	
	if item_container == null: 
		clear()
		return
	
	view.item_container = item_container # Must have item_container property to show item container
	view_position_target = hover_target
	
	if track_target_position:	
		view.global_position = get_global_mouse_position()
	else:
		view.global_position = starting_position
	
	view.show()
		
# Get CollisionObject2D where input_pickable = true under camera global mouse position
func get_2d_pickable_collider_under_mouse() -> CollisionObject2D:
	var space = get_world_2d().direct_space_state
	var camera = get_viewport().get_camera_2d()
	var query_position = camera.get_global_mouse_position()
	
	var params = PhysicsPointQueryParameters2D.new()
	params.position = query_position
	var intersections = space.intersect_point(params)
	
	for intersection in intersections:
		var collider = intersection.collider
		
		if collider is CollisionObject2D && collider.input_pickable:
			return collider
			break

	return null
class_name ContainerDisplayList
extends ItemContainerList
## FlexItem list containing extensions for easier interactions with flex container

## Holds reference to the item_container, user, and trade exchange handler objects
## for reference between concerned objects
#@export var container_bus : ItemContainerBus :
	#set(value):
		#if is_instance_valid(container_bus):
			#container_bus.container_changed.disconnect(_on_container_changed)
		#
		#container_bus = value
		#
		#if is_instance_valid(container_bus):
			#item_container = container_bus.container
			#container_bus.container_changed.connect(_on_container_changed)
		#else:
			#item_container = null
			#push_warning("Set to null container bus on " + str(get_path()))

### Handles modification of item amounts in transfering items out of
### this container's item list
#@export var items_transfer_bus : ItemsTransferBus

@export var empty_icon : Texture

var shown_stacks = 0

## Shortcut for accessing the active item_container
var item_container : ItemContainer :
	set(value):
		if is_instance_valid(item_container):
			item_container.item_count_changed.disconnect(_on_item_count_changed)
			item_container.item_stack_removed.disconnect(_on_item_stack_removed)
			item_container.slots_changed.disconnect(_on_slots_updated)
		
		item_container = value
		refresh()
		
		if is_instance_valid(item_container):
			item_container.item_count_changed.connect(_on_item_count_changed)
			item_container.item_stack_removed.connect(_on_item_stack_removed)
			item_container.slots_changed.connect(_on_slots_updated)

func _ready():
	item_activated.connect(_on_item_activated)

## Refreshes the display to show the contents of the item_container
func refresh():
	if not is_instance_valid(item_container):
		clear()
		return
	
	var stacks : Array[FlexStack] = item_container.get_stacks()
	var stacks_size = stacks.size()
	shown_stacks = 0
	
	for i in stacks_size:
		var stack = stacks[i]
		
		## Do not show empty stacks
		if stack.item == null:
			continue
		
		shown_stacks += 1
		var stack_disabled = not is_instance_valid(stack)
		var stack_text = get_stack_text(stack)
		var stack_icon = get_stack_icon(stack)
		
		if item_count <= i:
			add_item(
				stack_text,
				stack_icon
			)
			set_item_disabled(i, stack_disabled)
			set_item_metadata(i, stack)
		else:
			set_item_metadata(i, stack)
			set_item_disabled(i, stack_disabled)
			set_item_text(
				i, 
				stack_text
				)
			set_item_icon(i, stack_icon)
		
		set_item_tooltip(i, get_stack_tooltip(stack))
		
	for i in range(item_count + 1, shown_stacks, 1):
		remove_item(i)

func get_item_container() -> ItemContainer:
	return item_container

func get_item_stack_move(item : int) -> StackTransfer:
	var stack = get_item_metadata(item)
	var amount = 0
	
	if is_instance_valid(stack):
		amount = stack.count
	
	return StackTransfer.new(stack, amount)

## Gets a text representation for the stack and count
func get_stack_text(stack : FlexStack) -> String:
	if not stack || stack.infinite:
		return ""
		
	return str(stack.count)

## Returns the texture from the stack icon if the stack is valid or null otherwise
func get_stack_icon(stack : FlexStack) -> Texture:
	if stack == null || stack.item == null || stack.item.get("icon") == null:
		return empty_icon
	
	return stack.item.get("icon")
	
func get_stack_tooltip(stack : FlexStack) -> String:
	if not stack || stack.item == null:
		return ""
	
	return stack.item.name
	
## Gets the transfer data of the selected list items as a StackTransfer
## object and returns it
func get_selected_transfer_data() -> StackTransfer:
	var stack_moves : Array[StackTransfer] = []

	var selected = get_selected_items()
		
	for item in selected:
		var stack : FlexStack = get_item_metadata(item)
		var stack_move = StackTransfer.new(stack, stack.get_effective_count())
		stack_moves.append(stack_move)
			
	var transfer_data = StackTransfer.new(self, stack_moves)
		
	return transfer_data
	
## Creates or updates stack displays for each stack in the item_container
func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if data is StackTransfer:
		return true
		
	return false

func _drop_data(at_position: Vector2, data: Variant):
	if data is StackTransfer:
		if data.sender == self:
			var target_index = get_item_at_position(at_position)
			var stacks = data.get_source_stacks()
			var indexes : Dictionary[FlexStack, int] = item_container.get_indexes(stacks)
			
			if indexes.size() == 1:
				item_container.slots = item_container.swap(target_index, indexes.values()[0], item_container.get_stacks())
			else:
				item_container.slots = item_container.move_multi(target_index, indexes, item_container.get_stacks(), true)
				
			deselect_all()

func _on_container_changed(p_item_container : ItemContainer):
	item_container = p_item_container

func _on_item_count_changed(type : FlexItem, new_count : int):
	refresh()

func _on_item_stack_removed(stack : FlexStack):
	refresh()
	
func _on_slots_updated(changed_indexes : Array[FlexStack]):
	refresh()

## If FlexItem is already selected, start transfer to buy container
func _on_item_activated(index : int):
	if is_selected(index):
		var transfer_data : StackTransfer = get_selected_transfer_data()
		var error = await FlexState.send(transfer_data)
class_name ItemContainerList
extends ItemList
## Abstract class for item lists that handle ItemContainer display and
## data exchange

signal drag_started(transfer_data : StackTransfer)

## Allow dragging of items out of this container
@export var drag_items = true

## Display above / below positioning for the drag icons during a drag
@export var drag_z_index = 500

func is_abstract():
	return true

func get_item_container() -> ItemContainer:
	push_error("Virtual function. Implement in extended class")
	return null

func get_item_stack_move(item : int) -> StackTransfer:
	push_error("Virtual function. Implement in extended class")
	return null

## Makes a drag icon at the position of the item list item
func create_drag_icon(selected_index : int) -> TextureRect:
	var icon = TextureRect.new()
	icon.z_index = drag_z_index
	
	if(fixed_icon_size != Vector2i.ZERO):
		icon.size = fixed_icon_size
		
	icon.texture = get_item_icon(selected_index)
	return icon

## Creates an StackTransfer for the items being selected in the 
## drag between UI elements
func _get_drag_data(at_position: Vector2) -> Variant:
	if drag_items:
		var selected_items = get_selected_items()
		
		if selected_items.is_empty():
			return null
		
		var stack_moves : Array[StackTransfer] = []
		
		for selected in selected_items:
			var stack_move = get_item_stack_move(selected)
			stack_moves.append(stack_move)
			
		var drag_data = StackTransfer.new(self, stack_moves)
		var drag_icon = create_drag_icon(selected_items[0])

		set_drag_preview(drag_icon)
		drag_started.emit(drag_data)
		return drag_data

	return null
class_name TradeItemList
extends ItemContainerList
## Shows the stock and buy or sell price for items contained in the list

## What price to show
## Buy Price - The price the shopper pays for each item unit
## Sell Price - The amount the shop pays to buy the item from the shopper
enum TradeType { BUY, SELL, BUY_BACK }

## What type of trading this list represents. Controls where transferred items
## go
@export var trade_type : TradeType = TradeType.BUY :
	set(value):
		trade_type = value

## The data list for the current selection of items to be transferred
var selection : StackTransfer :
	get:
		match(trade_type):
			TradeType.SELL:
				return shop.sell_selection
			TradeType.BUY:
				return shop.buy_selection
			TradeType.BUY_BACK:
				return shop.buy_back_selection
			_:
				push_error("Unhandled trade type " + str(trade_type))
				return null
				
## Popup to instance when trying to drop data into this list
## to control the number of items being transferred. Recommended
## to make the instanced control top level for individual movement
#@export var exchange_menu : ExchangeMenu :
	#set(value):
		#if(is_instance_valid(exchange_menu)):
			#exchange_menu.finished.disconnect(_on_exchange_menu_finished)
			#
		#exchange_menu = value
		#
		#if(is_instance_valid(exchange_menu)):
			#exchange_menu.finished.connect(_on_exchange_menu_finished)

## Signal bus that holds an active shop and emits when the shop has changed
@export var shop_bus : ShopBus :
	set(value):
		if is_instance_valid(shop_bus):
			shop_bus.shop_changed.disconnect(_on_shop_changed)
		
		shop_bus = value
		
		if is_instance_valid(shop_bus):
			shop_bus.shop_changed.connect(_on_shop_changed)
			
## The shop that this item list is handling the UI view for
var shop : Shop :
	set(value):
		if is_instance_valid(shop):
			shop.buy_multiplier_changed.disconnect(_on_buy_multiplier_changed)
			shop.sell_multiplier_changed.disconnect(_on_sell_multiplier_changed)
		
		shop = value
		
		if is_instance_valid(shop):
			shop.buy_multiplier_changed.connect(_on_buy_multiplier_changed)
			shop.sell_multiplier_changed.connect(_on_sell_multiplier_changed)
			
			match trade_type:
				TradeType.BUY_BACK:
					shop.buy_back_selection.contents_changed.connect(_on_selection_changed)
		
## The container that the items selected will be transferring into
var target_container : ItemContainer :
	get:
		match trade_type:
			TradeType.BUY:
				target_container = shop.shopper_container
			TradeType.SELL:
				target_container = shop.sell_container
			TradeType.BUY_BACK:
				target_container = shop.shopper_container
			_:
				push_error("Not implemented for type")
		
		return null

var selection_data : Array[StackTransfer]:
	set(value):
		selection_data = value
		refresh_list()

func _ready():
	validate()
	drag_started.connect(_on_drag_started)

## Overrides the default stack text to show item price
func get_stack_move_text(stack_move_data : StackTransfer) -> String:
	var multiplier : float
	
	match(trade_type):
		TradeType.BUY:
			multiplier = shop.buy_multiplier
		TradeType.SELL:
			multiplier = shop.sell_multiplier
		TradeType.BUY_BACK:
			multiplier = shop.sell_multiplier
		_:
			push_warning("Unhandled shop DisplayMode case " + str(trade_type))
			return ""
	
	return stack_move_data.get_display_text(multiplier)

func refresh_list():
	for i in range(0, selection_data.size(), 1):
		var stack_text = get_stack_move_text(selection_data[i])
		var icon = selection_data[i].source.item.icon
		
		if(i < item_count):
			set_item_text(i, stack_text)
			set_item_icon(i, icon)
		else:
			add_item(stack_text, icon)
			
		set_item_metadata(i, selection_data[i])
	
	## Remove any unused items
	for i in range(selection_data.size(), item_count, 1):
		remove_item(i)
		
func get_item_container() -> ItemContainer:
	return target_container
		
func validate():
	var no_issues = true
	
	if(mouse_filter == MOUSE_FILTER_IGNORE):
		push_warning("Unable to receive drop data because mouse filter is set to ignore.")
	
	return no_issues
	
func get_item_stack_move(item : int) -> StackTransfer:
	return get_item_metadata(item)
			
func _on_shop_opened(p_shop : Shop):
	shop = p_shop

func _on_buy_multiplier_changed(new_value : float):
	refresh_list()
	
func _on_sell_multiplier_changed(new_value : float):
	refresh_list()

func _on_selection_changed(p_selection_data : Array[StackTransfer]):
	selection_data = p_selection_data
		
func _on_shop_changed(p_shop : Shop):
	shop = p_shop

## Checks whether the shop UI can handle the data being dragged into it
##
## Returns if the data can be handled by the shop control
func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if data is StackTransfer:
		return true
		
	return false

## Starts a sell prompt for data being dropped into it
func _drop_data(at_position: Vector2, data: Variant):
	if data is StackTransfer:
		# Sell from player inventory
		match trade_type:
			TradeType.SELL:
				pass
				#_sell_transfer(data)
			TradeType.BUY:
				pass
				#_buy_transfer(data)
			TradeType.BUY_BACK:
				_buy_back_transfer(data)

#func _sell_transfer(data : StackTransfer):
	#if(data.sender == self): # If data is not coming from a container, skip menu
		#shop.sell_selection.combine(data)
	#elif(data.container == shop.shopper_container):
		#var result = await exchange_menu.handle(data)
		#
		#if(confirmed):
			#shop.sell_selection.combine(data)
#
#func _buy_transfer(data : StackTransfer):
	#if(data.sender == self):
		#shop.buy_selection.combine(data)
	#if(data.container == shop.shop_container):
		#var confirmed = await exchange_menu.handle(data)
		#
		#if(confirmed):
			#shop.buy_selection.combine(data)

## Call when this trade list receives additional data
## to combine with the current selection
func receive(data : StackTransfer):
	selection.combine(data)
			
## TODO Implement
func _buy_back_transfer(data : StackTransfer):
	push_error("Not implemented")
	
## All items removed from data list after dragging out of the item list
func _on_drag_started(transfer_data : StackTransfer):
	for item in get_selected_items():
		remove_item(item)
		
	if(trade_type == TradeType.SELL):
		shop.sell_selection.remove(transfer_data)
	elif(trade_type == TradeType.BUY):
		shop.buy_selection.remove(transfer_data)
	else:
		push_error("Unhandled trade type " + str(trade_type))
		
	return
	
func _on_exchange_menu_finished(transfer_data : StackTransfer):
	shop.buy_selection.combine(transfer_data)
class_name ItemsTransferMenu
extends ConfirmationDialog
## Control the number of items being exchanged through sliders
##
## Handler for the FlexState

## Emitted when the dialog is finished either through confirmed or canceled signals
signal finished(result : Error, transfer_data : StackTransfer)

### When set, the items_trasfer_menu takes control as the handler
### on the items_transfer_bus. The bus handler
### manages modification and sending of StackTransfer
### and receiving final receiving objects
#@export var items_transfer_bus : ItemsTransferBus:
	#set(value):
		#if(is_instance_valid(items_transfer_bus)):
			#if(items_transfer_bus.handler == self):
				#items_transfer_bus.handler = null
			#
		#items_transfer_bus = value
		#
		#if(is_instance_valid(items_transfer_bus)):
			#items_transfer_bus.handler = self

## Grid to display each selector template on. One per transfer item stack.
@export var selector_grid : GridContainer

## UI for selecting the number of each item to transfer between containers
@export var selector_template : PackedScene

#@export var exchange_selector : ExchangeAmountSelector :
	#set(value):
		#if(is_instance_valid(exchange_selector)):
			#exchange_selector.amount_slider.value_changed.disconnect(_on_slider_value_changed)
	#
		#exchange_selector = value
		#
		#if(is_instance_valid(exchange_selector)):
			#exchange_selector.amount_slider.value_changed.connect(_on_slider_value_changed)
	#
@export var count_prefix = "("
@export var count_suffix = ")"

## The current transfer values after any user modifications are made
var data : StackTransfer :
	set(value):
		if is_instance_valid(data):
			clear()
		
		data = value
		
		if is_instance_valid(data):
			populate(data)

## Whether the exchange is confirmed or not
var confirm_exchange : Error

func _ready():
	hide()
	validate()
	confirmed.connect(_on_confirmed)
	canceled.connect(_on_canceled)
	close_requested.connect(_on_close_requested)
	FlexState.handler = self

## Control the number of items being transferred through user UI input
##
## Returns true if handling successful (transfer confirmed)
func handle(transaction_data : StackTransfer) -> bool:
	data = transaction_data
	position = Vector2i(0,0)
	popup(Rect2i(get_mouse_position(), size))
	var result = await finished
	return result[0]

## Adds item transfer controls the menu for choosing the
## amount of each item to move between containers. Selects
## the first item in the list automatically.
func populate(p_data : StackTransfer):
	for i in range(0, p_data.stack_moves.size(), 1):
		var selector = selector_template.instantiate()
		selector_grid.add_child(selector)
		selector.data = p_data.stack_moves[i]

## Clears all transfer selectors from the window
func clear():
	for child in selector_grid.get_children():
		child.free()

func validate() -> bool:
	var no_issues = true
	
	return no_issues
	
func _on_confirmed():
	finished.emit(OK, data)

func _on_canceled():
	finished.emit(FAILED, null)

func _on_close_requested():
	finished.emit(FAILED, null)
	hide()
class_name TransferAmountSelector
extends Control
## Presents a slider to control how many of the item in question 
## to move between item containers

@export var label : Label

## Displays the icon of the item type being transferred
@export var icon_rect : TextureRect

@export var remove_button : Button :
	set(value):
		if(is_instance_valid(remove_button)):
			remove_button.pressed.disconnect(_on_remove_pressed)
		
		remove_button = value
		
		if(is_instance_valid(remove_button)):
			remove_button.pressed.connect(_on_remove_pressed)

## Controls the amount of the item being transferred between none and the total stack amount
@export var amount_slider : Slider :
	set(value):
		if(is_instance_valid(amount_slider)):
			amount_slider.value_changed.disconnect(_on_slider_value_changed)
			
		amount_slider = value
		
		if(is_instance_valid(amount_slider)):
			amount_slider.value_changed.connect(_on_slider_value_changed)
				

## Show the number of items currently selected for transfer by the slider
@export var amount_label : Label

@export var amount_prefix : StringName = "("
@export var amount_suffix : StringName = ")"

## The stack data that this control uses for dislaying settings
var data : StackTransfer :
	set(value):
		if(is_instance_valid(data)):
			data.source.count_changed.disconnect(_on_source_count_changed)
			
		data = value
		
		if(is_instance_valid(data)):
			data.source.count_changed.connect(_on_source_count_changed)
			_update_display(data)

## Gets the current amount of items to be transferred
func get_amount():
	return amount_slider.value

## Updates the UI display to match the stack_move_data
func _update_display(p_data : StackTransfer):
	label.text = data.source.item.name
	icon_rect.texture = data.source.item.icon
	amount_slider.min_value = 0
	var max_move = data.get_maximum_move()
	amount_slider.max_value = max_move
	amount_slider.value = 0
	amount_label.text = amount_prefix + str(amount_slider.value) + amount_suffix

func _on_source_count_changed(new_count : int):
	amount_slider.max_value = new_count

func _on_slider_value_changed(value : float):
	data.amount = value
	amount_label.text = amount_prefix + str(amount_slider.value) + amount_suffix

func _on_remove_pressed():
	data.amount = 0
	self.queue_free()
extends Node
class_name TransferPreviewFactory
extends RefCounted

## Default settings for preview appearance
const DEFAULT_SETTINGS = {
	"icon_size": Vector2(32, 32),
	"font_size": 12,
	"count_position": Vector2(24, 24),
	"background_color": Color(0.2, 0.2, 0.2, 0.8),
	"text_color": Color.WHITE
}

## Creates a preview Control for a stack transfer
## Returns a Control node configured with the transfer details
static func create_preview(transfer: StackTransfer, settings: Dictionary = {}) -> Control:
	# Merge provided settings with defaults
	settings = DEFAULT_SETTINGS.duplicate()
	settings.merge(settings, true)
	
	# Create container
	var container = Control.new()
	container.custom_minimum_size = settings.icon_size
	container.mouse_filter = Control.MOUSE_FILTER_IGNORE
	
	# Add item icon
	var icon = TextureRect.new()
	var item := transfer.source.get_item()

	if item != null:
		icon.texture = item.icon
		
	icon.custom_minimum_size = settings.icon_size
	icon.expand_mode = TextureRect.EXPAND_FIT_WIDTH_PROPORTIONAL
	icon.mouse_filter = Control.MOUSE_FILTER_IGNORE
	container.add_child(icon)
	
	# Add count label if transferring more than 1 item
	if transfer.source.amount > 1:
		var count_label = Label.new()
		count_label.text = str(transfer.source.amount)
		count_label.position = settings.count_position
		count_label.add_theme_color_override("font_color", settings.text_color)
		count_label.add_theme_font_size_override("font_size", settings.font_size)
		container.add_child(count_label)
	
	return container
class_name InventoryView
extends Control
## Displays ItemContainers and currency for an inventory
## Also handles transfers of items into and out of the inventory

## Emitted when a new StackTransfer is created
signal transfer_created(transfer : StackTransfer)

## Emitted when StackTransfer data is dropped on this InventoryView
signal transfer_dropped(transfer : StackTransfer)

## The inventory resource that this view provides a UI display for
@export var inventory : FlexInventory :
	set(value):
		inventory = value
		
		for view in container_views:
			view.inventory = inventory

## Where the item container views are added as a child of so they can display under tabs
@export var tabs : TabContainer

## The view to display for each ItemContainer
@export_file var container_view_template : String

## Whether to show the title of each ItemContainer
@export var show_tab_titles = false

## Whether to show the icons of each ItemContainer
@export var show_tab_icons = true

var container_views : Array[ItemContainerView] = []

func _ready() -> void:
	visibility_changed.connect(_on_visibility_changed)
	populate()

## Clears all tab views
func clear():
	for container in container_views:
		container.queue_free()
	
	container_views = []

## Create tab views for each item_container of the inventory
func populate():
	clear()
	
	for index in range(0, inventory.item_containers.size(), 1):
		var view : ItemContainerView = load(container_view_template).instantiate()
		view.set_drag_forwarding(view._get_drag_data, _can_drop_data, _drop_data) # The inventory handles the dropping of data
		var item_container = inventory.item_containers[index]
		view.item_container = item_container
		tabs.add_child(view)
		container_views.append(view)
		
		if show_tab_titles:
			tabs.set_tab_title(index, item_container.type.name)
		else:
			tabs.set_tab_title(index, "")
	
		if show_tab_icons:
			tabs.set_tab_icon(index, item_container.type.icon)

func _on_visibility_changed():
	if visible:
		populate()

func _get_drag_data(at_position: Vector2) -> Variant:
	return self
	
func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	return data is StackTransfer

func _drop_data(at_position: Vector2, data: Variant) -> void:
	if data is StackTransfer:
		data.target = inventory
		transfer_dropped.emit(self)
		data.execute()
class_name ItemContainerView
extends Container
## stack_views the resources being held by the item container
## Shows the exact ItemStacks set to the _slots of the ItemContainer

## Emit when any of the managed stack views has it's selected count changes
signal selected_items_changed(p_views : Array[StackView])
		
@export var stack_view_template : PackedScene

@export_group("Internal Dependencies")
@export var grid_container : GridContainer

## The item container data model this view represents
var item_container : ItemContainer :
	set(value):
		if item_container != null:
			clear()
			item_container.stack_added.disconnect(_on_stack_added)
			item_container.stack_removed.disconnect(_on_stack_removed)
			
		item_container = value
		
		if item_container != null:
			_setup()
			item_container.stack_added.connect(_on_stack_added)
			item_container.stack_removed.connect(_on_stack_removed)

var stack_views : Array[StackView]

func _ready() -> void:
	validate()

## Frees active item stack_views
func clear():
	for view in stack_views:
		view.free()
		
	stack_views = []
	
func create_stack_view(p_display_stack : FlexStack) -> void:
	var stack_view : StackView = stack_view_template.instantiate() as StackView
	grid_container.add_child(stack_view)
	stack_view.item_stack = p_display_stack
	stack_views.append(stack_view)

## Removes the view that corresponds with the p_stack FlexStackut
func remove_stack_view(p_stack : FlexStack):
	var matches = []
	
	for view in stack_views:
		if view.item_stack == p_stack:
			matches.append(view)
			
	for view in matches:
		view.queue_free()
		stack_views.erase.call_deferred(view) # Delay to prevent for loop issues and wait for view to actually free
		
func validate() -> bool:
	var no_issues = true
	
	if item_container == null:
		push_warning("No [item_container] set in %s" % get_path())
		no_issues = false
		
	if stack_view_template == null:
		push_warning("No [stack_view_template] set in %s" % get_path())
		no_issues = false
		
	return no_issues

func _on_stack_added(p_stack : FlexStack):
	create_stack_view(p_stack)
	
func _on_stack_removed(p_stack : FlexStack):
	remove_stack_view(p_stack)

		
## Creates a display for each item_container stack
func _setup():
	clear()
	
	for stack in item_container.get_stacks():
		create_stack_view(stack)

# Passed forwarding to child views
func _get_drag_data(at_position: Vector2) -> Variant:
	return null

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if data is StackTransfer:
		return true

	return false

## Makes the ItemContainer the preferred container in the StackTransfer transaction
func _drop_data(at_position: Vector2, data: Variant) -> void:
	if data is StackTransfer:
		data.target = item_container
		data.execute()

func _on_close_button_pressed() -> void:
	hide()

## Whenever count changes on any stack, emit message that selected items changed
func _on_stack_selection_amount_changed(count : int) -> void:
	selected_items_changed.emit(stack_views)
class_name PurchaseView
extends ScrollContainer

## View for displaying stock items
@export var stock_view: ItemContainerView

## Inventory containing merchant's stock
@export var inventory: FlexInventory:
	set(value):
		inventory = value
		_update_stock_view()

func _ready() -> void:
	_update_stock_view()

## Updates the stock view with the first container from the inventory
func _update_stock_view() -> void:
	if not stock_view or not inventory:
		return
		
	if inventory.item_containers.is_empty():
		push_warning("Inventory has no containers to display in PurchaseView")
		return
		
	stock_view.item_container = inventory.item_containers[0]
class_name ResourcesDisplayView
extends MarginContainer
# Displays the resources being held by the item container

@export var container : ItemContainer :
	set(value):
		if(container):
			container.item_count_changed.disconnect(_on_item_count_changed)
			
		container = value
		
		if(container):
			container.item_count_changed.connect(_on_item_count_changed)
			_setup_for_materials()
		
@export var flex_stack_display_template : PackedScene

## Hide any item stacks that show 0 count
## TODO: Remove need for this with signal that auto removes
@export var remove_0_count_display = true

@export_group("Internal Dependencies")
@export var stack_container : Container

var displays : Array[StackView]

func _setup_for_materials():
	# Set current resources to display
	for type in container.get_item_types():
		var count = container.get_count(type)
		_create_display(type, count)
	
func _create_display(item : FlexItem, count : int) -> void:
	var new_display : StackView = flex_stack_display_template.instantiate() as StackView
	stack_container.add_child(new_display)
	new_display.item_stack = FlexStack.new(item, count)
	displays.append(new_display)

func _on_item_count_changed(item : FlexItem, new_count : int) -> void:
	# Find existing item display for type
	var current_display : StackView
	
	# Find existing display and update the count if one is found
	for display in displays:
		if(display.item_stack.item == item):
			current_display = display
			current_display.update_count(new_count)
			
			if(remove_0_count_display && new_count == 0):
				displays.erase(current_display)
				current_display.queue_free()
				break
	
	# If none exist, create a new one
	if(new_count > 0 && current_display == null):
		_create_display(item, new_count)
class_name ShopStackView
extends StackView
## Allows selection of the number to buy by scroll wheel
		
func _ready():
	super()
	validate()
	
func validate() -> bool:
	var no_issues = true
	
	if actions == null:
		push_warning("There is no FlexActions defined at %s to control the UI" % get_path())
		no_issues = false
	
	return no_issues

func update_count_display():
	if item_stack == null || item_stack.item == null:
		super()
		return
	
	var max = item_stack.get_effective_count()
	
	if item_stack.infinite:
		count_label.text = str(selected_count) + " / ∞"
	else:
		count_label.text = "%d / %d" % [selected_count, max]
		
func _create_drag_duplicate() -> StackView:
	var duplicant : Control = super()
	var label : Label
	
	for child in duplicant.get_children():
		if child is Label:
			label = child
			break
	
	if label:
		label.text = str(selected_count)
		
	return duplicant
class_name StackView
extends Button
## For displaying visuals for an item stack in UI


## When the item displayed in the stack is changed
signal item_changed(view : StackView)

## When the count on the item_stack changes
signal item_count_changed(view : StackView)

## Text to display in the tooltip when there is no FlexStack set or it has no FlexItem
@export var empty_tooltip: String = "Empty"

## Text to display on the button when there is no FlexStack set or it has no FlexItem
@export var empty_label: String = ""

## The item stack currently being displayed and used in this StackView
@export var item_stack : FlexStack:
	set(value):
		if item_stack == value:
			return
		
		if item_stack != null:
			if item_stack.count_changed.is_connected(_on_count_changed):
				item_stack.count_changed.disconnect(_on_count_changed)
				
			if item_stack.item_changed.is_connected(_on_item_changed):
				item_stack.item_changed.disconnect(_on_item_changed)
		
		item_stack = value
		
		if item_stack != null:
			## Create / Update the stackSelection to use the current item_stack
			if selection == null:
				selection = StackSelection.new(item_stack, 0)
			elif selection.stack != item_stack:
				selection.stack = item_stack
			
			refresh()
			
			if not item_stack.count_changed.is_connected(_on_count_changed):
				item_stack.count_changed.connect(_on_count_changed)
				
			if not item_stack.item_changed.is_connected(_on_item_changed):
				item_stack.item_changed.connect(_on_item_changed)

## Define the actions to use for controlling this stack
@export var actions: FlexActions

## Label to display the item count on
@export var count_label: Label

## The number of items being selected from the current stack
var selection : StackSelection :
	set(value):
		if selection != null:
			selection.amount_changed.disconnect(_on_selection_amount_changed)
	
		selection = value	
		
		if selection != null:
			selection.amount_changed.connect(_on_selection_amount_changed)

## Whether the mouse is currently over this view or not
var mouse_over : bool = false

func _ready() -> void:
	refresh()
	mouse_entered.connect(_on_mouse_entered)
	mouse_exited.connect(_on_mouse_exited)

## Increase or decrease the selected count depending on action input
## but only when the mouse is also over the UI view
func _unhandled_input(event: InputEvent) -> void:
	if not mouse_over:
		return
	
	## Check the more actions first because if more is active, increase or decrease base already is too but we want to prioritize the more actions
	if event.is_action_pressed(actions.decrease_more):
		selection.amount -= 10
	elif event.is_action_pressed(actions.increase_more):
		selection.amount += 10
	elif event.is_action_pressed(actions.increase):
		if actions.shift_modifier && Input.is_key_pressed(KEY_SHIFT): # Work around for Mouse Wheel + Shift input
			selection.amount += 10
		else:
			selection.amount += 1
	elif event.is_action_pressed(actions.decrease):
		if actions.shift_modifier && Input.is_key_pressed(KEY_SHIFT): # Work around for Mouse Wheel + Shift input
			selection.amount -= 10
		else:
			selection.amount -= 1
	

func refresh() -> void:
	update_item_display()
	update_count_display()

## Set the count label to display the appropriate count number
func update_count_display() -> void:
	if count_label == null:
		return
	
	if item_stack == null or item_stack.item == null or item_stack.count == 0:
		count_label.text = empty_label
		return
	
	var max = item_stack.get_effective_count()
	
	if item_stack.infinite:
		# Show selected / ∞ for infinite stacks
		count_label.text = str(selection.amount) + " / ∞"
	else:
		if selection.amount == 0:
			# Show max amount when nothing is selected
			count_label.text = str(max)
		else:
			# Show selected / max when something is selected
			count_label.text = "%d / %d" % [selection.amount, max]

## Update the count_label.texture and tooltip to show item graphics and information
func update_item_display() -> void:
	if item_stack != null and item_stack.item != null:
		icon = item_stack.item.icon
		tooltip_text = item_stack.item.name
	else:
		icon = null
		tooltip_text = empty_tooltip

func _on_count_changed(_stack : FlexStack) -> void:
	# Ensure selection.amount stays valid when stack count changes
	selection.amount = selection.amount  # Triggers setter to clamp value
	update_count_display()
	item_count_changed.emit(self)

func _on_item_changed(_stack : FlexStack) -> void:
	refresh()
	item_changed.emit(self)

func _can_drop_data(at_position: Vector2, data: Variant) -> bool:
	if data is StackTransfer:
		return true
	
	return false
	
func _get_drag_data(at_posiition : Vector2) -> Variant:
	# Inventory must be set from a parent to create the StackTransfer
	var transfer = StackTransfer.new(selection)
	var drag_control := TransferPreviewFactory.create_preview(transfer)
	set_drag_preview(drag_control)
	return transfer
	
## Makes the ItemContainer the preferred container in the StackTransfer transaction
func _drop_data(at_position: Vector2, data: Variant) -> void:
	if data is StackTransfer:
		data.target = item_stack
		data.execute()

## Creates a control for drag preview using the FlexStack's item icon and count
func _create_stack_control(stack: FlexStack) -> Control:
	# Create a container (e.g., HBoxContainer) to hold texture and label
	var container := HBoxContainer.new()
	container.size = Vector2(64, 32)  # Adjust size as needed
	
	# TextureRect for the item icon
	var texture_rect := TextureRect.new()
	texture_rect.texture = stack.item.icon if stack.item and stack.item.icon else null
	texture_rect.custom_minimum_size = Vector2(32, 32)  # Fixed size for icon
	texture_rect.expand_mode = TextureRect.EXPAND_FIT_WIDTH  # Ensure it fits
	texture_rect.stretch_mode = TextureRect.STRETCH_KEEP_ASPECT_CENTERED
	
	# Label for the stack count
	var label := Label.new()
	label.text = str(stack.count) if not stack.infinite else "∞"
	label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	label.custom_minimum_size = Vector2(32, 32)  # Match icon height
	
	# Add children to container
	container.add_child(texture_rect)
	container.add_child(label)
	
	return container

func _on_mouse_entered():
	mouse_over = true

func _on_mouse_exited():
	mouse_over = false

func _on_selection_amount_changed(p_amount : int):
	refresh()
class_name TotalItemCountView
extends Container
## Displays the resources being held by the item container
## Groups items of the same type into one display

@export var item_container : ItemContainer :
	set(value):
		if item_container != null:
			item_container.item_count_changed.disconnect(_on_item_count_changed)
			clear()
			
		item_container = value
		
		if item_container != null:
			item_container.item_count_changed.connect(_on_item_count_changed)
			_setup_for_materials()
		
@export var item_display_template : PackedScene

@export_group("Internal Dependencies")
@export var grid_container : GridContainer

var displays : Array[StackView]

## Frees active item displays
func clear():
	for display in displays:
		display.queue_free()
		
	displays = []

func _setup_for_materials():
	# Set current resources to display
	for item in item_container.get_item_types():
		var count = item_container.get_count(item)
		var display_stack = FlexStack.new(item, count)
		create_display(display_stack)

## Creates a new display for a given FlexStack resource
func create_display(p_display_stack : FlexStack) -> void:
	var new_display : StackView = item_display_template.instantiate() as StackView
	grid_container.add_child(new_display)
	new_display.item_stack = p_display_stack
	displays.append(new_display)

func _on_item_count_changed(p_item : FlexItem, new_count : int) -> void:
	# Find existing item display for p_item
	var current_display : StackView
	
	# Find existing display and update the count if one is found
	for display in displays:
		if display.item_stack.item == p_item:
			current_display = display
			current_display.update_count(new_count)
	
	# If none exist, create a new one
	if new_count > 0 && current_display == null:
		var display_stack = FlexStack.new(p_item, new_count)
		create_display(display_stack)
#!/usr/bin/env -S godot -s
extends SceneTree

enum {
	INIT,
	PROCESSING,
	EXIT
}

const RETURN_SUCCESS  =   0
const RETURN_ERROR    = 100
const RETURN_WARNING  = 101

var _console := CmdConsole.new()
var _cmd_options: = CmdOptions.new([
	CmdOption.new(
		"-scp, --src_class_path",
		"-scp <source_path>",
		"The full class path of the source file.",
		TYPE_STRING
	),
	CmdOption.new(
		"-scl, --src_class_line",
		"-scl <line_number>",
		"The selected line number to generate test case.",
		TYPE_INT
	)
])

var _status := INIT
var _source_file :String = ""
var _source_line :int = -1


func _init() -> void:
	var cmd_parser := CmdArgumentParser.new(_cmd_options, "GdUnitBuildTool.gd")
	var result := cmd_parser.parse(OS.get_cmdline_args())
	if result.is_error():
		show_options()
		exit(RETURN_ERROR, result.error_message());
		return

	var cmd_options :Array[CmdCommand] = result.value()
	for cmd in cmd_options:
		if cmd.name() == '-scp':
			_source_file = cmd.arguments()[0]
			_source_file = ProjectSettings.localize_path(ProjectSettings.localize_path(_source_file))
		if cmd.name() == '-scl':
			_source_line = int(cmd.arguments()[0])
	# verify required arguments
	if _source_file == "":
		exit(RETURN_ERROR, "missing required argument -scp <source>")
		return
	if _source_line == -1:
		exit(RETURN_ERROR, "missing required argument -scl <number>")
		return
	_status = PROCESSING


func _idle(_delta :float) -> void:
	if _status == PROCESSING:
		var script := ResourceLoader.load(_source_file) as Script
		if script == null:
			exit(RETURN_ERROR, "Can't load source file %s!" % _source_file)
		var result := GdUnitTestSuiteBuilder.create(script, _source_line)
		if result.is_error():
			print_json_error(result.error_message())
			exit(RETURN_ERROR, result.error_message())
			return
		_console.prints_color("Added testcase: %s" % result.value(), Color.CORNFLOWER_BLUE)
		print_json_result(result.value() as Dictionary)
		exit(RETURN_SUCCESS)


func exit(code :int, message :String = "") -> void:
	_status = EXIT
	if code == RETURN_ERROR:
		if not message.is_empty():
			_console.prints_error(message)
		_console.prints_error("Abnormal exit with %d" % code)
	else:
		_console.prints_color("Exit code: %d" % RETURN_SUCCESS, Color.DARK_SALMON)
	quit(code)


func print_json_result(result :Dictionary) -> void:
	# convert back to system path
	var path := ProjectSettings.globalize_path(result["path"] as String)
	var json := 'JSON_RESULT:{"TestCases" : [{"line":%d, "path": "%s"}]}' % [result["line"], path]
	prints(json)


func print_json_error(error :String) -> void:
	prints('JSON_RESULT:{"Error" : "%s"}' % error)


func show_options() -> void:
	_console.prints_color(" Usage:", Color.DARK_SALMON)
	_console.prints_color("	build -scp <source_path> -scl <line_number>", Color.DARK_SALMON)
	_console.prints_color("-- Options ---------------------------------------------------------------------------------------",
		Color.DARK_SALMON).new_line()
	for option in _cmd_options.default_options():
		descripe_option(option)


func descripe_option(cmd_option :CmdOption) -> void:
	_console.print_color("  %-40s" % str(cmd_option.commands()), Color.CORNFLOWER_BLUE)
	_console.prints_color(cmd_option.description(), Color.LIGHT_GREEN)
	if not cmd_option.help().is_empty():
		_console.prints_color("%-4s %s" % ["", cmd_option.help()], Color.DARK_TURQUOISE)
	_console.new_line()
#!/usr/bin/env -S godot -s
extends SceneTree

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")


#warning-ignore-all:return_value_discarded
class CLIRunner:
	extends Node

	enum {
		READY,
		INIT,
		RUN,
		STOP,
		EXIT
	}

	const DEFAULT_REPORT_COUNT = 20
	const RETURN_SUCCESS = 0
	const RETURN_ERROR = 100
	const RETURN_ERROR_HEADLESS_NOT_SUPPORTED = 103
	const RETURN_ERROR_GODOT_VERSION_NOT_SUPPORTED = 104
	const RETURN_WARNING = 101

	var _state := READY
	var _test_suites_to_process: Array
	var _executor :Variant
	var _cs_executor :Variant
	var _report: GdUnitHtmlReport
	var _report_dir: String
	var _report_max: int = DEFAULT_REPORT_COUNT
	var _headless_mode_ignore := false
	var _runner_config := GdUnitRunnerConfig.new()
	var _runner_config_file := ""
	var _debug_cmd_args: = PackedStringArray()
	var _console := CmdConsole.new()
	var _cmd_options := CmdOptions.new([
			CmdOption.new(
				"-a, --add",
				"-a <directory|path of testsuite>",
				"Adds the given test suite or directory to the execution pipeline.",
				TYPE_STRING
			),
			CmdOption.new(
				"-i, --ignore",
				"-i <testsuite_name|testsuite_name:test-name>",
				"Adds the given test suite or test case to the ignore list.",
				TYPE_STRING
			),
			CmdOption.new(
					"-c, --continue",
					"",
					"""By default GdUnit will abort checked first test failure to be fail fast,
					instead of stop after first failure you can use this option to run the complete test set.""".dedent()
			),
			CmdOption.new(
				"-conf, --config",
				"-conf [testconfiguration.cfg]",
				"Run all tests by given test configuration. Default is 'GdUnitRunner.cfg'",
				TYPE_STRING,
				true
			),
			CmdOption.new(
				"-help", "",
				"Shows this help message."
			),
			CmdOption.new("--help-advanced", "",
				"Shows advanced options."
			)
		],
		[
			# advanced options
			CmdOption.new(
				"-rd, --report-directory",
				"-rd <directory>",
				"Specifies the output directory in which the reports are to be written. The default is res://reports/.",
				TYPE_STRING,
				true
			),
			CmdOption.new(
				"-rc, --report-count",
				"-rc <count>",
				"Specifies how many reports are saved before they are deleted. The default is %s." % str(DEFAULT_REPORT_COUNT),
				TYPE_INT,
				true
			),
			#CmdOption.new("--list-suites", "--list-suites [directory]", "Lists all test suites located in the given directory.", TYPE_STRING),
			#CmdOption.new("--describe-suite", "--describe-suite <suite name>", "Shows the description of selected test suite.", TYPE_STRING),
			CmdOption.new(
				"--info", "",
				"Shows the GdUnit version info"
			),
			CmdOption.new(
				"--selftest", "",
				"Runs the GdUnit self test"
			),
			CmdOption.new(
				"--ignoreHeadlessMode",
				"--ignoreHeadlessMode",
				"By default, running GdUnit4 in headless mode is not allowed. You can switch off the headless mode check by set this property."
			),
		])


	func _ready() -> void:
		_state = INIT
		_report_dir = GdUnitFileAccess.current_dir() + "reports"
		_executor = GdUnitTestSuiteExecutor.new()
		# stop checked first test failure to fail fast
		@warning_ignore("unsafe_cast")
		(_executor as GdUnitTestSuiteExecutor).fail_fast(true)
		if GdUnit4CSharpApiLoader.is_mono_supported():
			prints("GdUnit4Net version '%s' loaded." % GdUnit4CSharpApiLoader.version())
			_cs_executor = GdUnit4CSharpApiLoader.create_executor(self)
		var err := GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
		if err != OK:
			prints("gdUnitSignals failed")
			push_error("Error checked startup, can't connect executor for 'send_event'")
			quit(RETURN_ERROR)


	func _notification(what: int) -> void:
		if what == NOTIFICATION_PREDELETE:
			prints("Finallize .. done")


	@warning_ignore("unsafe_method_access")
	func _process(_delta :float) -> void:
		match _state:
			INIT:
				init_gd_unit()
				_state = RUN
			RUN:
				# all test suites executed
				if _test_suites_to_process.is_empty():
					_state = STOP
				else:
					set_process(false)
					# process next test suite
					var test_suite: Node = _test_suites_to_process.pop_front()

					if _cs_executor != null and _cs_executor.IsExecutable(test_suite):
						_cs_executor.Execute(test_suite)
						await _cs_executor.ExecutionCompleted
					else:
						await _executor.execute(test_suite)
					set_process(true)
			STOP:
				_state = EXIT
				_on_gdunit_event(GdUnitStop.new())
				quit(report_exit_code(_report))


	func quit(code: int) -> void:
		_cs_executor = null
		GdUnitTools.dispose_all()
		await GdUnitMemoryObserver.gc_on_guarded_instances()
		await get_tree().physics_frame
		get_tree().quit(code)


	func set_report_dir(path: String) -> void:
		_report_dir = ProjectSettings.globalize_path(GdUnitFileAccess.make_qualified_path(path))
		_console.prints_color(
			"Set write reports to %s" % _report_dir,
			Color.DEEP_SKY_BLUE
		)


	func set_report_count(count: String) -> void:
		var report_count := count.to_int()
		if report_count < 1:
			_console.prints_error(
				"Invalid report history count '%s' set back to default %d"
				% [count, DEFAULT_REPORT_COUNT]
			)
			_report_max = DEFAULT_REPORT_COUNT
		else:
			_console.prints_color(
				"Set report history count to %s" % count,
				Color.DEEP_SKY_BLUE
			)
			_report_max = report_count


	func disable_fail_fast() -> void:
		_console.prints_color(
			"Disabled fail fast!",
			Color.DEEP_SKY_BLUE
		)
		@warning_ignore("unsafe_method_access")
		_executor.fail_fast(false)


	func run_self_test() -> void:
		_console.prints_color(
			"Run GdUnit4 self tests.",
			Color.DEEP_SKY_BLUE
		)
		disable_fail_fast()
		_runner_config.self_test()


	func show_version() -> void:
		_console.prints_color(
			"Godot %s" % Engine.get_version_info().get("string") as String,
			Color.DARK_SALMON
		)
		var config := ConfigFile.new()
		config.load("addons/gdUnit4/plugin.cfg")
		_console.prints_color(
			"GdUnit4 %s" % config.get_value("plugin", "version") as String,
			Color.DARK_SALMON
		)
		quit(RETURN_SUCCESS)


	func check_headless_mode() -> void:
		_headless_mode_ignore = true


	func show_options(show_advanced: bool = false) -> void:
		_console.prints_color(
			"""
			Usage:
				runtest -a <directory|path of testsuite>
				runtest -a <directory> -i <path of testsuite|testsuite_name|testsuite_name:test_name>
				""".dedent(),
			Color.DARK_SALMON
		).prints_color(
			"-- Options ---------------------------------------------------------------------------------------",
			Color.DARK_SALMON
		).new_line()
		for option in _cmd_options.default_options():
			descripe_option(option)
		if show_advanced:
			_console.prints_color(
				"-- Advanced options --------------------------------------------------------------------------",
				Color.DARK_SALMON
			).new_line()
			for option in _cmd_options.advanced_options():
				descripe_option(option)


	func descripe_option(cmd_option: CmdOption) -> void:
		_console.print_color(
			"  %-40s" % str(cmd_option.commands()),
			Color.CORNFLOWER_BLUE
		)
		_console.prints_color(
			cmd_option.description(),
			Color.LIGHT_GREEN
		)
		if not cmd_option.help().is_empty():
			_console.prints_color(
				"%-4s %s" % ["", cmd_option.help()],
				Color.DARK_TURQUOISE
			)
		_console.new_line()


	func load_test_config(path := GdUnitRunnerConfig.CONFIG_FILE) -> void:
		_console.print_color(
			"Loading test configuration %s\n" % path,
			Color.CORNFLOWER_BLUE
		)
		_runner_config_file = path
		_runner_config.load_config(path)


	func show_help() -> void:
		show_options()
		quit(RETURN_SUCCESS)


	func show_advanced_help() -> void:
		show_options(true)
		quit(RETURN_SUCCESS)


	func get_cmdline_args() -> PackedStringArray:
		if _debug_cmd_args.is_empty():
			return OS.get_cmdline_args()
		return _debug_cmd_args


	func init_gd_unit() -> void:
		_console.prints_color(
			"""
			--------------------------------------------------------------------------------------------------
			GdUnit4 Comandline Tool
			--------------------------------------------------------------------------------------------------""".dedent(),
			Color.DARK_SALMON
		).new_line()

		var cmd_parser := CmdArgumentParser.new(_cmd_options, "GdUnitCmdTool.gd")
		var result := cmd_parser.parse(get_cmdline_args())
		if result.is_error():
			show_options()
			_console.prints_error(result.error_message())
			_console.prints_error("Abnormal exit with %d" % RETURN_ERROR)
			_state = STOP
			quit(RETURN_ERROR)
			return
		if result.is_empty():
			show_help()
			return
		# build runner config by given commands
		var commands :Array[CmdCommand] = []
		@warning_ignore("unsafe_cast")
		commands.append_array(result.value() as Array)
		result = (
			CmdCommandHandler.new(_cmd_options)
				.register_cb("-help", show_help)
				.register_cb("--help-advanced", show_advanced_help)
				.register_cb("-a", _runner_config.add_test_suite)
				.register_cbv("-a", _runner_config.add_test_suites)
				.register_cb("-i", _runner_config.skip_test_suite)
				.register_cbv("-i", _runner_config.skip_test_suites)
				.register_cb("-rd", set_report_dir)
				.register_cb("-rc", set_report_count)
				.register_cb("--selftest", run_self_test)
				.register_cb("-c", disable_fail_fast)
				.register_cb("-conf", load_test_config)
				.register_cb("--info", show_version)
				.register_cb("--ignoreHeadlessMode", check_headless_mode)
				.execute(commands)
		)
		if result.is_error():
			_console.prints_error(result.error_message())
			_state = STOP
			quit(RETURN_ERROR)

		if DisplayServer.get_name() == "headless":
			if _headless_mode_ignore:
				_console.prints_warning("""
					Headless mode is ignored by option '--ignoreHeadlessMode'"

					Please note that tests that use UI interaction do not work correctly in headless mode.
					Godot 'InputEvents' are not transported by the Godot engine in headless mode and therefore
					have no effect in the test!
					""".dedent()
				).new_line()
			else:
				_console.prints_error("""
					Headless mode is not supported!

					Please note that tests that use UI interaction do not work correctly in headless mode.
					Godot 'InputEvents' are not transported by the Godot engine in headless mode and therefore
					have no effect in the test!

					You can run with '--ignoreHeadlessMode' to swtich off this check.
					""".dedent()
				).prints_error(
					"Abnormal exit with %d" % RETURN_ERROR_HEADLESS_NOT_SUPPORTED
				)
				quit(RETURN_ERROR_HEADLESS_NOT_SUPPORTED)
				return

		_test_suites_to_process = load_testsuites(_runner_config)
		if _test_suites_to_process.is_empty():
			_console.prints_warning("No test suites found, abort test run!")
			_console.prints_color("Exit code: %d" % RETURN_SUCCESS, Color.DARK_SALMON)
			_state = STOP
			quit(RETURN_SUCCESS)
		var total_test_count := _collect_test_case_count(_test_suites_to_process)
		_on_gdunit_event(GdUnitInit.new(_test_suites_to_process.size(), total_test_count))


	func load_testsuites(config: GdUnitRunnerConfig) -> Array[Node]:
		var test_suites_to_process: Array[Node] = []
		# Dictionary[String, Dictionary[String, PackedStringArray]]
		var to_execute := config.to_execute()
		# scan for the requested test suites
		var ts_scanner := GdUnitTestSuiteScanner.new()
		for as_resource_path in to_execute.keys() as Array[String]:
			var selected_tests: PackedStringArray = to_execute.get(as_resource_path)
			var scanned_suites := ts_scanner.scan(as_resource_path)
			skip_test_case(scanned_suites, selected_tests)
			test_suites_to_process.append_array(scanned_suites)
		skip_suites(test_suites_to_process, config)
		return test_suites_to_process


	func skip_test_case(test_suites: Array[Node], test_case_names: Array[String]) -> void:
		if test_case_names.is_empty():
			return
		for test_suite in test_suites:
			for test_case in test_suite.get_children():
				if not test_case_names.has(test_case.get_name()):
					test_suite.remove_child(test_case)
					test_case.free()


	func skip_suites(test_suites: Array[Node], config: GdUnitRunnerConfig) -> void:
		var skipped := config.skipped()
		if skipped.is_empty():
			return

		for test_suite in test_suites:
			# skipp c# testsuites for now
			if test_suite.get_script() == null:
				continue
			skip_suite(test_suite, skipped)


	# Dictionary[String, PackedStringArray]
	func skip_suite(test_suite: Node, skipped: Dictionary) -> void:
		var skipped_suites :Array = skipped.keys()
		var suite_name := test_suite.get_name()
		var test_suite_path: String = (
			test_suite.get_meta("ResourcePath") if test_suite.get_script() == null
			else test_suite.get_script().resource_path
		)
		for suite_to_skip: String in skipped_suites:
			# if suite skipped by path or name
			if (
				suite_to_skip == test_suite_path
				or (suite_to_skip.is_valid_filename() and suite_to_skip == suite_name)
			):
				var skipped_tests: PackedStringArray = skipped.get(suite_to_skip)
				var skip_reason := "Excluded by configuration"
				# if no tests skipped test the complete suite is skipped
				if skipped_tests.is_empty():
					_console.prints_warning("Mark the entire test suite '%s' as skipped!" % test_suite_path)
					@warning_ignore("unsafe_property_access")
					test_suite.__is_skipped = true
					@warning_ignore("unsafe_property_access")
					test_suite.__skip_reason = skip_reason
				else:
					# skip tests
					for test_to_skip in skipped_tests:
						var test_case: _TestCase = test_suite.find_child(test_to_skip, true, false)
						if test_case:
							test_case.skip(true, skip_reason)
							_console.prints_warning("Mark test case '%s':%s as skipped" % [suite_to_skip, test_to_skip])
						else:
							_console.prints_error(
								"Can't skip test '%s' checked test suite '%s', no test with given name exists!"
								% [test_to_skip, suite_to_skip]
							)


	func _collect_test_case_count(test_suites: Array[Node]) -> int:
		var total: int = 0
		for test_suite in test_suites:
			total += test_suite.get_child_count()
		return total


	# gdlint: disable=function-name
	func PublishEvent(data: Dictionary) -> void:
		_on_gdunit_event(GdUnitEvent.new().deserialize(data))


	func _on_gdunit_event(event: GdUnitEvent) -> void:
		match event.type():
			GdUnitEvent.INIT:
				_report = GdUnitHtmlReport.new(_report_dir, _report_max)
			GdUnitEvent.STOP:
				var report_path := _report.write()
				_report.delete_history(_report_max)
				JUnitXmlReport.new(_report._report_path, _report.iteration()).write(_report)
				_console.prints_color(
					build_executed_test_suite_msg(_report.suite_executed_count(), _report.suite_count()),
					Color.DARK_SALMON
				).prints_color(
					build_executed_test_case_msg(_report.test_executed_count(), _report.test_count()),
					Color.DARK_SALMON
				).prints_color(
					"Total time:        %s" % LocalTime.elapsed(_report.duration()),
					Color.DARK_SALMON
				).prints_color(
					"Open Report at: file://%s" % report_path,
					Color.CORNFLOWER_BLUE
				)
			GdUnitEvent.TESTSUITE_BEFORE:
				_report.add_testsuite_report(event.resource_path(), event.suite_name(), event.total_count())
			GdUnitEvent.TESTSUITE_AFTER:
				_report.add_testsuite_reports(
					event.resource_path(),
					event.error_count(),
					event.failed_count(),
					event.orphan_nodes(),
					event.elapsed_time(),
					event.reports()
				)
			GdUnitEvent.TESTCASE_BEFORE:
				_report.add_testcase(event.resource_path(), event.suite_name(), event.test_name())
			GdUnitEvent.TESTCASE_AFTER:
				_report.set_testcase_counters(event.resource_path(),
					event.test_name(),
					event.is_error(),
					event.failed_count(),
					event.orphan_nodes(),
					event.is_skipped(),
					event.is_flaky(),
					event.elapsed_time())
				_report.add_testcase_reports(event.resource_path(), event.test_name(), event.reports())
			GdUnitEvent.TESTCASE_STATISTICS:
				_report.update_testsuite_counters(event.resource_path(), event.is_error(), event.failed_count(), event.orphan_nodes(),\
					event.is_skipped(), event.is_flaky(), event.elapsed_time())
		print_status(event)


	func build_executed_test_suite_msg(executed_count :int, total_count :int) -> String:
		if executed_count == total_count:
			return "Executed test suites: (%d/%d)" % [executed_count, total_count]
		return "Executed test suites: (%d/%d), %d skipped" % [executed_count, total_count, (total_count - executed_count)]


	func build_executed_test_case_msg(executed_count :int, total_count :int) -> String:
		if executed_count == total_count:
			return "Executed test cases: (%d/%d)" % [executed_count, total_count]
		return "Executed test cases: (%d/%d), %d skipped" % [executed_count, total_count, (total_count - executed_count)]


	func report_exit_code(report: GdUnitHtmlReport) -> int:
		if report.error_count() + report.failure_count() > 0:
			_console.prints_color("Exit code: %d" % RETURN_ERROR, Color.FIREBRICK)
			return RETURN_ERROR
		if report.orphan_count() > 0:
			_console.prints_color("Exit code: %d" % RETURN_WARNING, Color.GOLDENROD)
			return RETURN_WARNING
		_console.prints_color("Exit code: %d" % RETURN_SUCCESS, Color.DARK_SALMON)
		return RETURN_SUCCESS


	func print_status(event: GdUnitEvent) -> void:
		match event.type():
			GdUnitEvent.TESTSUITE_BEFORE:
				_console.prints_color(
					"Run Test Suite %s " % event.resource_path(),
					Color.ANTIQUE_WHITE
				)
			GdUnitEvent.TESTCASE_BEFORE:
				_console.print_color(
					"	Run Test: %s > %s :" % [event.resource_path(), event.test_name()],
					Color.ANTIQUE_WHITE
				).prints_color(
					"STARTED",
					Color.FOREST_GREEN
				).save_cursor()
			GdUnitEvent.TESTCASE_AFTER:
				#_console.restore_cursor()
				_console.print_color(
					"	Run Test: %s > %s :" % [event.resource_path(), event.test_name()],
					Color.ANTIQUE_WHITE
				)
				_print_status(event)
				_print_failure_report(event.reports())
			GdUnitEvent.TESTSUITE_AFTER:
				_print_failure_report(event.reports())
				_print_status(event)
				_console.prints_color(
					"Statistics: | %d tests cases | %d error | %d failed | %d flaky | %d skipped | %d orphans |\n"
					% [
						_report.test_count(),
						_report.error_count(),
						_report.failure_count(),
						_report.flaky_count(),
						_report.skipped_count(),
						_report.orphan_count()
					],
					Color.ANTIQUE_WHITE
				)


	func _print_failure_report(reports: Array[GdUnitReport]) -> void:
		for report in reports:
			if (
				report.is_failure()
				or report.is_error()
				or report.is_warning()
				or report.is_skipped()
			):
				_console.prints_color(
					"	Report:",
					Color.DARK_TURQUOISE, CmdConsole.BOLD | CmdConsole.UNDERLINE
				)
				var text := GdUnitTools.richtext_normalize(str(report))
				for line in text.split("\n"):
					_console.prints_color("		%s" % line, Color.DARK_TURQUOISE)
		_console.new_line()


	func _print_status(event: GdUnitEvent) -> void:
		if event.is_flaky() and event.is_success():
			var retries :int = event.statistic(GdUnitEvent.RETRY_COUNT)
			_console.print_color("FLAKY (%d retries)" % retries, Color.GREEN_YELLOW, CmdConsole.BOLD | CmdConsole.ITALIC)
		elif event.is_success():
			_console.print_color("PASSED", Color.FOREST_GREEN, CmdConsole.BOLD)
		elif event.is_skipped():
			_console.print_color("SKIPPED", Color.GOLDENROD, CmdConsole.BOLD | CmdConsole.ITALIC)
		elif event.is_failed() or event.is_error():
			var retries :int = event.statistic(GdUnitEvent.RETRY_COUNT)
			if retries > 1:
				_console.print_color("FAILED (retry %d)" % retries, Color.FIREBRICK, CmdConsole.BOLD)
			else:
				_console.print_color("FAILED", Color.FIREBRICK, CmdConsole.BOLD)
		elif event.is_warning():
			_console.print_color("WARNING", Color.GOLDENROD, CmdConsole.BOLD | CmdConsole.UNDERLINE)

		_console.prints_color(
			" %s" % LocalTime.elapsed(event.elapsed_time()), Color.CORNFLOWER_BLUE
		)


var _cli_runner :CLIRunner


func _initialize() -> void:
	if Engine.get_version_info().hex < 0x40200:
		prints("GdUnit4 requires a minimum of Godot 4.2.x Version!")
		quit(CLIRunner.RETURN_ERROR_GODOT_VERSION_NOT_SUPPORTED)
		return
	DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_MINIMIZED)
	_cli_runner = CLIRunner.new()
	root.add_child(_cli_runner)


# do not use print statements on _finalize it results in random crashes
func _finalize() -> void:
	queue_delete(_cli_runner)
	if OS.is_stdout_verbose():
		prints("Finallize ..")
		prints("-Orphan nodes report-----------------------")
		Window.print_orphan_nodes()
		prints("Finallize .. done")
#!/usr/bin/env -S godot -s
extends MainLoop

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

# gdlint: disable=max-line-length
const LOG_FRAME_TEMPLATE = """
<!DOCTYPE html>
<html style="display: inline-grid;">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Godot Logging</title>
	<link rel="stylesheet" href="css/styles.css">
</head>

<body style="background-color: #eee;">
	<div class="godot-report-frame"">
${content}
	</div>
</body>
</html>
"""

const NO_LOG_MESSAGE = """
<h3>No logging available!</h3>
</br>
<p>In order for logging to take place, you must activate the Activate file logging option in the project settings.</p>
<p>You can enable the logging under:
<b>Project Settings</b> > <b>Debug</b> > <b>File Logging</b> > <b>Enable File Logging</b> in the project settings.</p>
"""

#warning-ignore-all:return_value_discarded
var _cmd_options := CmdOptions.new([
		CmdOption.new(
			"-rd, --report-directory",
			"-rd <directory>",
			"Specifies the output directory in which the reports are to be written. The default is res://reports/.",
			TYPE_STRING,
			true
		)
	])


var _report_root_path: String
var _current_report_path: String
var _debug_cmd_args := PackedStringArray()


func _init() -> void:
	set_report_directory(GdUnitFileAccess.current_dir() + "reports")
	set_current_report_path()


func _process(_delta: float) -> bool:
	# check if reports exists
	if not reports_available():
		prints("no reports found")
		return true

	# only process if godot logging is enabled
	if not GdUnitSettings.is_log_enabled():
		write_report(NO_LOG_MESSAGE, "")
		return true

	# parse possible custom report path,
	var cmd_parser := CmdArgumentParser.new(_cmd_options, "GdUnitCmdTool.gd")
	# ignore erros and exit quitly
	if cmd_parser.parse(get_cmdline_args(), true).is_error():
		return true
	CmdCommandHandler.new(_cmd_options).register_cb("-rd", set_report_directory)

	var godot_log_file := scan_latest_godot_log()
	var result := read_log_file_content(godot_log_file)
	if result.is_error():
		write_report(result.error_message(), godot_log_file)
		return true
	write_report(result.value_as_string(), godot_log_file)
	return true


func set_current_report_path() -> void:
	# scan for latest report directory
	var iteration := GdUnitFileAccess.find_last_path_index(
		_report_root_path, GdUnitHtmlReport.REPORT_DIR_PREFIX
	)
	_current_report_path = "%s/%s%d" % [_report_root_path, GdUnitHtmlReport.REPORT_DIR_PREFIX, iteration]


func set_report_directory(path: String) -> void:
	_report_root_path = path


func get_log_report_html() -> String:
	return _current_report_path + "/godot_report_log.html"


func reports_available() -> bool:
	return DirAccess.dir_exists_absolute(_report_root_path)


func scan_latest_godot_log() -> String:
	var path := GdUnitSettings.get_log_path().get_base_dir()
	var files_sorted := Array()
	for file in GdUnitFileAccess.scan_dir(path):
		var file_name := "%s/%s" % [path, file]
		files_sorted.append(file_name)
	# sort by name, the name contains the timestamp so we sort at the end by timestamp
	files_sorted.sort()
	return files_sorted.back()


func read_log_file_content(log_file: String) -> GdUnitResult:
	var file := FileAccess.open(log_file, FileAccess.READ)
	if file == null:
		return GdUnitResult.error(
			"Can't find log file '%s'. Error: %s"
			% [log_file, error_string(FileAccess.get_open_error())]
		)
	var content := "<pre>" + file.get_as_text()
	# patch out console format codes
	for color_index in range(0, 256):
		var to_replace := "[38;5;%dm" % color_index
		content = content.replace(to_replace, "")
	content += "</pre>"
	content = content\
		.replace("[0m", "")\
		.replace(CmdConsole.CSI_BOLD, "")\
		.replace(CmdConsole.CSI_ITALIC, "")\
		.replace(CmdConsole.CSI_UNDERLINE, "")
	return GdUnitResult.success(content)


func write_report(content: String, godot_log_file: String) -> GdUnitResult:
	var file := FileAccess.open(get_log_report_html(), FileAccess.WRITE)
	if file == null:
		return GdUnitResult.error(
			"Can't open to write '%s'. Error: %s"
			% [get_log_report_html(), error_string(FileAccess.get_open_error())]
		)
	var report_html := LOG_FRAME_TEMPLATE.replace("${content}", content)
	file.store_string(report_html)
	_update_index_html(godot_log_file)
	return GdUnitResult.success(file)


func _update_index_html(godot_log_file: String) -> void:
	var index_file := FileAccess.open("%s/index.html" % _current_report_path, FileAccess.READ_WRITE)
	if index_file == null:
		push_error(
			"Can't add log path to index.html. Error: %s"
			% error_string(FileAccess.get_open_error())
		)
		return
	var content := index_file.get_as_text()\
		.replace("${log_report}", get_log_report_html())\
		.replace("${godot_log_file}", godot_log_file)
	# overide it
	index_file.seek(0)
	index_file.store_string(content)


func get_cmdline_args() -> PackedStringArray:
	if _debug_cmd_args.is_empty():
		return OS.get_cmdline_args()
	return _debug_cmd_args
@tool
extends EditorPlugin

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const GdUnitTestDiscoverGuard := preload("res://addons/gdUnit4/src/core/discovery/GdUnitTestDiscoverGuard.gd")
const GdUnitConsole := preload("res://addons/gdUnit4/src/ui/GdUnitConsole.gd")


var _gd_inspector: Control
var _gd_console: GdUnitConsole
var _guard: GdUnitTestDiscoverGuard


func _enter_tree() -> void:
	if check_running_in_test_env():
		@warning_ignore("return_value_discarded")
		CmdConsole.new().prints_warning("It was recognized that GdUnit4 is running in a test environment, therefore the GdUnit4 plugin will not be executed!")
		return
	if Engine.get_version_info().hex < 0x40200:
		prints("GdUnit4 plugin requires a minimum of Godot 4.2.x Version!")
		return
	GdUnitSettings.setup()
	# Install the GdUnit Inspector
	_gd_inspector = (load("res://addons/gdUnit4/src/ui/GdUnitInspector.tscn") as PackedScene).instantiate()
	add_control_to_dock(EditorPlugin.DOCK_SLOT_LEFT_UR, _gd_inspector)
	# Install the GdUnit Console
	_gd_console = (load("res://addons/gdUnit4/src/ui/GdUnitConsole.tscn") as PackedScene).instantiate()
	var control := add_control_to_bottom_panel(_gd_console, "gdUnitConsole")
	await _gd_console.setup_update_notification(control)
	if GdUnit4CSharpApiLoader.is_mono_supported():
		prints("GdUnit4Net version '%s' loaded." % GdUnit4CSharpApiLoader.version())
	# Connect to be notified for script changes to be able to discover new tests
	_guard = GdUnitTestDiscoverGuard.new()
	@warning_ignore("return_value_discarded")
	resource_saved.connect(_on_resource_saved)
	prints("Loading GdUnit4 Plugin success")


func _exit_tree() -> void:
	if check_running_in_test_env():
		return
	if is_instance_valid(_gd_inspector):
		remove_control_from_docks(_gd_inspector)
		_gd_inspector.free()
	if is_instance_valid(_gd_console):
		remove_control_from_bottom_panel(_gd_console)
		_gd_console.free()
	GdUnitTools.dispose_all(true)
	prints("Unload GdUnit4 Plugin success")


func check_running_in_test_env() -> bool:
	var args := OS.get_cmdline_args()
	args.append_array(OS.get_cmdline_user_args())
	return DisplayServer.get_name() == "headless" or args.has("--selftest") or args.has("--add") or args.has("-a") or args.has("--quit-after") or args.has("--import")


func _on_resource_saved(resource: Resource) -> void:
	if resource is Script:
		await _guard.discover(resource as Script)
class_name Comparator
extends Resource

enum {
	EQUAL,
	LESS_THAN,
	LESS_EQUAL,
	GREATER_THAN,
	GREATER_EQUAL,
	BETWEEN_EQUAL,
	NOT_BETWEEN_EQUAL,
}
## A fuzzer implementation to provide default implementation
class_name Fuzzers
extends Resource


## Generates an random string with min/max length and given charset
static func rand_str(min_length: int, max_length :int, charset := StringFuzzer.DEFAULT_CHARSET) -> Fuzzer:
	return StringFuzzer.new(min_length, max_length, charset)


## Generates an random integer in a range form to
static func rangei(from: int, to: int) -> Fuzzer:
	return IntFuzzer.new(from, to)

## Generates a randon float within in a given range
static func rangef(from: float, to: float) -> Fuzzer:
	return FloatFuzzer.new(from, to)

## Generates an random Vector2 in a range form to
static func rangev2(from: Vector2, to: Vector2) -> Fuzzer:
	return Vector2Fuzzer.new(from, to)


## Generates an random Vector3 in a range form to
static func rangev3(from: Vector3, to: Vector3) -> Fuzzer:
	return Vector3Fuzzer.new(from, to)

## Generates an integer in a range form to that can be divided exactly by 2
static func eveni(from: int, to: int) -> Fuzzer:
	return IntFuzzer.new(from, to, IntFuzzer.EVEN)

## Generates an integer in a range form to that cannot be divided exactly by 2
static func oddi(from: int, to: int) -> Fuzzer:
	return IntFuzzer.new(from, to, IntFuzzer.ODD)
## An Assertion Tool to verify array values
class_name GdUnitArrayAssert
extends GdUnitAssert


## Verifies that the current value is null.
func is_null() -> GdUnitArrayAssert:
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is equal to the given one, ignoring case considerations.
@warning_ignore("unused_parameter")
func is_equal_ignoring_case(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is not equal to the given one, ignoring case considerations.
@warning_ignore("unused_parameter")
func is_not_equal_ignoring_case(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is empty, it has a size of 0.
func is_empty() -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is not empty, it has a size of minimum 1.
func is_not_empty() -> GdUnitArrayAssert:
	return self

## Verifies that the current Array is the same. [br]
## Compares the current by object reference equals
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_same(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array is NOT the same. [br]
## Compares the current by object reference equals
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_not_same(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array has a size of given value.
@warning_ignore("unused_parameter")
func has_size(expectd: int) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains the given values, in any order.[br]
## The values are compared by deep parameter comparision, for object reference compare you have to use [method contains_same]
@warning_ignore("unused_parameter")
func contains(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains exactly only the given values and nothing else, in same order.[br]
## The values are compared by deep parameter comparision, for object reference compare you have to use [method contains_same_exactly]
@warning_ignore("unused_parameter")
func contains_exactly(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains exactly only the given values and nothing else, in any order.[br]
## The values are compared by deep parameter comparision, for object reference compare you have to use [method contains_same_exactly_in_any_order]
@warning_ignore("unused_parameter")
func contains_exactly_in_any_order(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains the given values, in any order.[br]
## The values are compared by object reference, for deep parameter comparision use [method contains]
@warning_ignore("unused_parameter")
func contains_same(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains exactly only the given values and nothing else, in same order.[br]
## The values are compared by object reference, for deep parameter comparision use [method contains_exactly]
@warning_ignore("unused_parameter")
func contains_same_exactly(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array contains exactly only the given values and nothing else, in any order.[br]
## The values are compared by object reference, for deep parameter comparision use [method contains_exactly_in_any_order]
@warning_ignore("unused_parameter")
func contains_same_exactly_in_any_order(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array do NOT contains the given values, in any order.[br]
## The values are compared by deep parameter comparision, for object reference compare you have to use [method not_contains_same]
## [b]Example:[/b]
## [codeblock]
## # will succeed
## assert_array([1, 2, 3, 4, 5]).not_contains([6])
## # will fail
## assert_array([1, 2, 3, 4, 5]).not_contains([2, 6])
## [/codeblock]
@warning_ignore("unused_parameter")
func not_contains(expected :Variant) -> GdUnitArrayAssert:
	return self


## Verifies that the current Array do NOT contains the given values, in any order.[br]
## The values are compared by object reference, for deep parameter comparision use [method not_contains]
## [b]Example:[/b]
## [codeblock]
## # will succeed
## assert_array([1, 2, 3, 4, 5]).not_contains([6])
## # will fail
## assert_array([1, 2, 3, 4, 5]).not_contains([2, 6])
## [/codeblock]
@warning_ignore("unused_parameter")
func not_contains_same(expected :Variant) -> GdUnitArrayAssert:
	return self


## Extracts all values by given function name and optional arguments into a new ArrayAssert.
## If the elements not accessible by `func_name` the value is converted to `"n.a"`, expecting null values
@warning_ignore("unused_parameter")
func extract(func_name: String, args := Array()) -> GdUnitArrayAssert:
	return self


## Extracts all values by given extractor's into a new ArrayAssert.
## If the elements not extractable than the value is converted to `"n.a"`, expecting null values
@warning_ignore("unused_parameter")
func extractv(
	extractor0 :GdUnitValueExtractor,
	extractor1 :GdUnitValueExtractor = null,
	extractor2 :GdUnitValueExtractor = null,
	extractor3 :GdUnitValueExtractor = null,
	extractor4 :GdUnitValueExtractor = null,
	extractor5 :GdUnitValueExtractor = null,
	extractor6 :GdUnitValueExtractor = null,
	extractor7 :GdUnitValueExtractor = null,
	extractor8 :GdUnitValueExtractor = null,
	extractor9 :GdUnitValueExtractor = null) -> GdUnitArrayAssert:
	return self



@warning_ignore("unused_parameter")
func override_failure_message(message :String) -> GdUnitArrayAssert:
	return self


@warning_ignore("unused_parameter")
func append_failure_message(message :String) -> GdUnitArrayAssert:
	return self
## Base interface of all GdUnit asserts
class_name GdUnitAssert
extends RefCounted


## Verifies that the current value is null.
@warning_ignore("untyped_declaration")
func is_null():
	return self


## Verifies that the current value is not null.
@warning_ignore("untyped_declaration")
func is_not_null():
	return self


## Verifies that the current value is equal to expected one.
@warning_ignore("unused_parameter")
@warning_ignore("untyped_declaration")
func is_equal(expected: Variant):
	return self


## Verifies that the current value is not equal to expected one.
@warning_ignore("unused_parameter")
@warning_ignore("untyped_declaration")
func is_not_equal(expected: Variant):
	return self


@warning_ignore("untyped_declaration")
func do_fail():
	return self


## Overrides the default failure message by given custom message.
@warning_ignore("unused_parameter")
@warning_ignore("untyped_declaration")
func override_failure_message(message :String):
	return self


## Appends a custom message to the failure message.
## This can be used to add additional infromations to the generated failure message.
@warning_ignore("unused_parameter")
@warning_ignore("untyped_declaration")
func append_failure_message(message :String):
	return self
class_name GdUnitAwaiter
extends RefCounted


# Waits for a specified signal in an interval of 50ms sent from the <source>, and terminates with an error after the specified timeout has elapsed.
# source: the object from which the signal is emitted
# signal_name: signal name
# args: the expected signal arguments as an array
# timeout: the timeout in ms, default is set to 2000ms
func await_signal_on(source :Object, signal_name :String, args :Array = [], timeout_millis :int = 2000) -> Variant:
	# fail fast if the given source instance invalid
	var assert_that := GdUnitAssertImpl.new(signal_name)
	var line_number := GdUnitAssertions.get_line_number()
	if not is_instance_valid(source):
		@warning_ignore("return_value_discarded")
		assert_that.report_error(GdAssertMessages.error_await_signal_on_invalid_instance(source, signal_name, args), line_number)
		return await (Engine.get_main_loop() as SceneTree).process_frame
	# fail fast if the given source instance invalid
	if not is_instance_valid(source):
		@warning_ignore("return_value_discarded")
		assert_that.report_error(GdAssertMessages.error_await_signal_on_invalid_instance(source, signal_name, args), line_number)
		return await await_idle_frame()
	var awaiter := GdUnitSignalAwaiter.new(timeout_millis)
	var value :Variant = await awaiter.on_signal(source, signal_name, args)
	if awaiter.is_interrupted():
		var failure := "await_signal_on(%s, %s) timed out after %sms" % [signal_name, args, timeout_millis]
		@warning_ignore("return_value_discarded")
		assert_that.report_error(failure, line_number)
	return value


# Waits for a specified signal sent from the <source> between idle frames and aborts with an error after the specified timeout has elapsed
# source: the object from which the signal is emitted
# signal_name: signal name
# args: the expected signal arguments as an array
# timeout: the timeout in ms, default is set to 2000ms
func await_signal_idle_frames(source :Object, signal_name :String, args :Array = [], timeout_millis :int = 2000) -> Variant:
	var line_number := GdUnitAssertions.get_line_number()
	# fail fast if the given source instance invalid
	if not is_instance_valid(source):
		@warning_ignore("return_value_discarded")
		GdUnitAssertImpl.new(signal_name)\
			.report_error(GdAssertMessages.error_await_signal_on_invalid_instance(source, signal_name, args), line_number)
		return await await_idle_frame()
	var awaiter := GdUnitSignalAwaiter.new(timeout_millis, true)
	var value :Variant = await awaiter.on_signal(source, signal_name, args)
	if awaiter.is_interrupted():
		var failure := "await_signal_idle_frames(%s, %s) timed out after %sms" % [signal_name, args, timeout_millis]
		@warning_ignore("return_value_discarded")
		GdUnitAssertImpl.new(signal_name).report_error(failure, line_number)
	return value


# Waits for for a given amount of milliseconds
# example:
#    # waits for 100ms
#    await GdUnitAwaiter.await_millis(myNode, 100).completed
# use this waiter and not `await get_tree().create_timer().timeout to prevent errors when a test case is timed out
func await_millis(milliSec :int) -> void:
	var timer :Timer = Timer.new()
	timer.set_name("gdunit_await_millis_timer_%d" % timer.get_instance_id())
	(Engine.get_main_loop() as SceneTree).root.add_child(timer)
	timer.add_to_group("GdUnitTimers")
	timer.set_one_shot(true)
	timer.start(milliSec / 1000.0)
	await timer.timeout
	timer.queue_free()


# Waits until the next idle frame
func await_idle_frame() -> void:
	await (Engine.get_main_loop() as SceneTree).process_frame
## An Assertion Tool to verify boolean values
class_name GdUnitBoolAssert
extends GdUnitAssert


## Verifies that the current value is null.
func is_null() -> GdUnitBoolAssert:
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitBoolAssert:
	return self


## Verifies that the current value is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitBoolAssert:
	return self


## Verifies that the current value is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitBoolAssert:
	return self


## Verifies that the current value is true.
func is_true() -> GdUnitBoolAssert:
	return self


## Verifies that the current value is false.
func is_false() -> GdUnitBoolAssert:
	return self


## Overrides the default failure message by given custom message.
@warning_ignore("unused_parameter")
func override_failure_message(message :String) -> GdUnitBoolAssert:
	return self
class_name GdUnitConstants
extends RefCounted

const NO_ARG :Variant = "<--null-->"

const EXPECT_ASSERT_REPORT_FAILURES := "expect_assert_report_failures"
## An Assertion Tool to verify dictionary
class_name GdUnitDictionaryAssert
extends GdUnitAssert


## Verifies that the current value is null.
func is_null() -> GdUnitDictionaryAssert:
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is equal to the given one, ignoring order.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is not equal to the given one, ignoring order.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is empty, it has a size of 0.
func is_empty() -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is not empty, it has a size of minimum 1.
func is_not_empty() -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is the same. [br]
## Compares the current by object reference equals
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_same(expected :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary is NOT the same. [br]
## Compares the current by object reference equals
@warning_ignore("unused_parameter")
func is_not_same(expected :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary has a size of given value.
@warning_ignore("unused_parameter")
func has_size(expected: int) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary contains the given key(s).[br]
## The keys are compared by deep parameter comparision, for object reference compare you have to use [method contains_same_keys]
@warning_ignore("unused_parameter")
func contains_keys(expected :Array) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary contains the given key and value.[br]
## The key and value are compared by deep parameter comparision, for object reference compare you have to use [method contains_same_key_value]
@warning_ignore("unused_parameter")
func contains_key_value(key :Variant, value :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary not contains the given key(s).[br]
## This function is [b]deprecated[/b] you have to use [method not_contains_keys] instead
@warning_ignore("unused_parameter")
func contains_not_keys(expected :Array) -> GdUnitDictionaryAssert:
	push_warning("Deprecated: 'contains_not_keys' is deprectated and will be removed soon, use `not_contains_keys` instead!")
	return not_contains_keys(expected)


## Verifies that the current dictionary not contains the given key(s).[br]
## The keys are compared by deep parameter comparision, for object reference compare you have to use [method not_contains_same_keys]
@warning_ignore("unused_parameter")
func not_contains_keys(expected :Array) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary contains the given key(s).[br]
## The keys are compared by object reference, for deep parameter comparision use [method contains_keys]
@warning_ignore("unused_parameter")
func contains_same_keys(expected :Array) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary contains the given key and value.[br]
## The key and value are compared by object reference, for deep parameter comparision use [method contains_key_value]
@warning_ignore("unused_parameter")
func contains_same_key_value(key :Variant, value :Variant) -> GdUnitDictionaryAssert:
	return self


## Verifies that the current dictionary not contains the given key(s).
## The keys are compared by object reference, for deep parameter comparision use [method not_contains_keys]
@warning_ignore("unused_parameter")
func not_contains_same_keys(expected :Array) -> GdUnitDictionaryAssert:
	return self
## An assertion tool to verify GDUnit asserts.
## This assert is for internal use only, to verify that failed asserts work as expected.
class_name GdUnitFailureAssert
extends GdUnitAssert


## Verifies if the executed assert was successful
func is_success() -> GdUnitFailureAssert:
	return self

## Verifies if the executed assert has failed
func is_failed() -> GdUnitFailureAssert:
	return self


## Verifies the failure line is equal to expected one.
@warning_ignore("unused_parameter")
func has_line(expected :int) -> GdUnitFailureAssert:
	return self


## Verifies the failure message is equal to expected one.
@warning_ignore("unused_parameter")
func has_message(expected: String) -> GdUnitFailureAssert:
	return self


## Verifies that the failure message starts with the expected message.
@warning_ignore("unused_parameter")
func starts_with_message(expected: String) -> GdUnitFailureAssert:
	return self


## Verifies that the failure message contains the expected message.
@warning_ignore("unused_parameter")
func contains_message(expected: String) -> GdUnitFailureAssert:
	return self
class_name GdUnitFileAssert
extends GdUnitAssert


func is_file() -> GdUnitFileAssert:
	return self


func exists() -> GdUnitFileAssert:
	return self


func is_script() -> GdUnitFileAssert:
	return self


@warning_ignore("unused_parameter")
func contains_exactly(expected_rows :Array) -> GdUnitFileAssert:
	return self
## An Assertion Tool to verify float values
class_name GdUnitFloatAssert
extends GdUnitAssert


## Verifies that the current String is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitFloatAssert:
	return self


## Verifies that the current String is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitFloatAssert:
	return self


## Verifies that the current and expected value are approximately equal.
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_equal_approx(expected :float, approx :float) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is less than the given one.
@warning_ignore("unused_parameter")
func is_less(expected :float) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is less than or equal the given one.
@warning_ignore("unused_parameter")
func is_less_equal(expected :float) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is greater than the given one.
@warning_ignore("unused_parameter")
func is_greater(expected :float) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is greater than or equal the given one.
@warning_ignore("unused_parameter")
func is_greater_equal(expected :float) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is negative.
func is_negative() -> GdUnitFloatAssert:
	return self


## Verifies that the current value is not negative.
func is_not_negative() -> GdUnitFloatAssert:
	return self


## Verifies that the current value is equal to zero.
func is_zero() -> GdUnitFloatAssert:
	return self


## Verifies that the current value is not equal to zero.
func is_not_zero() -> GdUnitFloatAssert:
	return self


## Verifies that the current value is in the given set of values.
@warning_ignore("unused_parameter")
func is_in(expected :Array) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is not in the given set of values.
@warning_ignore("unused_parameter")
func is_not_in(expected :Array) -> GdUnitFloatAssert:
	return self


## Verifies that the current value is between the given boundaries (inclusive).
@warning_ignore("unused_parameter")
func is_between(from :float, to :float) -> GdUnitFloatAssert:
	return self
## An Assertion Tool to verify function callback values
class_name GdUnitFuncAssert
extends GdUnitAssert


## Verifies that the current value is null.
func is_null() -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that the current value is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that the current value is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that the current value is true.
func is_true() -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that the current value is false.
func is_false() -> GdUnitFuncAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Overrides the default failure message by given custom message.
@warning_ignore("unused_parameter")
func override_failure_message(message :String) -> GdUnitFuncAssert:
	return self


## Sets the timeout in ms to wait the function returnd the expected value, if the time over a failure is emitted.[br]
## e.g.[br]
## do wait until 5s the function `is_state` is returns 10 [br]
## [code]assert_func(instance, "is_state").wait_until(5000).is_equal(10)[/code]
@warning_ignore("unused_parameter")
func wait_until(timeout :int) -> GdUnitFuncAssert:
	return self
## An assertion tool to verify for Godot runtime errors like assert() and push notifications like push_error().
class_name GdUnitGodotErrorAssert
extends GdUnitAssert


## Verifies if the executed code runs without any runtime errors
## Usage:
##     [codeblock]
##		await assert_error(<callable>).is_success()
##     [/codeblock]
func is_success() -> GdUnitGodotErrorAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies if the executed code runs into a runtime error
## Usage:
##     [codeblock]
##		await assert_error(<callable>).is_runtime_error(<expected error message>)
##     [/codeblock]
@warning_ignore("unused_parameter")
func is_runtime_error(expected_error :String) -> GdUnitGodotErrorAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies if the executed code has a push_warning() used
## Usage:
##     [codeblock]
##		await assert_error(<callable>).is_push_warning(<expected push warning message>)
##     [/codeblock]
@warning_ignore("unused_parameter")
func is_push_warning(expected_warning :String) -> GdUnitGodotErrorAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies if the executed code has a push_error() used
## Usage:
##     [codeblock]
##		await assert_error(<callable>).is_push_error(<expected push error message>)
##     [/codeblock]
@warning_ignore("unused_parameter")
func is_push_error(expected_error :String) -> GdUnitGodotErrorAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self
## An Assertion Tool to verify integer values
class_name GdUnitIntAssert
extends GdUnitAssert

## Verifies that the current String is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitIntAssert:
	return self


## Verifies that the current String is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitIntAssert:
	return self


## Verifies that the current value is less than the given one.
@warning_ignore("unused_parameter")
func is_less(expected :int) -> GdUnitIntAssert:
	return self


## Verifies that the current value is less than or equal the given one.
@warning_ignore("unused_parameter")
func is_less_equal(expected :int) -> GdUnitIntAssert:
	return self


## Verifies that the current value is greater than the given one.
@warning_ignore("unused_parameter")
func is_greater(expected :int) -> GdUnitIntAssert:
	return self


## Verifies that the current value is greater than or equal the given one.
@warning_ignore("unused_parameter")
func is_greater_equal(expected :int) -> GdUnitIntAssert:
	return self


## Verifies that the current value is even.
func is_even() -> GdUnitIntAssert:
	return self


## Verifies that the current value is odd.
func is_odd() -> GdUnitIntAssert:
	return self


## Verifies that the current value is negative.
func is_negative() -> GdUnitIntAssert:
	return self


## Verifies that the current value is not negative.
func is_not_negative() -> GdUnitIntAssert:
	return self


## Verifies that the current value is equal to zero.
func is_zero() -> GdUnitIntAssert:
	return self


## Verifies that the current value is not equal to zero.
func is_not_zero() -> GdUnitIntAssert:
	return self


## Verifies that the current value is in the given set of values.
@warning_ignore("unused_parameter")
func is_in(expected :Array) -> GdUnitIntAssert:
	return self


## Verifies that the current value is not in the given set of values.
@warning_ignore("unused_parameter")
func is_not_in(expected :Array) -> GdUnitIntAssert:
	return self


## Verifies that the current value is between the given boundaries (inclusive).
@warning_ignore("unused_parameter")
func is_between(from :int, to :int) -> GdUnitIntAssert:
	return self
## An Assertion Tool to verify Object values
class_name GdUnitObjectAssert
extends GdUnitAssert


## Verifies that the current value is equal to expected one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitObjectAssert:
	return self


## Verifies that the current value is not equal to expected one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitObjectAssert:
	return self


## Verifies that the current value is null.
func is_null() -> GdUnitObjectAssert:
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitObjectAssert:
	return self


## Verifies that the current value is the same as the given one.
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_same(expected :Variant) -> GdUnitObjectAssert:
	return self


## Verifies that the current value is not the same as the given one.
@warning_ignore("unused_parameter")
func is_not_same(expected :Variant) -> GdUnitObjectAssert:
	return self


## Verifies that the current value is an instance of the given type.
@warning_ignore("unused_parameter")
func is_instanceof(expected :Object) -> GdUnitObjectAssert:
	return self


## Verifies that the current value is not an instance of the given type.
@warning_ignore("unused_parameter")
func is_not_instanceof(expected :Variant) -> GdUnitObjectAssert:
	return self
## An Assertion Tool to verify Results
class_name GdUnitResultAssert
extends GdUnitAssert


## Verifies that the current value is null.
func is_null() -> GdUnitResultAssert:
	return self


## Verifies that the current value is not null.
func is_not_null() -> GdUnitResultAssert:
	return self


## Verifies that the result is ends up with empty
func is_empty() -> GdUnitResultAssert:
	return self


## Verifies that the result is ends up with success
func is_success() -> GdUnitResultAssert:
	return self


## Verifies that the result is ends up with warning
func is_warning() -> GdUnitResultAssert:
	return self


## Verifies that the result is ends up with error
func is_error() -> GdUnitResultAssert:
	return self


## Verifies that the result contains the given message
@warning_ignore("unused_parameter")
func contains_message(expected :String) -> GdUnitResultAssert:
	return self


## Verifies that the result contains the given value
@warning_ignore("unused_parameter")
func is_value(expected :Variant) -> GdUnitResultAssert:
	return self
## The Scene Runner is a tool used for simulating interactions on a scene.
## With this tool, you can simulate input events such as keyboard or mouse input and/or simulate scene processing over a certain number of frames.
## This tool is typically used for integration testing a scene.
class_name GdUnitSceneRunner
extends RefCounted

const NO_ARG = GdUnitConstants.NO_ARG


## Simulates that an action has been pressed.[br]
## [member action] : the action e.g. [code]"ui_up"[/code][br]
@warning_ignore("unused_parameter")
func simulate_action_pressed(action: String) -> GdUnitSceneRunner:
	return self


## Simulates that an action is pressed.[br]
## [member action] : the action e.g. [code]"ui_up"[/code][br]
@warning_ignore("unused_parameter")
func simulate_action_press(action: String) -> GdUnitSceneRunner:
	return self


## Simulates that an action has been released.[br]
## [member action] : the action e.g. [code]"ui_up"[/code][br]
@warning_ignore("unused_parameter")
func simulate_action_release(action: String) -> GdUnitSceneRunner:
	return self


## Simulates that a key has been pressed.[br]
## [member key_code] : the key code e.g. [constant KEY_ENTER][br]
## [member shift_pressed] : false by default set to true if simmulate shift is press[br]
## [member ctrl_pressed] : false by default set to true if simmulate control is press[br]
## [codeblock]
##    func test_key_presssed():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       await runner.simulate_key_pressed(KEY_SPACE)
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_key_pressed(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates that a key is pressed.[br]
## [member key_code] : the key code e.g. [constant KEY_ENTER][br]
## [member shift_pressed] : false by default set to true if simmulate shift is press[br]
## [member ctrl_pressed] : false by default set to true if simmulate control is press[br]
@warning_ignore("unused_parameter")
func simulate_key_press(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	return self


## Simulates that a key has been released.[br]
## [member key_code] : the key code e.g. [constant KEY_ENTER][br]
## [member shift_pressed] : false by default set to true if simmulate shift is press[br]
## [member ctrl_pressed] : false by default set to true if simmulate control is press[br]
@warning_ignore("unused_parameter")
func simulate_key_release(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	return self


## Sets the mouse cursor to given position relative to the viewport.
## @deprecated: Use [set_mouse_position] instead.
@warning_ignore("unused_parameter")
func set_mouse_pos(position: Vector2) -> GdUnitSceneRunner:
	return self


## Sets the mouse position to the specified vector, provided in pixels and relative to an origin at the upper left corner of the currently focused Window Manager game window.[br]
## [member position] : The absolute position in pixels as Vector2
@warning_ignore("unused_parameter")
func set_mouse_position(position: Vector2) -> GdUnitSceneRunner:
	return self


## Returns the mouse's position in this Viewport using the coordinate system of this Viewport.
func get_mouse_position() -> Vector2:
	return Vector2.ZERO


## Gets the current global mouse position of the current window
func get_global_mouse_position() -> Vector2:
	return Vector2.ZERO


## Simulates a mouse moved to final position.[br]
## [member position] : The final mouse position
@warning_ignore("unused_parameter")
func simulate_mouse_move(position: Vector2) -> GdUnitSceneRunner:
	return self


## Simulates a mouse move to the relative coordinates (offset).[br]
## [color=yellow]You must use [b]await[/b] to wait until the simulated mouse movement is complete.[/color][br]
## [br]
## [member relative] : The relative position, indicating the mouse position offset.[br]
## [member time] : The time to move the mouse by the relative position in seconds (default is 1 second).[br]
## [member trans_type] : Sets the type of transition used (default is TRANS_LINEAR).[br]
## [codeblock]
##    func test_move_mouse():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       await runner.simulate_mouse_move_relative(Vector2(100,100))
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_mouse_move_relative(relative: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates a mouse move to the absolute coordinates.[br]
## [color=yellow]You must use [b]await[/b] to wait until the simulated mouse movement is complete.[/color][br]
## [br]
## [member position] : The final position of the mouse.[br]
## [member time] : The time to move the mouse to the final position in seconds (default is 1 second).[br]
## [member trans_type] : Sets the type of transition used (default is TRANS_LINEAR).[br]
## [codeblock]
##    func test_move_mouse():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       await runner.simulate_mouse_move_absolute(Vector2(100,100))
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_mouse_move_absolute(position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates a mouse button pressed.[br]
## [member button_index] : The mouse button identifier, one of the [enum MouseButton] or button wheel constants.
## [member double_click] : Set to true to simulate a double-click
@warning_ignore("unused_parameter")
func simulate_mouse_button_pressed(button_index: MouseButton, double_click := false) -> GdUnitSceneRunner:
	return self


## Simulates a mouse button press (holding)[br]
## [member button_index] : The mouse button identifier, one of the [enum MouseButton] or button wheel constants.
## [member double_click] : Set to true to simulate a double-click
@warning_ignore("unused_parameter")
func simulate_mouse_button_press(button_index: MouseButton, double_click := false) -> GdUnitSceneRunner:
	return self


## Simulates a mouse button released.[br]
## [member button_index] : The mouse button identifier, one of the [enum MouseButton] or button wheel constants.
@warning_ignore("unused_parameter")
func simulate_mouse_button_release(button_index: MouseButton) -> GdUnitSceneRunner:
	return self


## Simulates a screen touch is pressed.[br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member position] : The position to touch the screen.[br]
## [member double_tap] : If true, the touch's state is a double tab.
@warning_ignore("unused_parameter")
func simulate_screen_touch_pressed(index: int, position: Vector2, double_tap := false) -> GdUnitSceneRunner:
	return self


## Simulates a screen touch press without releasing it immediately, effectively simulating a "hold" action.[br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member position] : The position to touch the screen.[br]
## [member double_tap] : If true, the touch's state is a double tab.
@warning_ignore("unused_parameter")
func simulate_screen_touch_press(index: int, position: Vector2, double_tap := false) -> GdUnitSceneRunner:
	return self


## Simulates a screen touch is released.[br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member double_tap] : If true, the touch's state is a double tab.
@warning_ignore("unused_parameter")
func simulate_screen_touch_release(index: int, double_tap := false) -> GdUnitSceneRunner:
	return self


## Simulates a touch drag and drop event to a relative position.[br]
## [color=yellow]You must use [b]await[/b] to wait until the simulated drag&drop is complete.[/color][br]
## [br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member relative] : The relative position, indicating the drag&drop position offset.[br]
## [member time] : The time to move to the relative position in seconds (default is 1 second).[br]
## [member trans_type] : Sets the type of transition used (default is TRANS_LINEAR).[br]
## [codeblock]
##    func test_touch_drag_drop():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       # start drag at position 50,50
##       runner.simulate_screen_touch_drag_begin(1, Vector2(50, 50))
##       # and drop it at final at 150,50  relative (50,50 + 100,0)
##       await runner.simulate_screen_touch_drag_relative(1, Vector2(100,0))
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_screen_touch_drag_relative(index: int, relative: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates a touch screen drop to the absolute coordinates (offset).[br]
## [color=yellow]You must use [b]await[/b] to wait until the simulated drop is complete.[/color][br]
## [br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member position] : The final position, indicating the drop position.[br]
## [member time] : The time to move to the final position in seconds (default is 1 second).[br]
## [member trans_type] : Sets the type of transition used (default is TRANS_LINEAR).[br]
## [codeblock]
##    func test_touch_drag_drop():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       # start drag at position 50,50
##       runner.simulate_screen_touch_drag_begin(1, Vector2(50, 50))
##       # and drop it at 100,50
##       await runner.simulate_screen_touch_drag_absolute(1, Vector2(100,50))
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_screen_touch_drag_absolute(index: int, position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates a complete drag and drop event from one position to another.[br]
## This is ideal for testing complex drag-and-drop scenarios that require a specific start and end position.[br]
## [color=yellow]You must use [b]await[/b] to wait until the simulated drop is complete.[/color][br]
## [br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member position] : The drag start position, indicating the drag position.[br]
## [member drop_position] : The drop position, indicating the drop position.[br]
## [member time] : The time to move to the final position in seconds (default is 1 second).[br]
## [member trans_type] : Sets the type of transition used (default is TRANS_LINEAR).[br]
## [codeblock]
##    func test_touch_drag_drop():
##       var runner = scene_runner("res://scenes/simple_scene.tscn")
##       # start drag at position 50,50 and drop it at 100,50
##       await runner.simulate_screen_touch_drag_drop(1, Vector2(50, 50), Vector2(100,50))
## [/codeblock]
@warning_ignore("unused_parameter")
func simulate_screen_touch_drag_drop(index: int, position: Vector2, drop_position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates a touch screen drag event to given position.[br]
## [member index] : The touch index in the case of a multi-touch event.[br]
## [member position] : The drag start position, indicating the drag position.[br]
@warning_ignore("unused_parameter")
func simulate_screen_touch_drag(index: int, position: Vector2) -> GdUnitSceneRunner:
	return self


## Returns the actual position of the touchscreen drag position by given index.
## [member index] : The touch index in the case of a multi-touch event.[br]
@warning_ignore("unused_parameter")
func get_screen_touch_drag_position(index: int) -> Vector2:
	return Vector2.ZERO


## Sets how fast or slow the scene simulation is processed (clock ticks versus the real).[br]
## It defaults to 1.0. A value of 2.0 means the game moves twice as fast as real life,
## whilst a value of 0.5 means the game moves at half the regular speed.


## Sets the time factor for the scene simulation.
## [member time_factor] : A float representing the simulation speed.[br]
## - Default is 1.0, meaning the simulation runs at normal speed.[br]
## - A value of 2.0 means the simulation runs twice as fast as real time.[br]
## - A value of 0.5 means the simulation runs at half the regular speed.[br]
@warning_ignore("unused_parameter")
func set_time_factor(time_factor: float = 1.0) -> GdUnitSceneRunner:
	return self


## Simulates scene processing for a certain number of frames.[br]
## [member frames] : amount of frames to process[br]
## [member delta_milli] : the time delta between a frame in milliseconds
@warning_ignore("unused_parameter")
func simulate_frames(frames: int, delta_milli: int = -1) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates scene processing until the given signal is emitted by the scene.[br]
## [member signal_name] : the signal to stop the simulation[br]
## [member args] : optional signal arguments to be matched for stop[br]
@warning_ignore("unused_parameter")
func simulate_until_signal(
	signal_name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Simulates scene processing until the given signal is emitted by the given object.[br]
## [member source] : the object that should emit the signal[br]
## [member signal_name] : the signal to stop the simulation[br]
## [member args] : optional signal arguments to be matched for stop
@warning_ignore("unused_parameter")
func simulate_until_object_signal(
	source: Object,
	signal_name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> GdUnitSceneRunner:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Waits for all input events to be processed by flushing any buffered input events
## and then awaiting a full cycle of both the process and physics frames.[br]
## [br]
## This is typically used to ensure that any simulated or queued inputs are fully
## processed before proceeding with the next steps in the scene.[br]
## It's essential for reliable input simulation or when synchronizing logic based
## on inputs.[br]
##
## Usage Example:
## [codeblock]
## 	await await_input_processed()  # Ensure all inputs are processed before continuing
## [/codeblock]
func await_input_processed() -> void:
	if scene() != null and scene().process_mode != Node.PROCESS_MODE_DISABLED:
		Input.flush_buffered_events()
	await (Engine.get_main_loop() as SceneTree).process_frame
	await (Engine.get_main_loop() as SceneTree).physics_frame


## The await_func function pauses execution until a specified function in the scene returns a value.[br]
## It returns a [GdUnitFuncAssert], which provides a suite of assertion methods to verify the returned value.[br]
## [member func_name] : The name of the function to wait for.[br]
## [member args] : Optional function arguments
## [br]
## Usage Example:
## [codeblock]
## 	# Waits for 'calculate_score' function and verifies the result is equal to 100.
## 	await_func("calculate_score").is_equal(100)
## [/codeblock]
@warning_ignore("unused_parameter")
func await_func(func_name: String, args := []) -> GdUnitFuncAssert:
	return null



## The await_func_on function extends the functionality of await_func by allowing you to specify a source node within the scene.[br]
## It waits for a specified function on that node to return a value and returns a [GdUnitFuncAssert] object for assertions.[br]
## [member source] : The object where implements the function.[br]
## [member func_name] : The name of the function to wait for.[br]
## [member args] : optional function arguments
## [br]
## Usage Example:
## [codeblock]
## 	# Waits for 'calculate_score' function and verifies the result is equal to 100.
## 	var my_instance := ScoreCalculator.new()
## 	await_func(my_instance, "calculate_score").is_equal(100)
## [/codeblock]
@warning_ignore("unused_parameter")
func await_func_on(source: Object, func_name: String, args := []) -> GdUnitFuncAssert:
	return null


## Waits for the specified signal to be emitted by the scene. If the signal is not emitted within the given timeout, the operation fails.[br]
## [member signal_name] : The name of the signal to wait for[br]
## [member args] : The signal arguments as an array[br]
## [member timeout] : The maximum duration (in milliseconds) to wait for the signal to be emitted before failing
@warning_ignore("unused_parameter")
func await_signal(signal_name: String, args := [], timeout := 2000 ) -> void:
	await (Engine.get_main_loop() as SceneTree).process_frame
	pass


## Waits for the specified signal to be emitted by a particular source node. If the signal is not emitted within the given timeout, the operation fails.[br]
## [member source] : the object from which the signal is emitted[br]
## [member signal_name] : The name of the signal to wait for[br]
## [member args] : The signal arguments as an array[br]
## [member timeout] : tThe maximum duration (in milliseconds) to wait for the signal to be emitted before failing
@warning_ignore("unused_parameter")
func await_signal_on(source: Object, signal_name: String, args := [], timeout := 2000 ) -> void:
	pass


## Restores the scene window to a windowed mode and brings it to the foreground.[br]
## This ensures that the scene is visible and active during testing, making it easier to observe and interact with.
func move_window_to_foreground() -> GdUnitSceneRunner:
	return self


## Restores the scene window to a windowed mode and brings it to the foreground.[br]
## This ensures that the scene is visible and active during testing, making it easier to observe and interact with.
## @deprecated: Use [move_window_to_foreground] instead.
func maximize_view() -> GdUnitSceneRunner:
	return self


## Return the current value of the property with the name <name>.[br]
## [member name] : name of property[br]
## [member return] : the value of the property
@warning_ignore("unused_parameter")
func get_property(name: String) -> Variant:
	return null

## Set the  value <value> of the property with the name <name>.[br]
## [member name] : name of property[br]
## [member value] : value of property[br]
## [member return] : true|false depending on valid property name.
@warning_ignore("unused_parameter")
func set_property(name: String, value: Variant) -> bool:
	return false


## executes the function specified by <name> in the scene and returns the result.[br]
## [member name] : the name of the function to execute[br]
## [member args] : optional function arguments[br]
## [member return] : the function result
@warning_ignore("unused_parameter")
func invoke(
	name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> Variant:
	return null


## Searches for the specified node with the name in the current scene and returns it, otherwise null.[br]
## [member name] : the name of the node to find[br]
## [member recursive] : enables/disables seraching recursive[br]
## [member return] : the node if find otherwise null
@warning_ignore("unused_parameter")
func find_child(name: String, recursive: bool = true, owned: bool = false) -> Node:
	return null


## Access to current running scene
func scene() -> Node:
	return null
## An Assertion Tool to verify for emitted signals until a waiting time
class_name GdUnitSignalAssert
extends GdUnitAssert


## Verifies that given signal is emitted until waiting time
@warning_ignore("unused_parameter")
func is_emitted(name :String, args := []) -> GdUnitSignalAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies that given signal is NOT emitted until waiting time
@warning_ignore("unused_parameter")
func is_not_emitted(name :String, args := []) -> GdUnitSignalAssert:
	await (Engine.get_main_loop() as SceneTree).process_frame
	return self


## Verifies the signal exists checked the emitter
@warning_ignore("unused_parameter")
func is_signal_exists(name :String) -> GdUnitSignalAssert:
	return self


## Overrides the default failure message by given custom message.
@warning_ignore("unused_parameter")
func override_failure_message(message :String) -> GdUnitSignalAssert:
	return self


## Sets the assert signal timeout in ms, if the time over a failure is reported.[br]
## e.g.[br]
## do wait until 5s the instance has emitted the signal `signal_a`[br]
## [code]assert_signal(instance).wait_until(5000).is_emitted("signal_a")[/code]
@warning_ignore("unused_parameter")
func wait_until(timeout :int) -> GdUnitSignalAssert:
	return self
## An Assertion Tool to verify String values
class_name GdUnitStringAssert
extends GdUnitAssert


## Verifies that the current String is equal to the given one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitStringAssert:
	return self


## Verifies that the current String is equal to the given one, ignoring case considerations.
@warning_ignore("unused_parameter")
func is_equal_ignoring_case(expected :Variant) -> GdUnitStringAssert:
	return self


## Verifies that the current String is not equal to the given one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitStringAssert:
	return self


## Verifies that the current String is not equal to the given one, ignoring case considerations.
@warning_ignore("unused_parameter")
func is_not_equal_ignoring_case(expected :Variant) -> GdUnitStringAssert:
	return self


## Verifies that the current String is empty, it has a length of 0.
func is_empty() -> GdUnitStringAssert:
	return self


## Verifies that the current String is not empty, it has a length of minimum 1.
func is_not_empty() -> GdUnitStringAssert:
	return self


## Verifies that the current String contains the given String.
@warning_ignore("unused_parameter")
func contains(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String does not contain the given String.
@warning_ignore("unused_parameter")
func not_contains(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String does not contain the given String, ignoring case considerations.
@warning_ignore("unused_parameter")
func contains_ignoring_case(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String does not contain the given String, ignoring case considerations.
@warning_ignore("unused_parameter")
func not_contains_ignoring_case(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String starts with the given prefix.
@warning_ignore("unused_parameter")
func starts_with(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String ends with the given suffix.
@warning_ignore("unused_parameter")
func ends_with(expected: String) -> GdUnitStringAssert:
	return self


## Verifies that the current String has the expected length by used comparator.
@warning_ignore("unused_parameter")
func has_length(length: int, comparator: int = Comparator.EQUAL) -> GdUnitStringAssert:
	return self
## The main class for all GdUnit test suites[br]
## This class is the main class to implement your unit tests[br]
## You have to extend and implement your test cases as described[br]
## e.g MyTests.gd [br]
## [codeblock]
##    extends GdUnitTestSuite
##    # testcase
##    func test_case_a():
##       assert_that("value").is_equal("value")
## [/codeblock]
## @tutorial:  https://mikeschulze.github.io/gdUnit4/faq/test-suite/

@icon("res://addons/gdUnit4/src/ui/settings/logo.png")
class_name GdUnitTestSuite
extends Node

const NO_ARG :Variant = GdUnitConstants.NO_ARG

### internal runtime variables that must not be overwritten!!!
@warning_ignore("unused_private_class_variable")
var __is_skipped := false
@warning_ignore("unused_private_class_variable")
var __skip_reason :String = "Unknow."
var __active_test_case :String
var __awaiter := __gdunit_awaiter()


### We now load all used asserts and tool scripts into the cache according to the principle of "lazy loading"
### in order to noticeably reduce the loading time of the test suite.
# We go this hard way to increase the loading performance to avoid reparsing all the used scripts
# for more detailed info -> https://github.com/godotengine/godot/issues/67400
func __lazy_load(script_path :String) -> GDScript:
	return GdUnitAssertions.__lazy_load(script_path)


func __gdunit_assert() -> GDScript:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitAssertImpl.gd")


func __gdunit_tools() -> GDScript:
	return __lazy_load("res://addons/gdUnit4/src/core/GdUnitTools.gd")


func __gdunit_file_access() -> GDScript:
	return __lazy_load("res://addons/gdUnit4/src/core/GdUnitFileAccess.gd")


func __gdunit_awaiter() -> Object:
	return __lazy_load("res://addons/gdUnit4/src/GdUnitAwaiter.gd").new()


func __gdunit_argument_matchers() -> GDScript:
	return __lazy_load("res://addons/gdUnit4/src/matchers/GdUnitArgumentMatchers.gd")


func __gdunit_object_interactions() -> GDScript:
	return __lazy_load("res://addons/gdUnit4/src/core/GdUnitObjectInteractions.gd")


## This function is called before a test suite starts[br]
## You can overwrite to prepare test data or initalizize necessary variables
func before() -> void:
	pass


## This function is called at least when a test suite is finished[br]
## You can overwrite to cleanup data created during test running
func after() -> void:
	pass


## This function is called before a test case starts[br]
## You can overwrite to prepare test case specific data
func before_test() -> void:
	pass


## This function is called after the test case is finished[br]
## You can overwrite to cleanup your test case specific data
func after_test() -> void:
	pass


func is_failure(_expected_failure :String = NO_ARG) -> bool:
	return Engine.get_meta("GD_TEST_FAILURE") if Engine.has_meta("GD_TEST_FAILURE") else false


func set_active_test_case(test_case :String) -> void:
	__active_test_case = test_case


# === Tools ====================================================================
# Mapps Godot error number to a readable error message. See at ERROR
# https://docs.godotengine.org/de/stable/classes/class_@globalscope.html#enum-globalscope-error
func error_as_string(error_number :int) -> String:
	return error_string(error_number)


## A litle helper to auto freeing your created objects after test execution
func auto_free(obj :Variant) -> Variant:
	var execution_context := GdUnitThreadManager.get_current_context().get_execution_context()

	assert(execution_context != null, "INTERNAL ERROR: The current execution_context is null! Please report this as bug.")
	return execution_context.register_auto_free(obj)


@warning_ignore("native_method_override")
func add_child(node :Node, force_readable_name := false, internal := Node.INTERNAL_MODE_DISABLED) -> void:
	super.add_child(node, force_readable_name, internal)
	var execution_context := GdUnitThreadManager.get_current_context().get_execution_context()
	if execution_context != null:
		execution_context.orphan_monitor_start()


## Discard the error message triggered by a timeout (interruption).[br]
## By default, an interrupted test is reported as an error.[br]
## This function allows you to change the message to Success when an interrupted error is reported.
func discard_error_interupted_by_timeout() -> void:
	@warning_ignore("unsafe_method_access")
	__gdunit_tools().register_expect_interupted_by_timeout(self, __active_test_case)


## Creates a new directory under the temporary directory *user://tmp*[br]
## Useful for storing data during test execution. [br]
## The directory is automatically deleted after test suite execution
func create_temp_dir(relative_path :String) -> String:
	@warning_ignore("unsafe_method_access")
	return __gdunit_file_access().create_temp_dir(relative_path)


## Deletes the temporary base directory[br]
## Is called automatically after each execution of the test suite
func clean_temp_dir() -> void:
	@warning_ignore("unsafe_method_access")
	__gdunit_file_access().clear_tmp()


## Creates a new file under the temporary directory *user://tmp* + <relative_path>[br]
## with given name <file_name> and given file <mode> (default = File.WRITE)[br]
## If success the returned File is automatically closed after the execution of the test suite
func create_temp_file(relative_path :String, file_name :String, mode := FileAccess.WRITE) -> FileAccess:
	@warning_ignore("unsafe_method_access")
	return __gdunit_file_access().create_temp_file(relative_path, file_name, mode)


## Reads a resource by given path <resource_path> into a PackedStringArray.
func resource_as_array(resource_path :String) -> PackedStringArray:
	@warning_ignore("unsafe_method_access")
	return __gdunit_file_access().resource_as_array(resource_path)


## Reads a resource by given path <resource_path> and returned the content as String.
func resource_as_string(resource_path :String) -> String:
	@warning_ignore("unsafe_method_access")
	return __gdunit_file_access().resource_as_string(resource_path)


## Reads a resource by given path <resource_path> and return Variand translated by str_to_var
func resource_as_var(resource_path :String) -> Variant:
	@warning_ignore("unsafe_method_access", "unsafe_cast")
	return str_to_var(__gdunit_file_access().resource_as_string(resource_path) as String)


## Waits for given signal is emited by the <source> until a specified timeout to fail[br]
## source: the object from which the signal is emitted[br]
## signal_name: signal name[br]
## args: the expected signal arguments as an array[br]
## timeout: the timeout in ms, default is set to 2000ms
func await_signal_on(source :Object, signal_name :String, args :Array = [], timeout :int = 2000) -> Variant:
	@warning_ignore("unsafe_method_access")
	return await __awaiter.await_signal_on(source, signal_name, args, timeout)


## Waits until the next idle frame
func await_idle_frame() -> void:
	@warning_ignore("unsafe_method_access")
	await __awaiter.await_idle_frame()


## Waits for for a given amount of milliseconds[br]
## example:[br]
## [codeblock]
##    # waits for 100ms
##    await await_millis(myNode, 100).completed
## [/codeblock][br]
## use this waiter and not `await get_tree().create_timer().timeout to prevent errors when a test case is timed out
func await_millis(timeout :int) -> void:
	@warning_ignore("unsafe_method_access")
	await __awaiter.await_millis(timeout)


## Creates a new scene runner to allow simulate interactions checked a scene.[br]
## The runner will manage the scene instance and release after the runner is released[br]
## example:[br]
## [codeblock]
##    # creates a runner by using a instanciated scene
##    var scene = load("res://foo/my_scne.tscn").instantiate()
##    var runner := scene_runner(scene)
##
##    # or simply creates a runner by using the scene resource path
##    var runner := scene_runner("res://foo/my_scne.tscn")
## [/codeblock]
func scene_runner(scene :Variant, verbose := false) -> GdUnitSceneRunner:
	return auto_free(__lazy_load("res://addons/gdUnit4/src/core/GdUnitSceneRunnerImpl.gd").new(scene, verbose))


# === Mocking  & Spy ===========================================================

## do return a default value for primitive types or null
const RETURN_DEFAULTS = GdUnitMock.RETURN_DEFAULTS
## do call the real implementation
const CALL_REAL_FUNC = GdUnitMock.CALL_REAL_FUNC
## do return a default value for primitive types and a fully mocked value for Object types
## builds full deep mocked object
const RETURN_DEEP_STUB = GdUnitMock.RETURN_DEEP_STUB


## Creates a mock for given class name
func mock(clazz :Variant, mock_mode := RETURN_DEFAULTS) -> Variant:
	@warning_ignore("unsafe_method_access")
	return __lazy_load("res://addons/gdUnit4/src/mocking/GdUnitMockBuilder.gd").build(clazz, mock_mode)


## Creates a spy checked given object instance
func spy(instance :Variant) -> Variant:
	@warning_ignore("unsafe_method_access")
	return __lazy_load("res://addons/gdUnit4/src/spy/GdUnitSpyBuilder.gd").build(instance)


## Configures a return value for the specified function and used arguments.[br]
## [b]Example:
## 	[codeblock]
## 		# overrides the return value of myMock.is_selected() to false
## 		do_return(false).on(myMock).is_selected()
## 	[/codeblock]
func do_return(value :Variant) -> GdUnitMock:
	return GdUnitMock.new(value)


## Verifies certain behavior happened at least once or exact number of times
func verify(obj :Variant, times := 1) -> Variant:
	@warning_ignore("unsafe_method_access")
	return __gdunit_object_interactions().verify(obj, times)


## Verifies no interactions is happen checked this mock or spy
func verify_no_interactions(obj :Variant) -> GdUnitAssert:
	@warning_ignore("unsafe_method_access")
	return __gdunit_object_interactions().verify_no_interactions(obj)


## Verifies the given mock or spy has any unverified interaction.
func verify_no_more_interactions(obj :Variant) -> GdUnitAssert:
	@warning_ignore("unsafe_method_access")
	return __gdunit_object_interactions().verify_no_more_interactions(obj)


## Resets the saved function call counters checked a mock or spy
func reset(obj :Variant) -> void:
	@warning_ignore("unsafe_method_access")
	__gdunit_object_interactions().reset(obj)


## Starts monitoring the specified source to collect all transmitted signals.[br]
## The collected signals can then be checked with 'assert_signal'.[br]
## By default, the specified source is automatically released when the test ends.
## You can control this behavior by setting auto_free to false if you do not want the source to be automatically freed.[br]
## Usage:
##	[codeblock]
##		var emitter := monitor_signals(MyEmitter.new())
##		# call the function to send the signal
##		emitter.do_it()
##		# verify the signial is emitted
##		await assert_signal(emitter).is_emitted('my_signal')
##	[/codeblock]
func monitor_signals(source :Object, _auto_free := true) -> Object:
	@warning_ignore("unsafe_method_access")
	__lazy_load("res://addons/gdUnit4/src/core/thread/GdUnitThreadManager.gd")\
		.get_current_context()\
		.get_signal_collector()\
		.register_emitter(source)
	return auto_free(source) if _auto_free else source


# === Argument matchers ========================================================
## Argument matcher to match any argument
func any() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().any()


## Argument matcher to match any boolean value
func any_bool() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_BOOL)


## Argument matcher to match any integer value
func any_int() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_INT)


## Argument matcher to match any float value
func any_float() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_FLOAT)


## Argument matcher to match any string value
func any_string() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_STRING)


## Argument matcher to match any Color value
func any_color() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_COLOR)


## Argument matcher to match any Vector typed value
func any_vector() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_types([
		TYPE_VECTOR2,
		TYPE_VECTOR2I,
		TYPE_VECTOR3,
		TYPE_VECTOR3I,
		TYPE_VECTOR4,
		TYPE_VECTOR4I,
	])


## Argument matcher to match any Vector2 value
func any_vector2() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR2)


## Argument matcher to match any Vector2i value
func any_vector2i() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR2I)


## Argument matcher to match any Vector3 value
func any_vector3() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR3)


## Argument matcher to match any Vector3i value
func any_vector3i() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR3I)


## Argument matcher to match any Vector4 value
func any_vector4() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR4)


## Argument matcher to match any Vector3i value
func any_vector4i() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_VECTOR4I)


## Argument matcher to match any Rect2 value
func any_rect2() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_RECT2)


## Argument matcher to match any Plane value
func any_plane() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PLANE)


## Argument matcher to match any Quaternion value
func any_quat() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_QUATERNION)


## Argument matcher to match any AABB value
func any_aabb() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_AABB)


## Argument matcher to match any Basis value
func any_basis() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_BASIS)


## Argument matcher to match any Transform2D value
func any_transform_2d() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_TRANSFORM2D)


## Argument matcher to match any Transform3D value
func any_transform_3d() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_TRANSFORM3D)


## Argument matcher to match any NodePath value
func any_node_path() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_NODE_PATH)


## Argument matcher to match any RID value
func any_rid() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_RID)


## Argument matcher to match any Object value
func any_object() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_OBJECT)


## Argument matcher to match any Dictionary value
func any_dictionary() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_DICTIONARY)


## Argument matcher to match any Array value
func any_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_ARRAY)


## Argument matcher to match any PackedByteArray value
func any_packed_byte_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_BYTE_ARRAY)


## Argument matcher to match any PackedInt32Array value
func any_packed_int32_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_INT32_ARRAY)


## Argument matcher to match any PackedInt64Array value
func any_packed_int64_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_INT64_ARRAY)


## Argument matcher to match any PackedFloat32Array value
func any_packed_float32_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_FLOAT32_ARRAY)


## Argument matcher to match any PackedFloat64Array value
func any_packed_float64_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_FLOAT64_ARRAY)


## Argument matcher to match any PackedStringArray value
func any_packed_string_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_STRING_ARRAY)


## Argument matcher to match any PackedVector2Array value
func any_packed_vector2_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_VECTOR2_ARRAY)


## Argument matcher to match any PackedVector3Array value
func any_packed_vector3_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_VECTOR3_ARRAY)


## Argument matcher to match any PackedColorArray value
func any_packed_color_array() -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().by_type(TYPE_PACKED_COLOR_ARRAY)


## Argument matcher to match any instance of given class
func any_class(clazz :Object) -> GdUnitArgumentMatcher:
	@warning_ignore("unsafe_method_access")
	return __gdunit_argument_matchers().any_class(clazz)


# === value extract utils ======================================================
## Builds an extractor by given function name and optional arguments
func extr(func_name :String, args := Array()) -> GdUnitValueExtractor:
	return __lazy_load("res://addons/gdUnit4/src/extractors/GdUnitFuncValueExtractor.gd").new(func_name, args)


## Constructs a tuple by given arguments
func tuple(arg0 :Variant,
	arg1 :Variant=NO_ARG,
	arg2 :Variant=NO_ARG,
	arg3 :Variant=NO_ARG,
	arg4 :Variant=NO_ARG,
	arg5 :Variant=NO_ARG,
	arg6 :Variant=NO_ARG,
	arg7 :Variant=NO_ARG,
	arg8 :Variant=NO_ARG,
	arg9 :Variant=NO_ARG) -> GdUnitTuple:
	return GdUnitTuple.new(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)


# === Asserts ==================================================================

## The common assertion tool to verify values.
## It checks the given value by type to fit to the best assert
func assert_that(current :Variant) -> GdUnitAssert:
	match typeof(current):
		TYPE_BOOL:
			return assert_bool(current)
		TYPE_INT:
			return assert_int(current)
		TYPE_FLOAT:
			return assert_float(current)
		TYPE_STRING:
			return assert_str(current)
		TYPE_VECTOR2, TYPE_VECTOR2I, TYPE_VECTOR3, TYPE_VECTOR3I, TYPE_VECTOR4, TYPE_VECTOR4I:
			return assert_vector(current, false)
		TYPE_DICTIONARY:
			return assert_dict(current)
		TYPE_ARRAY, TYPE_PACKED_BYTE_ARRAY, TYPE_PACKED_INT32_ARRAY, TYPE_PACKED_INT64_ARRAY,\
		TYPE_PACKED_FLOAT32_ARRAY, TYPE_PACKED_FLOAT64_ARRAY, TYPE_PACKED_STRING_ARRAY,\
		TYPE_PACKED_VECTOR2_ARRAY, TYPE_PACKED_VECTOR3_ARRAY, TYPE_PACKED_COLOR_ARRAY:
			return assert_array(current, false)
		TYPE_OBJECT, TYPE_NIL:
			return assert_object(current)
		_:
			return __gdunit_assert().new(current)


## An assertion tool to verify boolean values.
func assert_bool(current :Variant) -> GdUnitBoolAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitBoolAssertImpl.gd").new(current)


## An assertion tool to verify String values.
func assert_str(current :Variant) -> GdUnitStringAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitStringAssertImpl.gd").new(current)


## An assertion tool to verify integer values.
func assert_int(current :Variant) -> GdUnitIntAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitIntAssertImpl.gd").new(current)


## An assertion tool to verify float values.
func assert_float(current :Variant) -> GdUnitFloatAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFloatAssertImpl.gd").new(current)


## An assertion tool to verify Vector values.[br]
## This assertion supports all vector types.[br]
## Usage:
##     [codeblock]
##		assert_vector(Vector2(1.2, 1.000001)).is_equal(Vector2(1.2, 1.000001))
##     [/codeblock]
func assert_vector(current :Variant, type_check := true) -> GdUnitVectorAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitVectorAssertImpl.gd").new(current, type_check)


## An assertion tool to verify arrays.
func assert_array(current :Variant, type_check := true) -> GdUnitArrayAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitArrayAssertImpl.gd").new(current, type_check)


## An assertion tool to verify dictionaries.
func assert_dict(current :Variant) -> GdUnitDictionaryAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitDictionaryAssertImpl.gd").new(current)


## An assertion tool to verify FileAccess.
func assert_file(current :Variant) -> GdUnitFileAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFileAssertImpl.gd").new(current)


## An assertion tool to verify Objects.
func assert_object(current :Variant) -> GdUnitObjectAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitObjectAssertImpl.gd").new(current)


func assert_result(current :Variant) -> GdUnitResultAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitResultAssertImpl.gd").new(current)


## An assertion tool that waits until a certain time for an expected function return value
func assert_func(instance :Object, func_name :String, args := Array()) -> GdUnitFuncAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFuncAssertImpl.gd").new(instance, func_name, args)


## An Assertion Tool to verify for emitted signals until a certain time.
func assert_signal(instance :Object) -> GdUnitSignalAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitSignalAssertImpl.gd").new(instance)


## An assertion tool to test for failing assertions.[br]
## This assert is only designed for internal use to verify failing asserts working as expected.[br]
## Usage:
##     [codeblock]
##		assert_failure(func(): assert_bool(true).is_not_equal(true)) \
##		    .has_message("Expecting:\n 'true'\n not equal to\n 'true'")
##     [/codeblock]
func assert_failure(assertion :Callable) -> GdUnitFailureAssert:
	@warning_ignore("unsafe_method_access")
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFailureAssertImpl.gd").new().execute(assertion)


## An assertion tool to test for failing assertions.[br]
## This assert is only designed for internal use to verify failing asserts working as expected.[br]
## Usage:
##     [codeblock]
##		await assert_failure_await(func(): assert_bool(true).is_not_equal(true)) \
##		    .has_message("Expecting:\n 'true'\n not equal to\n 'true'")
##     [/codeblock]
func assert_failure_await(assertion :Callable) -> GdUnitFailureAssert:
	@warning_ignore("unsafe_method_access")
	return await __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFailureAssertImpl.gd").new().execute_and_await(assertion)


## An assertion tool to verify for Godot errors.[br]
## You can use to verify for certain Godot erros like failing assertions, push_error, push_warn.[br]
## Usage:
##     [codeblock]
##		# tests no error was occured during execution the code
##		await assert_error(func (): return 0 )\
##		    .is_success()
##
##		# tests an push_error('test error') was occured during execution the code
##		await assert_error(func (): push_error('test error') )\
##		    .is_push_error('test error')
##     [/codeblock]
func assert_error(current :Callable) -> GdUnitGodotErrorAssert:
	return __lazy_load("res://addons/gdUnit4/src/asserts/GdUnitGodotErrorAssertImpl.gd").new(current)


func assert_not_yet_implemented() -> void:
	@warning_ignore("unsafe_method_access")
	__gdunit_assert().new(null).do_fail()


func fail(message :String) -> void:
	@warning_ignore("unsafe_method_access")
	__gdunit_assert().new(null).report_error(message)


# --- internal stuff do not override!!!
func ResourcePath() -> String:
	return get_script().resource_path
## A tuple implementation to hold two or many values
class_name GdUnitTuple
extends RefCounted

const NO_ARG :Variant = GdUnitConstants.NO_ARG

var __values :Array = Array()


func _init(arg0:Variant,
	arg1 :Variant=NO_ARG,
	arg2 :Variant=NO_ARG,
	arg3 :Variant=NO_ARG,
	arg4 :Variant=NO_ARG,
	arg5 :Variant=NO_ARG,
	arg6 :Variant=NO_ARG,
	arg7 :Variant=NO_ARG,
	arg8 :Variant=NO_ARG,
	arg9 :Variant=NO_ARG) -> void:
	__values = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], NO_ARG)


func values() -> Array:
	return __values


func _to_string() -> String:
	return "tuple(%s)" % str(__values)
## This is the base interface for value extraction
class_name GdUnitValueExtractor
extends RefCounted


## Extracts a value by given implementation
func extract_value(value :Variant) -> Variant:
	push_error("Uninplemented func 'extract_value'")
	return value
## An Assertion Tool to verify Vector values
class_name GdUnitVectorAssert
extends GdUnitAssert


## Verifies that the current value is equal to expected one.
@warning_ignore("unused_parameter")
func is_equal(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is not equal to expected one.
@warning_ignore("unused_parameter")
func is_not_equal(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current and expected value are approximately equal.
@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_equal_approx(expected :Variant, approx :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is less than the given one.
@warning_ignore("unused_parameter")
func is_less(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is less than or equal the given one.
@warning_ignore("unused_parameter")
func is_less_equal(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is greater than the given one.
@warning_ignore("unused_parameter")
func is_greater(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is greater than or equal the given one.
@warning_ignore("unused_parameter")
func is_greater_equal(expected :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is between the given boundaries (inclusive).
@warning_ignore("unused_parameter")
func is_between(from :Variant, to :Variant) -> GdUnitVectorAssert:
	return self


## Verifies that the current value is not between the given boundaries (inclusive).
@warning_ignore("unused_parameter")
func is_not_between(from :Variant, to :Variant) -> GdUnitVectorAssert:
	return self
# a value provider unsing a callback to get `next` value from a certain function
class_name CallBackValueProvider
extends ValueProvider

var _cb :Callable
var _args :Array


func _init(instance :Object, func_name :String, args :Array = Array(), force_error := true) -> void:
	_cb = Callable(instance, func_name);
	_args = args
	if force_error and not _cb.is_valid():
		push_error("Can't find function '%s' checked instance %s" % [func_name, instance])


func get_value() -> Variant:
	if not _cb.is_valid():
		return null
	if _args.is_empty():
		return await _cb.call()
	return await _cb.callv(_args)


func dispose() -> void:
	_cb = Callable()
# default value provider, simple returns the initial value
class_name DefaultValueProvider
extends ValueProvider

var _value: Variant


func _init(value: Variant) -> void:
	_value = value


func get_value() -> Variant:
	return _value
class_name GdAssertMessages
extends Resource

const WARN_COLOR = "#EFF883"
const ERROR_COLOR = "#CD5C5C"
const VALUE_COLOR = "#1E90FF"
const SUB_COLOR :=  Color(1, 0, 0, .3)
const ADD_COLOR :=  Color(0, 1, 0, .3)


static func format_dict(value :Variant) -> String:
	if not value is Dictionary:
		return str(value)

	var dict_value: Dictionary = value
	if dict_value.is_empty():
		return "{ }"
	var as_rows := var_to_str(value).split("\n")
	for index in range( 1, as_rows.size()-1):
		as_rows[index] = "	" + as_rows[index]
	as_rows[-1] = "  " + as_rows[-1]
	return "\n".join(as_rows)


# improved version of InputEvent as text
static func input_event_as_text(event :InputEvent) -> String:
	var text := ""
	if event is InputEventKey:
		var key_event := event as InputEventKey
		text += "InputEventKey : key='%s', pressed=%s, keycode=%d, physical_keycode=%s" % [
					event.as_text(), key_event.pressed, key_event.keycode, key_event.physical_keycode]
	else:
		text += event.as_text()
	if event is InputEventMouse:
		var mouse_event := event as InputEventMouse
		text += ", global_position %s" % mouse_event.global_position
	if event is InputEventWithModifiers:
		var mouse_event := event as InputEventWithModifiers
		text += ", shift=%s, alt=%s, control=%s, meta=%s, command=%s" % [
					mouse_event.shift_pressed,
					mouse_event.alt_pressed,
					mouse_event.ctrl_pressed,
					mouse_event.meta_pressed,
					mouse_event.command_or_control_autoremap]
	return text


static func _colored_string_div(characters :String) -> String:
	return colored_array_div(characters.to_utf8_buffer())


static func colored_array_div(characters :PackedByteArray) -> String:
	if characters.is_empty():
		return "<empty>"
	var result := PackedByteArray()
	var index := 0
	var missing_chars := PackedByteArray()
	var additional_chars := PackedByteArray()

	while index < characters.size():
		var character := characters[index]
		match character:
			GdDiffTool.DIV_ADD:
				index += 1
				@warning_ignore("return_value_discarded")
				additional_chars.append(characters[index])
			GdDiffTool.DIV_SUB:
				index += 1
				@warning_ignore("return_value_discarded")
				missing_chars.append(characters[index])
			_:
				if not missing_chars.is_empty():
					result.append_array(format_chars(missing_chars, SUB_COLOR))
					missing_chars = PackedByteArray()
				if not additional_chars.is_empty():
					result.append_array(format_chars(additional_chars, ADD_COLOR))
					additional_chars = PackedByteArray()
				@warning_ignore("return_value_discarded")
				result.append(character)
		index += 1

	result.append_array(format_chars(missing_chars, SUB_COLOR))
	result.append_array(format_chars(additional_chars, ADD_COLOR))
	return result.get_string_from_utf8()


static func _typed_value(value :Variant) -> String:
	return GdDefaultValueDecoder.decode(value)


static func _warning(error :String) -> String:
	return "[color=%s]%s[/color]" % [WARN_COLOR, error]


static func _error(error :String) -> String:
	return "[color=%s]%s[/color]" % [ERROR_COLOR, error]


static func _nerror(number :Variant) -> String:
	match typeof(number):
		TYPE_INT:
			return "[color=%s]%d[/color]" % [ERROR_COLOR, number]
		TYPE_FLOAT:
			return "[color=%s]%f[/color]" % [ERROR_COLOR, number]
		_:
			return "[color=%s]%s[/color]" % [ERROR_COLOR, str(number)]


static func _colored_value(value :Variant) -> String:
	match typeof(value):
		TYPE_STRING, TYPE_STRING_NAME:
			return "'[color=%s]%s[/color]'" % [VALUE_COLOR, _colored_string_div(str(value))]
		TYPE_INT:
			return "'[color=%s]%d[/color]'" % [VALUE_COLOR, value]
		TYPE_FLOAT:
			return "'[color=%s]%s[/color]'" % [VALUE_COLOR, _typed_value(value)]
		TYPE_COLOR:
			return "'[color=%s]%s[/color]'" % [VALUE_COLOR, _typed_value(value)]
		TYPE_OBJECT:
			if value == null:
				return "'[color=%s]<null>[/color]'" % [VALUE_COLOR]
			if value is InputEvent:
				var ie: InputEvent = value
				return "[color=%s]<%s>[/color]" % [VALUE_COLOR, input_event_as_text(ie)]
			var obj_value: Object = value
			if obj_value.has_method("_to_string"):
				return "[color=%s]<%s>[/color]" % [VALUE_COLOR, str(value)]
			return "[color=%s]<%s>[/color]" % [VALUE_COLOR, obj_value.get_class()]
		TYPE_DICTIONARY:
			return "'[color=%s]%s[/color]'" % [VALUE_COLOR, format_dict(value)]
		_:
			if GdArrayTools.is_array_type(value):
				return "'[color=%s]%s[/color]'" % [VALUE_COLOR, _typed_value(value)]
			return "'[color=%s]%s[/color]'" % [VALUE_COLOR, value]



static func _index_report_as_table(index_reports :Array) -> String:
	var table := "[table=3]$cells[/table]"
	var header := "[cell][right][b]$text[/b][/right]\t[/cell]"
	var cell := "[cell][right]$text[/right]\t[/cell]"
	var cells := header.replace("$text", "Index") + header.replace("$text", "Current") + header.replace("$text", "Expected")
	for report :Variant in index_reports:
		var index :String = str(report["index"])
		var current :String = str(report["current"])
		var expected :String = str(report["expected"])
		cells += cell.replace("$text", index) + cell.replace("$text", current) + cell.replace("$text", expected)
	return table.replace("$cells", cells)


static func orphan_detected_on_suite_setup(count :int) -> String:
	return "%s\n Detected <%d> orphan nodes during test suite setup stage! [b]Check before() and after()![/b]" % [
		_warning("WARNING:"), count]


static func orphan_detected_on_test_setup(count :int) -> String:
	return "%s\n Detected <%d> orphan nodes during test setup! [b]Check before_test() and after_test()![/b]" % [
		_warning("WARNING:"), count]


static func orphan_detected_on_test(count :int) -> String:
	return "%s\n Detected <%d> orphan nodes during test execution!" % [
		_warning("WARNING:"), count]


static func fuzzer_interuped(iterations: int, error: String) -> String:
	return "%s %s %s\n %s" % [
		_error("Found an error after"),
		_colored_value(iterations + 1),
		_error("test iterations"),
		error]


static func test_timeout(timeout :int) -> String:
	return "%s\n %s" % [_error("Timeout !"), _colored_value("Test timed out after %s" %  LocalTime.elapsed(timeout))]


# gdlint:disable = mixed-tabs-and-spaces
static func test_suite_skipped(hint :String, skip_count :int) -> String:
	return """
		%s
		  Skipped %s tests
		  Reason: %s
		""".dedent().trim_prefix("\n")\
		% [_error("The Entire test-suite is skipped!"), _colored_value(skip_count), _colored_value(hint)]


static func test_skipped(hint :String) -> String:
	return """
		%s
		  Reason: %s
		""".dedent().trim_prefix("\n")\
		% [_error("This test is skipped!"), _colored_value(hint)]


static func error_not_implemented() -> String:
	return _error("Test not implemented!")


static func error_is_null(current :Variant) -> String:
	return "%s %s but was %s" % [_error("Expecting:"), _colored_value(null), _colored_value(current)]


static func error_is_not_null() -> String:
	return "%s %s" % [_error("Expecting: not to be"), _colored_value(null)]


static func error_equal(current :Variant, expected :Variant, index_reports :Array = []) -> String:
	var report := """
		%s
		 %s
		 but was
		 %s""".dedent().trim_prefix("\n") % [_error("Expecting:"), _colored_value(expected), _colored_value(current)]
	if not index_reports.is_empty():
		report += "\n\n%s\n%s" % [_error("Differences found:"), _index_report_as_table(index_reports)]
	return report


static func error_not_equal(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n not equal to\n %s" % [_error("Expecting:"), _colored_value(expected), _colored_value(current)]


static func error_not_equal_case_insensetiv(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n not equal to (case insensitiv)\n %s" % [
			_error("Expecting:"), _colored_value(expected), _colored_value(current)]


static func error_is_empty(current :Variant) -> String:
	return "%s\n must be empty but was\n %s" % [_error("Expecting:"), _colored_value(current)]


static func error_is_not_empty() -> String:
	return "%s\n must not be empty" % [_error("Expecting:")]


static func error_is_same(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n to refer to the same object\n %s" % [_error("Expecting:"), _colored_value(expected), _colored_value(current)]


@warning_ignore("unused_parameter")
static func error_not_same(_current :Variant, expected :Variant) -> String:
	return "%s\n %s" % [_error("Expecting not same:"), _colored_value(expected)]


static func error_not_same_error(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n but was\n %s" % [_error("Expecting error message:"), _colored_value(expected), _colored_value(current)]


static func error_is_instanceof(current: GdUnitResult, expected :GdUnitResult) -> String:
	return "%s\n %s\n But it was %s" % [_error("Expected instance of:"),\
		_colored_value(expected.or_else(null)), _colored_value(current.or_else(null))]


# -- Boolean Assert specific messages -----------------------------------------------------
static func error_is_true(current :Variant) -> String:
	return "%s %s but is %s" % [_error("Expecting:"), _colored_value(true), _colored_value(current)]


static func error_is_false(current :Variant) -> String:
	return "%s %s but is %s" % [_error("Expecting:"), _colored_value(false), _colored_value(current)]


# - Integer/Float Assert specific messages -----------------------------------------------------

static func error_is_even(current :Variant) -> String:
	return "%s\n %s must be even" % [_error("Expecting:"), _colored_value(current)]


static func error_is_odd(current :Variant) -> String:
	return "%s\n %s must be odd" % [_error("Expecting:"), _colored_value(current)]


static func error_is_negative(current :Variant) -> String:
	return "%s\n %s be negative" % [_error("Expecting:"), _colored_value(current)]


static func error_is_not_negative(current :Variant) -> String:
	return "%s\n %s be not negative" % [_error("Expecting:"), _colored_value(current)]


static func error_is_zero(current :Variant) -> String:
	return "%s\n equal to 0 but is %s" % [_error("Expecting:"), _colored_value(current)]


static func error_is_not_zero() -> String:
	return "%s\n not equal to 0" % [_error("Expecting:")]


static func error_is_wrong_type(current_type :Variant.Type, expected_type :Variant.Type) -> String:
	return "%s\n Expecting type %s but is %s" % [
		_error("Unexpected type comparison:"),
		_colored_value(GdObjects.type_as_string(current_type)),
		_colored_value(GdObjects.type_as_string(expected_type))]


static func error_is_value(operation :int, current :Variant, expected :Variant, expected2 :Variant = null) -> String:
	match operation:
		Comparator.EQUAL:
			return "%s\n %s but was '%s'" % [_error("Expecting:"), _colored_value(expected), _nerror(current)]
		Comparator.LESS_THAN:
			return "%s\n %s but was '%s'" % [_error("Expecting to be less than:"), _colored_value(expected), _nerror(current)]
		Comparator.LESS_EQUAL:
			return "%s\n %s but was '%s'" % [_error("Expecting to be less than or equal:"), _colored_value(expected), _nerror(current)]
		Comparator.GREATER_THAN:
			return "%s\n %s but was '%s'" % [_error("Expecting to be greater than:"), _colored_value(expected), _nerror(current)]
		Comparator.GREATER_EQUAL:
			return "%s\n %s but was '%s'" % [_error("Expecting to be greater than or equal:"), _colored_value(expected), _nerror(current)]
		Comparator.BETWEEN_EQUAL:
			return "%s\n %s\n in range between\n %s <> %s" % [
					_error("Expecting:"), _colored_value(current), _colored_value(expected), _colored_value(expected2)]
		Comparator.NOT_BETWEEN_EQUAL:
			return "%s\n %s\n not in range between\n %s <> %s" % [
					_error("Expecting:"), _colored_value(current), _colored_value(expected), _colored_value(expected2)]
	return "TODO create expected message"


static func error_is_in(current :Variant, expected :Array) -> String:
	return "%s\n %s\n is in\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(str(expected))]


static func error_is_not_in(current :Variant, expected :Array) -> String:
	return "%s\n %s\n is not in\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(str(expected))]


# - StringAssert ---------------------------------------------------------------------------------
static func error_equal_ignoring_case(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n but was\n %s (ignoring case)" % [_error("Expecting:"), _colored_value(expected), _colored_value(current)]


static func error_contains(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n do contains\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_not_contains(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n not do contain\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_contains_ignoring_case(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n contains\n %s\n (ignoring case)" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_not_contains_ignoring_case(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n not do contains\n %s\n (ignoring case)" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_starts_with(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n to start with\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_ends_with(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n to end with\n %s" % [_error("Expecting:"), _colored_value(current), _colored_value(expected)]


static func error_has_length(current :Variant, expected: int, compare_operator :int) -> String:
	@warning_ignore("unsafe_method_access")
	var current_length :Variant = current.length() if current != null else null
	match compare_operator:
		Comparator.EQUAL:
			return "%s\n %s but was '%s' in\n %s" % [
					_error("Expecting size:"), _colored_value(expected), _nerror(current_length), _colored_value(current)]
		Comparator.LESS_THAN:
			return "%s\n %s but was '%s' in\n %s" % [
					_error("Expecting size to be less than:"), _colored_value(expected), _nerror(current_length), _colored_value(current)]
		Comparator.LESS_EQUAL:
			return "%s\n %s but was '%s' in\n %s" % [
					_error("Expecting size to be less than or equal:"), _colored_value(expected),
					_nerror(current_length), _colored_value(current)]
		Comparator.GREATER_THAN:
			return "%s\n %s but was '%s' in\n %s" % [
					_error("Expecting size to be greater than:"), _colored_value(expected),
					_nerror(current_length), _colored_value(current)]
		Comparator.GREATER_EQUAL:
			return "%s\n %s but was '%s' in\n %s" % [
					_error("Expecting size to be greater than or equal:"), _colored_value(expected),
					_nerror(current_length), _colored_value(current)]
	return "TODO create expected message"


# - ArrayAssert specific messgaes ---------------------------------------------------

static func error_arr_contains(current: Variant, expected: Variant, not_expect: Variant, not_found: Variant, by_reference: bool) -> String:
	var failure_message := "Expecting contains SAME elements:" if by_reference else "Expecting contains elements:"
	var error := "%s\n %s\n do contains (in any order)\n %s" % [
					_error(failure_message), _colored_value(current), _colored_value(expected)]
	if not is_empty(not_expect):
		error += "\nbut some elements where not expected:\n %s" % _colored_value(not_expect)
	if not is_empty(not_found):
		var prefix := "but" if is_empty(not_expect) else "and"
		error += "\n%s could not find elements:\n %s" % [prefix, _colored_value(not_found)]
	return error


static func error_arr_contains_exactly(
	current: Variant,
	expected: Variant,
	not_expect: Variant,
	not_found: Variant, compare_mode: GdObjects.COMPARE_MODE) -> String:
	var failure_message := (
		"Expecting contains exactly elements:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST
		else "Expecting contains SAME exactly elements:"
	)
	if is_empty(not_expect) and is_empty(not_found):
		var arr_current: Array = current
		var arr_expected: Array = expected
		var diff := _find_first_diff(arr_current, arr_expected)
		return "%s\n %s\n do contains (in same order)\n %s\n but has different order %s"  % [
					_error(failure_message), _colored_value(current), _colored_value(expected), diff]

	var error := "%s\n %s\n do contains (in same order)\n %s" % [
					_error(failure_message), _colored_value(current), _colored_value(expected)]
	if not is_empty(not_expect):
		error += "\nbut some elements where not expected:\n %s" % _colored_value(not_expect)
	if not is_empty(not_found):
		var prefix := "but" if is_empty(not_expect) else "and"
		error += "\n%s could not find elements:\n %s" % [prefix, _colored_value(not_found)]
	return error


static func error_arr_contains_exactly_in_any_order(
	current: Variant,
	expected: Variant,
	not_expect: Variant,
	not_found: Variant,
	compare_mode: GdObjects.COMPARE_MODE) -> String:

	var failure_message := (
		"Expecting contains exactly elements:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST
		else "Expecting contains SAME exactly elements:"
	)
	var error := "%s\n %s\n do contains exactly (in any order)\n %s" % [
					_error(failure_message), _colored_value(current), _colored_value(expected)]
	if not is_empty(not_expect):
		error += "\nbut some elements where not expected:\n %s" % _colored_value(not_expect)
	if not is_empty(not_found):
		var prefix := "but" if is_empty(not_expect) else "and"
		error += "\n%s could not find elements:\n %s" % [prefix, _colored_value(not_found)]
	return error


static func error_arr_not_contains(current: Variant, expected: Variant, found: Variant, compare_mode: GdObjects.COMPARE_MODE) -> String:
	var failure_message := "Expecting:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST else "Expecting SAME:"
	var error := "%s\n %s\n do not contains\n %s" % [
					_error(failure_message), _colored_value(current), _colored_value(expected)]
	if not is_empty(found):
		error += "\n but found elements:\n %s" % _colored_value(found)
	return error


# - DictionaryAssert specific messages ----------------------------------------------
static func error_contains_keys(current :Array, expected :Array, keys_not_found :Array, compare_mode :GdObjects.COMPARE_MODE) -> String:
	var failure := (
		"Expecting contains keys:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST
		else "Expecting contains SAME keys:"
	)
	return "%s\n %s\n to contains:\n %s\n but can't find key's:\n %s" % [
			_error(failure), _colored_value(current), _colored_value(expected), _colored_value(keys_not_found)]


static func error_not_contains_keys(current :Array, expected :Array, keys_not_found :Array, compare_mode :GdObjects.COMPARE_MODE) -> String:
	var failure := (
		"Expecting NOT contains keys:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST
		else "Expecting NOT contains SAME keys"
	)
	return "%s\n %s\n do not contains:\n %s\n but contains key's:\n %s" % [
			_error(failure), _colored_value(current), _colored_value(expected), _colored_value(keys_not_found)]


static func error_contains_key_value(key :Variant, value :Variant, current_value :Variant, compare_mode :GdObjects.COMPARE_MODE) -> String:
	var failure := (
		"Expecting contains key and value:" if compare_mode == GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST
		else "Expecting contains SAME key and value:"
	)
	return "%s\n %s : %s\n but contains\n %s : %s" % [
			_error(failure), _colored_value(key), _colored_value(value), _colored_value(key), _colored_value(current_value)]


# - ResultAssert specific errors ----------------------------------------------------
static func error_result_is_empty(current :GdUnitResult) -> String:
	return _result_error_message(current, GdUnitResult.EMPTY)


static func error_result_is_success(current :GdUnitResult) -> String:
	return _result_error_message(current, GdUnitResult.SUCCESS)


static func error_result_is_warning(current :GdUnitResult) -> String:
	return _result_error_message(current, GdUnitResult.WARN)


static func error_result_is_error(current :GdUnitResult) -> String:
	return _result_error_message(current, GdUnitResult.ERROR)


static func error_result_has_message(current :String, expected :String) -> String:
	return "%s\n %s\n but was\n %s." % [_error("Expecting:"), _colored_value(expected), _colored_value(current)]


static func error_result_has_message_on_success(expected :String) -> String:
	return "%s\n %s\n but the GdUnitResult is a success." % [_error("Expecting:"), _colored_value(expected)]


static func error_result_is_value(current :Variant, expected :Variant) -> String:
	return "%s\n %s\n but was\n %s." % [_error("Expecting to contain same value:"), _colored_value(expected), _colored_value(current)]


static func _result_error_message(current :GdUnitResult, expected_type :int) -> String:
	if current == null:
		return _error("Expecting the result must be a %s but was <null>." % result_type(expected_type))
	if current.is_success():
		return _error("Expecting the result must be a %s but was SUCCESS." % result_type(expected_type))
	var error := "Expecting the result must be a %s but was %s:" % [result_type(expected_type), result_type(current._state)]
	return "%s\n %s" % [_error(error), _colored_value(result_message(current))]


static func error_interrupted(func_name :String, expected :Variant, elapsed :String) -> String:
	func_name = humanized(func_name)
	if expected == null:
		return "%s %s but timed out after %s" % [_error("Expected:"), func_name, elapsed]
	return "%s %s %s but timed out after %s" % [_error("Expected:"), func_name, _colored_value(expected), elapsed]


static func error_wait_signal(signal_name :String, args :Array, elapsed :String) -> String:
	if args.is_empty():
		return "%s %s but timed out after %s" % [
				_error("Expecting emit signal:"), _colored_value(signal_name + "()"), elapsed]
	return "%s %s but timed out after %s" % [
			_error("Expecting emit signal:"), _colored_value(signal_name + "(" + str(args) + ")"), elapsed]


static func error_signal_emitted(signal_name :String, args :Array, elapsed :String) -> String:
	if args.is_empty():
		return "%s %s but is emitted after %s" % [
				_error("Expecting do not emit signal:"), _colored_value(signal_name + "()"), elapsed]
	return "%s %s but is emitted after %s" % [
			_error("Expecting do not emit signal:"), _colored_value(signal_name + "(" + str(args) + ")"), elapsed]


static func error_await_signal_on_invalid_instance(source :Variant, signal_name :String, args :Array) -> String:
	return "%s\n await_signal_on(%s, %s, %s)" % [
			_error("Invalid source! Can't await on signal:"), _colored_value(source), signal_name, args]


static func result_type(type :int) -> String:
	match type:
		GdUnitResult.SUCCESS: return "SUCCESS"
		GdUnitResult.WARN: return "WARNING"
		GdUnitResult.ERROR: return "ERROR"
		GdUnitResult.EMPTY: return "EMPTY"
	return "UNKNOWN"


static func result_message(result :GdUnitResult) -> String:
	match result._state:
		GdUnitResult.SUCCESS: return ""
		GdUnitResult.WARN: return result.warn_message()
		GdUnitResult.ERROR: return result.error_message()
		GdUnitResult.EMPTY: return ""
	return "UNKNOWN"
# -----------------------------------------------------------------------------------

# - Spy|Mock specific errors ----------------------------------------------------
static func error_no_more_interactions(summary :Dictionary) -> String:
	var interactions := PackedStringArray()
	for args :Array in summary.keys():
		var times :int = summary[args]
		@warning_ignore("return_value_discarded")
		interactions.append(_format_arguments(args, times))
	return "%s\n%s\n%s" % [_error("Expecting no more interactions!"), _error("But found interactions on:"), "\n".join(interactions)]


static func error_validate_interactions(current_interactions: Dictionary, expected_interactions: Dictionary) -> String:
	var collected_interactions := PackedStringArray()
	for args: Array in current_interactions.keys():
		var times: int = current_interactions[args]
		@warning_ignore("return_value_discarded")
		collected_interactions.append(_format_arguments(args, times))

	var arguments: Array = expected_interactions.keys()[0]
	var interactions: int = expected_interactions.values()[0]
	var expected_interaction := _format_arguments(arguments, interactions)
	return "%s\n%s\n%s\n%s" % [
			_error("Expecting interaction on:"), expected_interaction, _error("But found interactions on:"), "\n".join(collected_interactions)]


static func _format_arguments(args :Array, times :int) -> String:
	var fname :String = args[0]
	var fargs := args.slice(1) as Array
	var typed_args := _to_typed_args(fargs)
	var fsignature := _colored_value("%s(%s)" % [fname, ", ".join(typed_args)])
	return "	%s	%d time's" % [fsignature, times]


static func _to_typed_args(args :Array) -> PackedStringArray:
	var typed := PackedStringArray()
	for arg :Variant in args:
		@warning_ignore("return_value_discarded")
		typed.append(_format_arg(arg) + " :" + GdObjects.type_as_string(typeof(arg)))
	return typed


static func _format_arg(arg :Variant) -> String:
	if arg is InputEvent:
		var ie: InputEvent = arg
		return input_event_as_text(ie)
	return str(arg)


static func _find_first_diff(left :Array, right :Array) -> String:
	for index in left.size():
		var l :Variant = left[index]
		var r :Variant = "<no entry>" if index >= right.size() else right[index]
		if not GdObjects.equals(l, r):
			return "at position %s\n '%s' vs '%s'" % [_colored_value(index), _typed_value(l), _typed_value(r)]
	return ""


static func error_has_size(current :Variant, expected: int) -> String:
	@warning_ignore("unsafe_method_access")
	var current_size :Variant = null if current == null else current.size()
	return "%s\n %s\n but was\n %s" % [_error("Expecting size:"), _colored_value(expected), _colored_value(current_size)]


static func error_contains_exactly(current: Array, expected: Array) -> String:
	return "%s\n %s\n but was\n %s" % [_error("Expecting exactly equal:"), _colored_value(expected), _colored_value(current)]


static func format_chars(characters :PackedByteArray, type :Color) -> PackedByteArray:
	if characters.size() == 0:# or characters[0] == 10:
		return characters
	var result := PackedByteArray()
	var message := "[bgcolor=#%s][color=with]%s[/color][/bgcolor]" % [
					type.to_html(), characters.get_string_from_utf8().replace("\n", "<LF>")]
	result.append_array(message.to_utf8_buffer())
	return result


static func format_invalid(value :String) -> String:
	return "[bgcolor=#%s][color=with]%s[/color][/bgcolor]" % [SUB_COLOR.to_html(), value]


static func humanized(value :String) -> String:
	return value.replace("_", " ")


static func build_failure_message(failure :String, additional_failure_message: String, custom_failure_message: String) -> String:
	var message := failure if custom_failure_message.is_empty() else custom_failure_message
	if additional_failure_message.is_empty():
		return message
	return """
		%s
		[color=LIME_GREEN][b]Additional info:[/b][/color]
		 %s""".dedent().trim_prefix("\n") % [message, additional_failure_message]


static func is_empty(value: Variant) -> bool:
	var arry_value: Array = value
	return arry_value != null and arry_value.is_empty()
class_name GdAssertReports
extends RefCounted

const LAST_ERROR = "last_assert_error_message"
const LAST_ERROR_LINE = "last_assert_error_line"


static func report_success() -> void:
	GdUnitSignals.instance().gdunit_set_test_failed.emit(false)
	GdAssertReports.set_last_error_line_number(-1)
	Engine.remove_meta(LAST_ERROR)


static func report_warning(message :String, line_number :int) -> void:
	GdUnitSignals.instance().gdunit_set_test_failed.emit(false)
	send_report(GdUnitReport.new().create(GdUnitReport.WARN, line_number, message))


static func report_error(message:String, line_number :int) -> void:
	GdUnitSignals.instance().gdunit_set_test_failed.emit(true)
	GdAssertReports.set_last_error_line_number(line_number)
	Engine.set_meta(LAST_ERROR, message)
	# if we expect to fail we handle as success test
	if _do_expect_assert_failing():
		return
	send_report(GdUnitReport.new().create(GdUnitReport.FAILURE, line_number, message))


static func reset_last_error_line_number() -> void:
	Engine.remove_meta(LAST_ERROR_LINE)


static func set_last_error_line_number(line_number :int) -> void:
	Engine.set_meta(LAST_ERROR_LINE, line_number)


static func get_last_error_line_number() -> int:
	if Engine.has_meta(LAST_ERROR_LINE):
		return Engine.get_meta(LAST_ERROR_LINE)
	return -1


static func _do_expect_assert_failing() -> bool:
	if Engine.has_meta(GdUnitConstants.EXPECT_ASSERT_REPORT_FAILURES):
		return Engine.get_meta(GdUnitConstants.EXPECT_ASSERT_REPORT_FAILURES)
	return false


static func current_failure() -> String:
	return Engine.get_meta(LAST_ERROR)


static func send_report(report :GdUnitReport) -> void:
	GdUnitThreadManager.get_current_context().get_execution_context().add_report(report)
class_name GdUnitArrayAssertImpl
extends GdUnitArrayAssert


var _base: GdUnitAssertImpl
var _current_value_provider: ValueProvider
var _type_check: bool


func _init(current: Variant, type_check := true) -> void:
	_type_check = type_check
	_current_value_provider = DefaultValueProvider.new(current)
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not _validate_value_type(current):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitArrayAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event: int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func report_success() -> GdUnitArrayAssert:
	_base.report_success()
	return self


func report_error(error: String) -> GdUnitArrayAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message: String) -> GdUnitArrayAssert:
	_base.override_failure_message(message)
	return self


func append_failure_message(message: String) -> GdUnitArrayAssert:
	_base.append_failure_message(message)
	return self


func _validate_value_type(value: Variant) -> bool:
	return value == null or GdArrayTools.is_array_type(value)


func get_current_value() -> Variant:
	return _current_value_provider.get_value()


func max_length(left: Variant, right: Variant) -> int:
	var ls := str(left).length()
	var rs := str(right).length()
	return rs if ls < rs else ls


# gdlint: disable=function-name
func _toPackedStringArray(value: Variant) -> PackedStringArray:
	if GdArrayTools.is_array_type(value):
		@warning_ignore("unsafe_cast")
		return PackedStringArray(value as Array)
	return PackedStringArray([str(value)])


func _array_equals_div(current: Variant, expected: Variant, case_sensitive: bool = false) -> Array[Array]:
	var current_value := _toPackedStringArray(current)
	var expected_value := _toPackedStringArray(expected)
	var index_report := Array()
	for index in current_value.size():
		var c := current_value[index]
		if index < expected_value.size():
			var e := expected_value[index]
			if not GdObjects.equals(c, e, case_sensitive):
				var length := max_length(c, e)
				current_value[index] = GdAssertMessages.format_invalid(c.lpad(length))
				expected_value[index] = e.lpad(length)
				index_report.push_back({"index": index, "current": c, "expected": e})
		else:
			current_value[index] = GdAssertMessages.format_invalid(c)
			index_report.push_back({"index": index, "current": c, "expected": "<N/A>"})

	for index in range(current_value.size(), expected_value.size()):
		var value := expected_value[index]
		expected_value[index] = GdAssertMessages.format_invalid(value)
		index_report.push_back({"index": index, "current": "<N/A>", "expected": value})
	return [current_value, expected_value, index_report]


func _array_div(compare_mode: GdObjects.COMPARE_MODE, left: Array[Variant], right: Array[Variant], _same_order := false) -> Array[Variant]:
	var not_expect := left.duplicate(true)
	var not_found := right.duplicate(true)
	for index_c in left.size():
		var c: Variant = left[index_c]
		for index_e in right.size():
			var e: Variant = right[index_e]
			if GdObjects.equals(c, e, false, compare_mode):
				GdArrayTools.erase_value(not_expect, e)
				GdArrayTools.erase_value(not_found, c)
				break
	return [not_expect, not_found]


func _contains(expected: Variant, compare_mode: GdObjects.COMPARE_MODE) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var by_reference := compare_mode == GdObjects.COMPARE_MODE.OBJECT_REFERENCE
	var current_value: Variant = get_current_value()
	if current_value == null:
		return report_error(GdAssertMessages.error_arr_contains(current_value, expected, [], expected, by_reference))
	@warning_ignore("unsafe_cast")
	var diffs := _array_div(compare_mode, current_value as Array[Variant], expected as Array[Variant])
	#var not_expect := diffs[0] as Array
	var not_found: Array = diffs[1]
	if not not_found.is_empty():
		return report_error(GdAssertMessages.error_arr_contains(current_value, expected, [], not_found, by_reference))
	return report_success()


func _contains_exactly(expected: Variant, compare_mode: GdObjects.COMPARE_MODE) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if current_value == null:
		return report_error(GdAssertMessages.error_arr_contains_exactly(null, expected, [], expected, compare_mode))
	# has same content in same order
	if _is_equal(current_value, expected, false, compare_mode):
		return report_success()
	# check has same elements but in different order
	if _is_equals_sorted(current_value, expected, false, compare_mode):
		return report_error(GdAssertMessages.error_arr_contains_exactly(current_value, expected, [], [], compare_mode))
	# find the difference
	@warning_ignore("unsafe_cast")
	var diffs := _array_div(compare_mode,
		current_value as Array[Variant],
		expected as Array[Variant],
		GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)
	var not_expect: Array[Variant] = diffs[0]
	var not_found: Array[Variant] = diffs[1]
	return report_error(GdAssertMessages.error_arr_contains_exactly(current_value, expected, not_expect, not_found, compare_mode))


func _contains_exactly_in_any_order(expected: Variant, compare_mode: GdObjects.COMPARE_MODE) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if current_value == null:
		return report_error(GdAssertMessages.error_arr_contains_exactly_in_any_order(current_value, expected, [], expected, compare_mode))
	# find the difference
	@warning_ignore("unsafe_cast")
	var diffs := _array_div(compare_mode, current_value as Array[Variant], expected as Array[Variant], false)
	var not_expect: Array[Variant] = diffs[0]
	var not_found: Array[Variant] = diffs[1]
	if not_expect.is_empty() and not_found.is_empty():
		return report_success()
	return report_error(GdAssertMessages.error_arr_contains_exactly_in_any_order(current_value, expected, not_expect, not_found, compare_mode))


func _not_contains(expected: Variant, compare_mode: GdObjects.COMPARE_MODE) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if current_value == null:
		return report_error(GdAssertMessages.error_arr_contains_exactly_in_any_order(current_value, expected, [], expected, compare_mode))
	@warning_ignore("unsafe_cast")
	var diffs := _array_div(compare_mode, current_value as Array[Variant], expected as Array[Variant])
	var found: Array[Variant] = diffs[0]
	@warning_ignore("unsafe_cast")
	if found.size() == (current_value as Array).size():
		return report_success()
	@warning_ignore("unsafe_cast")
	var diffs2 := _array_div(compare_mode, expected as Array[Variant], diffs[1] as Array[Variant])
	return report_error(GdAssertMessages.error_arr_not_contains(current_value, expected, diffs2[0], compare_mode))


func is_null() -> GdUnitArrayAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitArrayAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


# Verifies that the current String is equal to the given one.
func is_equal(expected: Variant) -> GdUnitArrayAssert:
	if _type_check and not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if current_value == null and expected != null:
		return report_error(GdAssertMessages.error_equal(null, expected))
	if not _is_equal(current_value, expected):
		var diff := _array_equals_div(current_value, expected)
		var expected_as_list := GdArrayTools.as_string(diff[0], false)
		var current_as_list := GdArrayTools.as_string(diff[1], false)
		var index_report: Array = diff[2]
		return report_error(GdAssertMessages.error_equal(expected_as_list, current_as_list, index_report))
	return report_success()


# Verifies that the current Array is equal to the given one, ignoring case considerations.
func is_equal_ignoring_case(expected: Variant) -> GdUnitArrayAssert:
	if _type_check and not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if current_value == null and expected != null:
		@warning_ignore("unsafe_cast")
		return report_error(GdAssertMessages.error_equal(null, GdArrayTools.as_string(expected as Array)))
	if not _is_equal(current_value, expected, true):
		@warning_ignore("unsafe_cast")
		var diff := _array_equals_div(current_value as Array[Variant], expected as Array[Variant], true)
		var expected_as_list := GdArrayTools.as_string(diff[0])
		var current_as_list := GdArrayTools.as_string(diff[1])
		var index_report: Array = diff[2]
		return report_error(GdAssertMessages.error_equal(expected_as_list, current_as_list, index_report))
	return report_success()


func is_not_equal(expected: Variant) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if _is_equal(current_value, expected):
		return report_error(GdAssertMessages.error_not_equal(current_value, expected))
	return report_success()


func is_not_equal_ignoring_case(expected: Variant) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current_value: Variant = get_current_value()
	if _is_equal(current_value, expected, true):
		@warning_ignore("unsafe_cast")
		var c := GdArrayTools.as_string(current_value as Array)
		@warning_ignore("unsafe_cast")
		var e := GdArrayTools.as_string(expected as Array)
		return report_error(GdAssertMessages.error_not_equal_case_insensetiv(c, e))
	return report_success()


func is_empty() -> GdUnitArrayAssert:
	var current_value: Variant = get_current_value()
	@warning_ignore("unsafe_cast")
	if current_value == null or (current_value as Array).size() > 0:
		return report_error(GdAssertMessages.error_is_empty(current_value))
	return report_success()


func is_not_empty() -> GdUnitArrayAssert:
	var current_value: Variant = get_current_value()
	@warning_ignore("unsafe_cast")
	if current_value != null and (current_value as Array).size() == 0:
		return report_error(GdAssertMessages.error_is_not_empty())
	return report_success()


@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_same(expected: Variant) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current: Variant = get_current_value()
	if not is_same(current, expected):
		@warning_ignore("return_value_discarded")
		report_error(GdAssertMessages.error_is_same(current, expected))
	return self


func is_not_same(expected: Variant) -> GdUnitArrayAssert:
	if not _validate_value_type(expected):
		return report_error("ERROR: expected value: <%s>\n is not a Array Type!" % GdObjects.typeof_as_string(expected))
	var current: Variant = get_current_value()
	if is_same(current, expected):
		@warning_ignore("return_value_discarded")
		report_error(GdAssertMessages.error_not_same(current, expected))
	return self


func has_size(expected: int) -> GdUnitArrayAssert:
	var current_value: Variant = get_current_value()
	@warning_ignore("unsafe_cast")
	if current_value == null or (current_value as Array).size() != expected:
		return report_error(GdAssertMessages.error_has_size(current_value, expected))
	return report_success()


func contains(expected: Variant) -> GdUnitArrayAssert:
	return _contains(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func contains_exactly(expected: Variant) -> GdUnitArrayAssert:
	return _contains_exactly(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func contains_exactly_in_any_order(expected: Variant) -> GdUnitArrayAssert:
	return _contains_exactly_in_any_order(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func contains_same(expected: Variant) -> GdUnitArrayAssert:
	return _contains(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func contains_same_exactly(expected: Variant) -> GdUnitArrayAssert:
	return _contains_exactly(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func contains_same_exactly_in_any_order(expected: Variant) -> GdUnitArrayAssert:
	return _contains_exactly_in_any_order(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func not_contains(expected: Variant) -> GdUnitArrayAssert:
	return _not_contains(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func not_contains_same(expected: Variant) -> GdUnitArrayAssert:
	return _not_contains(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func is_instanceof(expected: Variant) -> GdUnitAssert:
	@warning_ignore("unsafe_method_access")
	_base.is_instanceof(expected)
	return self


func extract(func_name: String, args := Array()) -> GdUnitArrayAssert:
	var extracted_elements := Array()

	var extractor := GdUnitFuncValueExtractor.new(func_name, args)
	var current: Variant = get_current_value()
	if current == null:
		_current_value_provider = DefaultValueProvider.new(null)
	else:
		for element: Variant in current:
			extracted_elements.append(extractor.extract_value(element))
		_current_value_provider = DefaultValueProvider.new(extracted_elements)
	return self


func extractv(
	extr0: GdUnitValueExtractor,
	extr1: GdUnitValueExtractor = null,
	extr2: GdUnitValueExtractor = null,
	extr3: GdUnitValueExtractor = null,
	extr4: GdUnitValueExtractor = null,
	extr5: GdUnitValueExtractor = null,
	extr6: GdUnitValueExtractor = null,
	extr7: GdUnitValueExtractor = null,
	extr8: GdUnitValueExtractor = null,
	extr9: GdUnitValueExtractor = null) -> GdUnitArrayAssert:
	var extractors: Variant = GdArrayTools.filter_value([extr0, extr1, extr2, extr3, extr4, extr5, extr6, extr7, extr8, extr9], null)
	var extracted_elements := Array()
	var current: Variant = get_current_value()
	if current == null:
		_current_value_provider = DefaultValueProvider.new(null)
	else:
		for element: Variant in current:
			var ev: Array[Variant] = [
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG,
				GdUnitTuple.NO_ARG
			]
			@warning_ignore("unsafe_cast")
			for index: int in (extractors as Array).size():
				var extractor: GdUnitValueExtractor = extractors[index]
				ev[index] = extractor.extract_value(element)
			@warning_ignore("unsafe_cast")
			if (extractors as Array).size() > 1:
				extracted_elements.append(GdUnitTuple.new(ev[0], ev[1], ev[2], ev[3], ev[4], ev[5], ev[6], ev[7], ev[8], ev[9]))
			else:
				extracted_elements.append(ev[0])
		_current_value_provider = DefaultValueProvider.new(extracted_elements)
	return self


@warning_ignore("incompatible_ternary")
func _is_equal(
	left: Variant,
	right: Variant,
	case_sensitive := false,
	compare_mode := GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST) -> bool:

	@warning_ignore("unsafe_cast")
	return GdObjects.equals(
		(left as Array) if GdArrayTools.is_array_type(left) else left,
		(right as Array) if GdArrayTools.is_array_type(right) else right,
		case_sensitive,
		compare_mode
	)


func _is_equals_sorted(
	left: Variant,
	right: Variant,
	case_sensitive := false,
	compare_mode := GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST) -> bool:

	@warning_ignore("unsafe_cast")
	return GdObjects.equals_sorted(
		left as Array,
		right as Array,
		case_sensitive,
		compare_mode)
class_name GdUnitAssertImpl
extends GdUnitAssert


var _current :Variant
var _current_failure_message :String = ""
var _custom_failure_message :String = ""
var _additional_failure_message: String = ""


func _init(current :Variant) -> void:
	_current = current
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	GdAssertReports.reset_last_error_line_number()



func failure_message() -> String:
	return _current_failure_message


func current_value() -> Variant:
	return _current


func report_success() -> GdUnitAssert:
	GdAssertReports.report_success()
	return self


func report_error(failure :String, failure_line_number: int = -1) -> GdUnitAssert:
	var line_number := failure_line_number if failure_line_number != -1 else GdUnitAssertions.get_line_number()
	GdAssertReports.set_last_error_line_number(line_number)
	_current_failure_message = GdAssertMessages.build_failure_message(failure, _additional_failure_message, _custom_failure_message)
	GdAssertReports.report_error(_current_failure_message, line_number)
	Engine.set_meta("GD_TEST_FAILURE", true)
	return self


func do_fail() -> GdUnitAssert:
	return report_error(GdAssertMessages.error_not_implemented())


func override_failure_message(message :String) -> GdUnitAssert:
	_custom_failure_message = message
	return self


func append_failure_message(message :String) -> GdUnitAssert:
	_additional_failure_message = message
	return self


func is_equal(expected :Variant) -> GdUnitAssert:
	var current :Variant = current_value()
	if not GdObjects.equals(current, expected):
		return report_error(GdAssertMessages.error_equal(current, expected))
	return report_success()


func is_not_equal(expected :Variant) -> GdUnitAssert:
	var current :Variant = current_value()
	if GdObjects.equals(current, expected):
		return report_error(GdAssertMessages.error_not_equal(current, expected))
	return report_success()


func is_null() -> GdUnitAssert:
	var current :Variant = current_value()
	if current != null:
		return report_error(GdAssertMessages.error_is_null(current))
	return report_success()


func is_not_null() -> GdUnitAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_is_not_null())
	return report_success()
# Preloads all GdUnit assertions
class_name GdUnitAssertions
extends RefCounted


@warning_ignore("return_value_discarded")
func _init() -> void:
	# preload all gdunit assertions to speedup testsuite loading time
	# gdlint:disable=private-method-call
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitBoolAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitStringAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitIntAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFloatAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitVectorAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitArrayAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitDictionaryAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFileAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitObjectAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitResultAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFuncAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitSignalAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitFailureAssertImpl.gd")
	GdUnitAssertions.__lazy_load("res://addons/gdUnit4/src/asserts/GdUnitGodotErrorAssertImpl.gd")


### We now load all used asserts and tool scripts into the cache according to the principle of "lazy loading"
### in order to noticeably reduce the loading time of the test suite.
# We go this hard way to increase the loading performance to avoid reparsing all the used scripts
# for more detailed info -> https://github.com/godotengine/godot/issues/67400
# gdlint:disable=function-name
static func __lazy_load(script_path :String) -> GDScript:
	return ResourceLoader.load(script_path, "GDScript", ResourceLoader.CACHE_MODE_REUSE)


static func validate_value_type(value :Variant, type :Variant.Type) -> bool:
	return value == null or typeof(value) == type


# Scans the current stack trace for the root cause to extract the line number
static func get_line_number() -> int:
	var stack_trace := get_stack()
	if stack_trace == null or stack_trace.is_empty():
		return -1
	for index in stack_trace.size():
		var stack_info :Dictionary = stack_trace[index]
		var function :String = stack_info.get("function")
		# we catch helper asserts to skip over to return the correct line number
		if function.begins_with("assert_"):
			continue
		if function.begins_with("test_"):
			return stack_info.get("line")
		var source :String = stack_info.get("source")
		if source.is_empty() \
			or source.begins_with("user://") \
			or source.ends_with("GdUnitAssert.gd") \
			or source.ends_with("GdUnitAssertions.gd") \
			or source.ends_with("AssertImpl.gd") \
			or source.ends_with("GdUnitTestSuite.gd") \
			or source.ends_with("GdUnitSceneRunnerImpl.gd") \
			or source.ends_with("GdUnitObjectInteractions.gd") \
			or source.ends_with("GdUnitAwaiter.gd"):
			continue
		return stack_info.get("line")
	return -1
extends GdUnitBoolAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not GdUnitAssertions.validate_value_type(current, TYPE_BOOL):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitBoolAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitBoolAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitBoolAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


# Verifies that the current value is null.
func is_null() -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


# Verifies that the current value is not null.
func is_not_null() -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected: Variant) -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected: Variant) -> GdUnitBoolAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


func is_true() -> GdUnitBoolAssert:
	if current_value() != true:
		return report_error(GdAssertMessages.error_is_true(current_value()))
	return report_success()


func is_false() -> GdUnitBoolAssert:
	if current_value() == true || current_value() == null:
		return report_error(GdAssertMessages.error_is_false(current_value()))
	return report_success()
extends GdUnitDictionaryAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not GdUnitAssertions.validate_value_type(current, TYPE_DICTIONARY):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitDictionaryAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func report_success() -> GdUnitDictionaryAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitDictionaryAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitDictionaryAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitDictionaryAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func current_value() -> Variant:
	return _base.current_value()


func is_null() -> GdUnitDictionaryAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitDictionaryAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected :Variant) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_equal(null, GdAssertMessages.format_dict(expected)))
	if not GdObjects.equals(current, expected):
		var c := GdAssertMessages.format_dict(current)
		var e := GdAssertMessages.format_dict(expected)
		var diff := GdDiffTool.string_diff(c, e)
		var curent_diff := GdAssertMessages.colored_array_div(diff[1])
		return report_error(GdAssertMessages.error_equal(curent_diff, e))
	return report_success()


func is_not_equal(expected :Variant) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if GdObjects.equals(current, expected):
		return report_error(GdAssertMessages.error_not_equal(current, expected))
	return report_success()


@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_same(expected :Variant) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_equal(null, GdAssertMessages.format_dict(expected)))
	if not is_same(current, expected):
		var c := GdAssertMessages.format_dict(current)
		var e := GdAssertMessages.format_dict(expected)
		var diff := GdDiffTool.string_diff(c, e)
		var curent_diff := GdAssertMessages.colored_array_div(diff[1])
		return report_error(GdAssertMessages.error_is_same(curent_diff, e))
	return report_success()


@warning_ignore("unused_parameter", "shadowed_global_identifier")
func is_not_same(expected :Variant) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if is_same(current, expected):
		return report_error(GdAssertMessages.error_not_same(current, expected))
	return report_success()


func is_empty() -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or not (current as Dictionary).is_empty():
		return report_error(GdAssertMessages.error_is_empty(current))
	return report_success()


func is_not_empty() -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or (current as Dictionary).is_empty():
		return report_error(GdAssertMessages.error_is_not_empty())
	return report_success()


func has_size(expected: int) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_is_not_null())
	@warning_ignore("unsafe_cast")
	if (current as Dictionary).size() != expected:
		return report_error(GdAssertMessages.error_has_size(current, expected))
	return report_success()


func _contains_keys(expected :Array, compare_mode :GdObjects.COMPARE_MODE) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_is_not_null())
	# find expected keys
	@warning_ignore("unsafe_cast")
	var keys_not_found :Array = expected.filter(_filter_by_key.bind((current as Dictionary).keys(), compare_mode))
	if not keys_not_found.is_empty():
		@warning_ignore("unsafe_cast")
		return report_error(GdAssertMessages.error_contains_keys((current as Dictionary).keys() as Array, expected, keys_not_found, compare_mode))
	return report_success()


func _contains_key_value(key :Variant, value :Variant, compare_mode :GdObjects.COMPARE_MODE) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	var expected := [key]
	if current == null:
		return report_error(GdAssertMessages.error_is_not_null())
	var dict_current: Dictionary = current
	var keys_not_found :Array = expected.filter(_filter_by_key.bind(dict_current.keys(), compare_mode))
	if not keys_not_found.is_empty():
		return report_error(GdAssertMessages.error_contains_keys(dict_current.keys() as Array, expected, keys_not_found, compare_mode))
	if not GdObjects.equals(dict_current[key], value, false, compare_mode):
		return report_error(GdAssertMessages.error_contains_key_value(key, value, dict_current[key], compare_mode))
	return report_success()


func _not_contains_keys(expected :Array, compare_mode :GdObjects.COMPARE_MODE) -> GdUnitDictionaryAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_is_not_null())
	var dict_current: Dictionary = current
	var keys_found :Array = dict_current.keys().filter(_filter_by_key.bind(expected, compare_mode, true))
	if not keys_found.is_empty():
		return report_error(GdAssertMessages.error_not_contains_keys(dict_current.keys() as Array, expected, keys_found, compare_mode))
	return report_success()


func contains_keys(expected :Array) -> GdUnitDictionaryAssert:
	return _contains_keys(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func contains_key_value(key :Variant, value :Variant) -> GdUnitDictionaryAssert:
	return _contains_key_value(key, value, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func not_contains_keys(expected :Array) -> GdUnitDictionaryAssert:
	return _not_contains_keys(expected, GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST)


func contains_same_keys(expected :Array) -> GdUnitDictionaryAssert:
	return _contains_keys(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func contains_same_key_value(key :Variant, value :Variant) -> GdUnitDictionaryAssert:
	return _contains_key_value(key, value, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func not_contains_same_keys(expected :Array) -> GdUnitDictionaryAssert:
	return _not_contains_keys(expected, GdObjects.COMPARE_MODE.OBJECT_REFERENCE)


func _filter_by_key(element :Variant, values :Array, compare_mode :GdObjects.COMPARE_MODE, is_not :bool = false) -> bool:
	for key :Variant in values:
		if GdObjects.equals(key, element, false, compare_mode):
			return is_not
	return !is_not
extends GdUnitFailureAssert

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

var _is_failed := false
var _failure_message :String


func _set_do_expect_fail(enabled :bool = true) -> void:
	Engine.set_meta(GdUnitConstants.EXPECT_ASSERT_REPORT_FAILURES, enabled)


func execute_and_await(assertion :Callable, do_await := true) -> GdUnitFailureAssert:
	# do not report any failure from the original assertion we want to test
	_set_do_expect_fail(true)
	var thread_context := GdUnitThreadManager.get_current_context()
	thread_context.set_assert(null)
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_set_test_failed.connect(_on_test_failed)
	# execute the given assertion as callable
	if do_await:
		await assertion.call()
	else:
		assertion.call()
	_set_do_expect_fail(false)
	# get the assert instance from current tread context
	var current_assert := thread_context.get_assert()
	if not is_instance_of(current_assert, GdUnitAssert):
		_is_failed = true
		_failure_message = "Invalid Callable! It must be a callable of 'GdUnitAssert'"
		return self
	@warning_ignore("unsafe_method_access")
	_failure_message = current_assert.failure_message()
	return self


func execute(assertion :Callable) -> GdUnitFailureAssert:
	@warning_ignore("return_value_discarded")
	execute_and_await(assertion, false)
	return self


func _on_test_failed(value :bool) -> void:
	_is_failed = value


@warning_ignore("unused_parameter")
func is_equal(_expected: Variant) -> GdUnitFailureAssert:
	return _report_error("Not implemented")


@warning_ignore("unused_parameter")
func is_not_equal(_expected: Variant) -> GdUnitFailureAssert:
	return _report_error("Not implemented")


func is_null() -> GdUnitFailureAssert:
	return _report_error("Not implemented")


func is_not_null() -> GdUnitFailureAssert:
	return _report_error("Not implemented")


func is_success() -> GdUnitFailureAssert:
	if _is_failed:
		return _report_error("Expect: assertion ends successfully.")
	return self


func is_failed() -> GdUnitFailureAssert:
	if not _is_failed:
		return _report_error("Expect: assertion fails.")
	return self


func has_line(expected :int) -> GdUnitFailureAssert:
	var current := GdAssertReports.get_last_error_line_number()
	if current != expected:
		return _report_error("Expect: to failed on line '%d'\n but was '%d'." % [expected, current])
	return self


func has_message(expected :String) -> GdUnitFailureAssert:
	@warning_ignore("return_value_discarded")
	is_failed()
	var expected_error := GdUnitTools.normalize_text(GdUnitTools.richtext_normalize(expected))
	var current_error := GdUnitTools.normalize_text(GdUnitTools.richtext_normalize(_failure_message))
	if current_error != expected_error:
		var diffs := GdDiffTool.string_diff(current_error, expected_error)
		var current := GdAssertMessages.colored_array_div(diffs[1])
		return _report_error(GdAssertMessages.error_not_same_error(current, expected_error))
	return self


func contains_message(expected :String) -> GdUnitFailureAssert:
	var expected_error := GdUnitTools.normalize_text(expected)
	var current_error := GdUnitTools.normalize_text(GdUnitTools.richtext_normalize(_failure_message))
	if not current_error.contains(expected_error):
		var diffs := GdDiffTool.string_diff(current_error, expected_error)
		var current := GdAssertMessages.colored_array_div(diffs[1])
		return _report_error(GdAssertMessages.error_not_same_error(current, expected_error))
	return self


func starts_with_message(expected :String) -> GdUnitFailureAssert:
	var expected_error := GdUnitTools.normalize_text(expected)
	var current_error := GdUnitTools.normalize_text(GdUnitTools.richtext_normalize(_failure_message))
	if current_error.find(expected_error) != 0:
		var diffs := GdDiffTool.string_diff(current_error, expected_error)
		var current := GdAssertMessages.colored_array_div(diffs[1])
		return _report_error(GdAssertMessages.error_not_same_error(current, expected_error))
	return self


func _report_error(error_message :String, failure_line_number: int = -1) -> GdUnitAssert:
	var line_number := failure_line_number if failure_line_number != -1 else GdUnitAssertions.get_line_number()
	GdAssertReports.report_error(error_message, line_number)
	return self


func _report_success() -> GdUnitFailureAssert:
	GdAssertReports.report_success()
	return self
extends GdUnitFileAssert

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not GdUnitAssertions.validate_value_type(current, TYPE_STRING):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitFileAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func current_value() -> String:
	return _base.current_value()


func report_success() -> GdUnitFileAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitFileAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitFileAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitFileAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_equal(expected :Variant) -> GdUnitFileAssert:
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected :Variant) -> GdUnitFileAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


func is_file() -> GdUnitFileAssert:
	var current := current_value()
	if FileAccess.open(current, FileAccess.READ) == null:
		return report_error("Is not a file '%s', error code %s" % [current, FileAccess.get_open_error()])
	return report_success()


func exists() -> GdUnitFileAssert:
	var current := current_value()
	if not FileAccess.file_exists(current):
		return report_error("The file '%s' not exists" %current)
	return report_success()


func is_script() -> GdUnitFileAssert:
	var current := current_value()
	if FileAccess.open(current, FileAccess.READ) == null:
		return report_error("Can't acces the file '%s'! Error code %s" % [current, FileAccess.get_open_error()])

	var script := load(current)
	if not script is GDScript:
		return report_error("The file '%s' is not a GdScript" % current)
	return report_success()


func contains_exactly(expected_rows: Array) -> GdUnitFileAssert:
	var current := current_value()
	if FileAccess.open(current, FileAccess.READ) == null:
		return report_error("Can't acces the file '%s'! Error code %s" % [current, FileAccess.get_open_error()])

	var script: GDScript = load(current)
	if script is GDScript:
		var source_code := GdScriptParser.to_unix_format(script.source_code)
		var rows := Array(source_code.split("\n"))
		GdUnitArrayAssertImpl.new(rows).contains_exactly(expected_rows)
	return self
extends GdUnitFloatAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not GdUnitAssertions.validate_value_type(current, TYPE_FLOAT):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitFloatAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitFloatAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitFloatAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_null() -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected :Variant) -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected :Variant) -> GdUnitFloatAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


@warning_ignore("shadowed_global_identifier")
func is_equal_approx(expected :float, approx :float) -> GdUnitFloatAssert:
	return is_between(expected-approx, expected+approx)


func is_less(expected :float) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current >= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_THAN, current, expected))
	return report_success()


func is_less_equal(expected :float) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current > expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_EQUAL, current, expected))
	return report_success()


func is_greater(expected :float) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current <= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_THAN, current, expected))
	return report_success()


func is_greater_equal(expected :float) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current < expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_EQUAL, current, expected))
	return report_success()


func is_negative() -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current >= 0.0:
		return report_error(GdAssertMessages.error_is_negative(current))
	return report_success()


func is_not_negative() -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current < 0.0:
		return report_error(GdAssertMessages.error_is_not_negative(current))
	return report_success()


func is_zero() -> GdUnitFloatAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or not is_equal_approx(0.00000000, current as float):
		return report_error(GdAssertMessages.error_is_zero(current))
	return report_success()


func is_not_zero() -> GdUnitFloatAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or is_equal_approx(0.00000000, current as float):
		return report_error(GdAssertMessages.error_is_not_zero())
	return report_success()


func is_in(expected :Array) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if not expected.has(current):
		return report_error(GdAssertMessages.error_is_in(current, expected))
	return report_success()


func is_not_in(expected :Array) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if expected.has(current):
		return report_error(GdAssertMessages.error_is_not_in(current, expected))
	return report_success()


func is_between(from :float, to :float) -> GdUnitFloatAssert:
	var current :Variant = current_value()
	if current == null or current < from or current > to:
		return report_error(GdAssertMessages.error_is_value(Comparator.BETWEEN_EQUAL, current, from, to))
	return report_success()
extends GdUnitFuncAssert


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const DEFAULT_TIMEOUT := 2000


var _current_value_provider :ValueProvider
var _current_failure_message :String = ""
var _custom_failure_message :String = ""
var _additional_failure_message: String = ""
var _line_number := -1
var _timeout := DEFAULT_TIMEOUT
var _interrupted := false
var _sleep_timer :Timer = null


func _init(instance :Object, func_name :String, args := Array()) -> void:
	_line_number = GdUnitAssertions.get_line_number()
	GdAssertReports.reset_last_error_line_number()
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	# verify at first the function name exists
	if not instance.has_method(func_name):
		@warning_ignore("return_value_discarded")
		report_error("The function '%s' do not exists checked instance '%s'." % [func_name, instance])
		_interrupted = true
	else:
		_current_value_provider = CallBackValueProvider.new(instance, func_name, args)


func _notification(what :int) -> void:
	if what == NOTIFICATION_PREDELETE:
		_interrupted = true
		var main_node :Node = (Engine.get_main_loop() as SceneTree).root
		if is_instance_valid(_current_value_provider):
			_current_value_provider.dispose()
			_current_value_provider = null
		if is_instance_valid(_sleep_timer):
			_sleep_timer.set_wait_time(0.0001)
			_sleep_timer.stop()
			main_node.remove_child(_sleep_timer)
			_sleep_timer.free()
			_sleep_timer = null


func report_success() -> GdUnitFuncAssert:
	GdAssertReports.report_success()
	return self


func report_error(failure :String) -> GdUnitFuncAssert:
	_current_failure_message = GdAssertMessages.build_failure_message(failure, _additional_failure_message, _custom_failure_message)
	GdAssertReports.report_error(_current_failure_message, _line_number)
	return self


func failure_message() -> String:
	return _current_failure_message


func override_failure_message(message :String) -> GdUnitFuncAssert:
	_custom_failure_message = message
	return self


func append_failure_message(message :String) -> GdUnitFuncAssert:
	_additional_failure_message = message
	return self


func wait_until(timeout := 2000) -> GdUnitFuncAssert:
	if timeout <= 0:
		push_warning("Invalid timeout param, alloed timeouts must be grater than 0. Use default timeout instead")
		_timeout = DEFAULT_TIMEOUT
	else:
		_timeout = timeout
	return self


func is_null() -> GdUnitFuncAssert:
	await _validate_callback(cb_is_null)
	return self


func is_not_null() -> GdUnitFuncAssert:
	await _validate_callback(cb_is_not_null)
	return self


func is_false() -> GdUnitFuncAssert:
	await _validate_callback(cb_is_false)
	return self


func is_true() -> GdUnitFuncAssert:
	await _validate_callback(cb_is_true)
	return self


func is_equal(expected :Variant) -> GdUnitFuncAssert:
	await _validate_callback(cb_is_equal, expected)
	return self


func is_not_equal(expected :Variant) -> GdUnitFuncAssert:
	await _validate_callback(cb_is_not_equal, expected)
	return self


# we need actually to define this Callable as functions otherwise we results into leaked scripts here
# this is actually a Godot bug and needs this kind of workaround
func cb_is_null(c :Variant, _e :Variant) -> bool: return c == null
func cb_is_not_null(c :Variant, _e :Variant) -> bool: return c != null
func cb_is_false(c :Variant, _e :Variant) -> bool: return c == false
func cb_is_true(c :Variant, _e :Variant) -> bool: return c == true
func cb_is_equal(c :Variant, e :Variant) -> bool: return GdObjects.equals(c,e)
func cb_is_not_equal(c :Variant, e :Variant) -> bool: return not GdObjects.equals(c, e)


func do_interrupt() -> void:
	_interrupted = true


func _validate_callback(predicate :Callable, expected :Variant = null) -> void:
	if _interrupted:
		return
	GdUnitMemoryObserver.guard_instance(self)
	var time_scale := Engine.get_time_scale()
	var timer := Timer.new()
	timer.set_name("gdunit_funcassert_interrupt_timer_%d" % timer.get_instance_id())
	var scene_tree := Engine.get_main_loop() as SceneTree
	scene_tree.root.add_child(timer)
	timer.add_to_group("GdUnitTimers")
	@warning_ignore("return_value_discarded")
	timer.timeout.connect(do_interrupt, CONNECT_DEFERRED)
	timer.set_one_shot(true)
	timer.start((_timeout/1000.0)*time_scale)
	_sleep_timer = Timer.new()
	_sleep_timer.set_name("gdunit_funcassert_sleep_timer_%d" % _sleep_timer.get_instance_id() )
	scene_tree.root.add_child(_sleep_timer)

	while true:
		var current :Variant = await next_current_value()
		# is interupted or predicate success
		if _interrupted or predicate.call(current, expected):
			break
		if is_instance_valid(_sleep_timer):
			_sleep_timer.start(0.05)
			await _sleep_timer.timeout

	_sleep_timer.stop()
	await scene_tree.process_frame
	if _interrupted:
		# https://github.com/godotengine/godot/issues/73052
		#var predicate_name = predicate.get_method()
		var predicate_name :String = str(predicate).split('::')[1]
		@warning_ignore("return_value_discarded")
		report_error(GdAssertMessages.error_interrupted(
			predicate_name.strip_edges().trim_prefix("cb_"),
			expected,
			LocalTime.elapsed(_timeout)
			)
		)
	else:
		@warning_ignore("return_value_discarded")
		report_success()
	_sleep_timer.free()
	timer.free()
	GdUnitMemoryObserver.unguard_instance(self)


func next_current_value() -> Variant:
	@warning_ignore("redundant_await")
	if is_instance_valid(_current_value_provider):
		return await _current_value_provider.get_value()
	return "invalid value"
extends GdUnitGodotErrorAssert

var _current_error_message :String
var _callable :Callable


func _init(callable :Callable) -> void:
	# we only support Godot 4.1.x+ because of await issue https://github.com/godotengine/godot/issues/80292
	assert(Engine.get_version_info().hex >= 0x40100,
			"This assertion is not supported for Godot 4.0.x. Please upgrade to the minimum version Godot 4.1.0!")
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	GdAssertReports.reset_last_error_line_number()
	_callable = callable


func _execute() -> Array[ErrorLogEntry]:
	# execute the given code and monitor for runtime errors
	if _callable == null or not _callable.is_valid():
		@warning_ignore("return_value_discarded")
		_report_error("Invalid Callable '%s'" % _callable)
	else:
		await _callable.call()
	return await _error_monitor().scan(true)


func _error_monitor() -> GodotGdErrorMonitor:
	return GdUnitThreadManager.get_current_context().get_execution_context().error_monitor


func failure_message() -> String:
	return _current_error_message


func _report_success() -> GdUnitAssert:
	GdAssertReports.report_success()
	return self


func _report_error(error_message :String, failure_line_number: int = -1) -> GdUnitAssert:
	var line_number := failure_line_number if failure_line_number != -1 else GdUnitAssertions.get_line_number()
	_current_error_message = error_message
	GdAssertReports.report_error(error_message, line_number)
	return self


func _has_log_entry(log_entries :Array[ErrorLogEntry], type :ErrorLogEntry.TYPE, error :String) -> bool:
	for entry in log_entries:
		if entry._type == type and entry._message == error:
			# Erase the log entry we already handled it by this assertion, otherwise it will report at twice
			_error_monitor().erase_log_entry(entry)
			return true
	return false


func _to_list(log_entries :Array[ErrorLogEntry]) -> String:
	if log_entries.is_empty():
		return "no errors"
	if log_entries.size() == 1:
		return log_entries[0]._message
	var value := ""
	for entry in log_entries:
		value += "'%s'\n" % entry._message
	return value


func is_success() -> GdUnitGodotErrorAssert:
	var log_entries := await _execute()
	if log_entries.is_empty():
		return _report_success()
	return _report_error("""
		Expecting: no error's are ocured.
			but found: '%s'
		""".dedent().trim_prefix("\n") % _to_list(log_entries))


func is_runtime_error(expected_error :String) -> GdUnitGodotErrorAssert:
	var log_entries := await _execute()
	if _has_log_entry(log_entries, ErrorLogEntry.TYPE.SCRIPT_ERROR, expected_error):
		return _report_success()
	return _report_error("""
		Expecting: a runtime error is triggered.
			message: '%s'
			found: %s
		""".dedent().trim_prefix("\n") % [expected_error, _to_list(log_entries)])


func is_push_warning(expected_warning :String) -> GdUnitGodotErrorAssert:
	var log_entries := await _execute()
	if _has_log_entry(log_entries, ErrorLogEntry.TYPE.PUSH_WARNING, expected_warning):
		return _report_success()
	return _report_error("""
		Expecting: push_warning() is called.
			message: '%s'
			found: %s
		""".dedent().trim_prefix("\n") % [expected_warning, _to_list(log_entries)])


func is_push_error(expected_error :String) -> GdUnitGodotErrorAssert:
	var log_entries := await _execute()
	if _has_log_entry(log_entries, ErrorLogEntry.TYPE.PUSH_ERROR, expected_error):
		return _report_success()
	return _report_error("""
		Expecting: push_error() is called.
			message: '%s'
			found: %s
		""".dedent().trim_prefix("\n") % [expected_error, _to_list(log_entries)])
extends GdUnitIntAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not GdUnitAssertions.validate_value_type(current, TYPE_INT):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitIntAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitIntAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitIntAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_null() -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected :Variant) -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected :Variant) -> GdUnitIntAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


func is_less(expected :int) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current >= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_THAN, current, expected))
	return report_success()


func is_less_equal(expected :int) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current > expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_EQUAL, current, expected))
	return report_success()


func is_greater(expected :int) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current <= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_THAN, current, expected))
	return report_success()


func is_greater_equal(expected :int) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current < expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_EQUAL, current, expected))
	return report_success()


func is_even() -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current % 2 != 0:
		return report_error(GdAssertMessages.error_is_even(current))
	return report_success()


func is_odd() -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current % 2 == 0:
		return report_error(GdAssertMessages.error_is_odd(current))
	return report_success()


func is_negative() -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current >= 0:
		return report_error(GdAssertMessages.error_is_negative(current))
	return report_success()


func is_not_negative() -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current < 0:
		return report_error(GdAssertMessages.error_is_not_negative(current))
	return report_success()


func is_zero() -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current != 0:
		return report_error(GdAssertMessages.error_is_zero(current))
	return report_success()


func is_not_zero() -> GdUnitIntAssert:
	var current :Variant= current_value()
	if current == 0:
		return report_error(GdAssertMessages.error_is_not_zero())
	return report_success()


func is_in(expected :Array) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if not expected.has(current):
		return report_error(GdAssertMessages.error_is_in(current, expected))
	return report_success()


func is_not_in(expected :Array) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if expected.has(current):
		return report_error(GdAssertMessages.error_is_not_in(current, expected))
	return report_success()


func is_between(from :int, to :int) -> GdUnitIntAssert:
	var current :Variant = current_value()
	if current == null or current < from or current > to:
		return report_error(GdAssertMessages.error_is_value(Comparator.BETWEEN_EQUAL, current, from, to))
	return report_success()
extends GdUnitObjectAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if (current != null
		and (GdUnitAssertions.validate_value_type(current, TYPE_BOOL)
		or GdUnitAssertions.validate_value_type(current, TYPE_INT)
		or GdUnitAssertions.validate_value_type(current, TYPE_FLOAT)
		or GdUnitAssertions.validate_value_type(current, TYPE_STRING))):
			@warning_ignore("return_value_discarded")
			report_error("GdUnitObjectAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitObjectAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitObjectAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_equal(expected :Variant) -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected :Variant) -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


func is_null() -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitObjectAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


@warning_ignore("shadowed_global_identifier")
func is_same(expected :Variant) -> GdUnitObjectAssert:
	var current :Variant = current_value()
	if not is_same(current, expected):
		return report_error(GdAssertMessages.error_is_same(current, expected))
	return report_success()


func is_not_same(expected :Variant) -> GdUnitObjectAssert:
	var current :Variant = current_value()
	if is_same(current, expected):
		return report_error(GdAssertMessages.error_not_same(current, expected))
	return report_success()


func is_instanceof(type :Object) -> GdUnitObjectAssert:
	var current :Variant = current_value()
	if current == null or not is_instance_of(current, type):
		var result_expected: = GdObjects.extract_class_name(type)
		var result_current: = GdObjects.extract_class_name(current)
		return report_error(GdAssertMessages.error_is_instanceof(result_current, result_expected))
	return report_success()


func is_not_instanceof(type :Variant) -> GdUnitObjectAssert:
	var current :Variant = current_value()
	if is_instance_of(current, type):
		var result: = GdObjects.extract_class_name(type)
		if result.is_success():
			return report_error("Expected not be a instance of <%s>" % str(result.value()))

		push_error("Internal ERROR: %s" % result.error_message())
		return self
	return report_success()
extends GdUnitResultAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not validate_value_type(current):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitResultAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func validate_value_type(value :Variant) -> bool:
	return value == null or value is GdUnitResult


func current_value() -> GdUnitResult:
	return _base.current_value()


func report_success() -> GdUnitResultAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitResultAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitResultAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitResultAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_null() -> GdUnitResultAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitResultAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_empty() -> GdUnitResultAssert:
	var result := current_value()
	if result == null or not result.is_empty():
		return report_error(GdAssertMessages.error_result_is_empty(result))
	return report_success()


func is_success() -> GdUnitResultAssert:
	var result := current_value()
	if result == null or not result.is_success():
		return report_error(GdAssertMessages.error_result_is_success(result))
	return report_success()


func is_warning() -> GdUnitResultAssert:
	var result := current_value()
	if result == null or not result.is_warn():
		return report_error(GdAssertMessages.error_result_is_warning(result))
	return report_success()


func is_error() -> GdUnitResultAssert:
	var result := current_value()
	if result == null or not result.is_error():
		return report_error(GdAssertMessages.error_result_is_error(result))
	return report_success()


func contains_message(expected :String) -> GdUnitResultAssert:
	var result := current_value()
	if result == null:
		return report_error(GdAssertMessages.error_result_has_message("<null>", expected))
	if result.is_success():
		return report_error(GdAssertMessages.error_result_has_message_on_success(expected))
	if result.is_error() and result.error_message() != expected:
		return report_error(GdAssertMessages.error_result_has_message(result.error_message(), expected))
	if result.is_warn() and result.warn_message() != expected:
		return report_error(GdAssertMessages.error_result_has_message(result.warn_message(), expected))
	return report_success()


func is_value(expected :Variant) -> GdUnitResultAssert:
	var result := current_value()
	var value :Variant = null if result == null else result.value()
	if not GdObjects.equals(value, expected):
		return report_error(GdAssertMessages.error_result_is_value(value, expected))
	return report_success()


func is_equal(expected :Variant) -> GdUnitResultAssert:
	return is_value(expected)
extends GdUnitSignalAssert

const DEFAULT_TIMEOUT := 2000

var _signal_collector :GdUnitSignalCollector
var _emitter :Object
var _current_failure_message :String = ""
var _custom_failure_message :String = ""
var _additional_failure_message: String = ""
var _line_number := -1
var _timeout := DEFAULT_TIMEOUT
var _interrupted := false


func _init(emitter :Object) -> void:
	# save the actual assert instance on the current thread context
	var context := GdUnitThreadManager.get_current_context()
	context.set_assert(self)
	_signal_collector = context.get_signal_collector()
	_line_number = GdUnitAssertions.get_line_number()
	_emitter =  emitter
	GdAssertReports.reset_last_error_line_number()


func _notification(what :int) -> void:
	if what == NOTIFICATION_PREDELETE:
		_interrupted = true
		if is_instance_valid(_emitter):
			_signal_collector.unregister_emitter(_emitter)
		_emitter = null


func report_success() -> GdUnitAssert:
	GdAssertReports.report_success()
	return self


func report_warning(message :String) -> GdUnitAssert:
	GdAssertReports.report_warning(message, GdUnitAssertions.get_line_number())
	return self


func report_error(failure :String) -> GdUnitAssert:
	_current_failure_message = GdAssertMessages.build_failure_message(failure, _additional_failure_message, _custom_failure_message)
	GdAssertReports.report_error(_current_failure_message, _line_number)
	return self


func failure_message() -> String:
	return _current_failure_message


func override_failure_message(message :String) -> GdUnitSignalAssert:
	_custom_failure_message = message
	return self


func append_failure_message(message :String) -> GdUnitSignalAssert:
	_additional_failure_message = message
	return self


func wait_until(timeout := 2000) -> GdUnitSignalAssert:
	if timeout <= 0:
		@warning_ignore("return_value_discarded")
		report_warning("Invalid timeout parameter, allowed timeouts must be greater than 0, use default timeout instead!")
		_timeout = DEFAULT_TIMEOUT
	else:
		_timeout = timeout
	return self


# Verifies the signal exists checked the emitter
func is_signal_exists(signal_name :String) -> GdUnitSignalAssert:
	if not _emitter.has_signal(signal_name):
		@warning_ignore("return_value_discarded")
		report_error("The signal '%s' not exists checked object '%s'." % [signal_name, _emitter.get_class()])
	return self


# Verifies that given signal is emitted until waiting time
func is_emitted(name :String, args := []) -> GdUnitSignalAssert:
	_line_number = GdUnitAssertions.get_line_number()
	return await _wail_until_signal(name, args, false)


# Verifies that given signal is NOT emitted until waiting time
func is_not_emitted(name :String, args := []) -> GdUnitSignalAssert:
	_line_number = GdUnitAssertions.get_line_number()
	return await _wail_until_signal(name, args, true)


func _wail_until_signal(signal_name :String, expected_args :Array, expect_not_emitted: bool) -> GdUnitSignalAssert:
	if _emitter == null:
		return report_error("Can't wait for signal checked a NULL object.")
	# first verify the signal is defined
	if not _emitter.has_signal(signal_name):
		return report_error("Can't wait for non-existion signal '%s' checked object '%s'." % [signal_name,_emitter.get_class()])
	_signal_collector.register_emitter(_emitter)
	var time_scale := Engine.get_time_scale()
	var timer := Timer.new()
	(Engine.get_main_loop() as SceneTree).root.add_child(timer)
	timer.add_to_group("GdUnitTimers")
	timer.set_one_shot(true)
	@warning_ignore("return_value_discarded")
	timer.timeout.connect(func on_timeout() -> void: _interrupted = true)
	timer.start((_timeout/1000.0)*time_scale)
	var is_signal_emitted := false
	while not _interrupted and not is_signal_emitted:
		await (Engine.get_main_loop() as SceneTree).process_frame
		if is_instance_valid(_emitter):
			is_signal_emitted = _signal_collector.match(_emitter, signal_name, expected_args)
			if is_signal_emitted and expect_not_emitted:
				@warning_ignore("return_value_discarded")
				report_error(GdAssertMessages.error_signal_emitted(signal_name, expected_args, LocalTime.elapsed(int(_timeout-timer.time_left*1000))))

	if _interrupted and not expect_not_emitted:
		@warning_ignore("return_value_discarded")
		report_error(GdAssertMessages.error_wait_signal(signal_name, expected_args, LocalTime.elapsed(_timeout)))
	timer.free()
	if is_instance_valid(_emitter):
		_signal_collector.reset_received_signals(_emitter, signal_name, expected_args)
	return self
extends GdUnitStringAssert

var _base: GdUnitAssertImpl


func _init(current :Variant) -> void:
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if current != null and typeof(current) != TYPE_STRING and typeof(current) != TYPE_STRING_NAME:
		@warning_ignore("return_value_discarded")
		report_error("GdUnitStringAssert inital error, unexpected type <%s>" % GdObjects.typeof_as_string(current))


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func failure_message() -> String:
	return _base.failure_message()


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitStringAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitStringAssert:
	_base.report_error(error)
	return self


func override_failure_message(message :String) -> GdUnitStringAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitStringAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_null() -> GdUnitStringAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitStringAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected :Variant) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_equal(current, expected))
	if not GdObjects.equals(current, expected):
		var diffs := GdDiffTool.string_diff(current, expected)
		var formatted_current := GdAssertMessages.colored_array_div(diffs[1])
		return report_error(GdAssertMessages.error_equal(formatted_current, expected))
	return report_success()


func is_equal_ignoring_case(expected :Variant) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_equal_ignoring_case(current, expected))
	if not GdObjects.equals(str(current), expected, true):
		var diffs := GdDiffTool.string_diff(current, expected)
		var formatted_current := GdAssertMessages.colored_array_div(diffs[1])
		return report_error(GdAssertMessages.error_equal_ignoring_case(formatted_current, expected))
	return report_success()


func is_not_equal(expected :Variant) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if GdObjects.equals(current, expected):
		return report_error(GdAssertMessages.error_not_equal(current, expected))
	return report_success()


func is_not_equal_ignoring_case(expected :Variant) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if GdObjects.equals(current, expected, true):
		return report_error(GdAssertMessages.error_not_equal(current, expected))
	return report_success()


func is_empty() -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or not (current as String).is_empty():
		return report_error(GdAssertMessages.error_is_empty(current))
	return report_success()


func is_not_empty() -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or (current as String).is_empty():
		return report_error(GdAssertMessages.error_is_not_empty())
	return report_success()


func contains(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or (current as String).find(expected) == -1:
		return report_error(GdAssertMessages.error_contains(current, expected))
	return report_success()


func not_contains(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current != null and (current as String).find(expected) != -1:
		return report_error(GdAssertMessages.error_not_contains(current, expected))
	return report_success()


func contains_ignoring_case(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or (current as String).findn(expected) == -1:
		return report_error(GdAssertMessages.error_contains_ignoring_case(current, expected))
	return report_success()


func not_contains_ignoring_case(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current != null and (current as String).findn(expected) != -1:
		return report_error(GdAssertMessages.error_not_contains_ignoring_case(current, expected))
	return report_success()


func starts_with(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	@warning_ignore("unsafe_cast")
	if current == null or (current as String).find(expected) != 0:
		return report_error(GdAssertMessages.error_starts_with(current, expected))
	return report_success()


func ends_with(expected :String) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_ends_with(current, expected))
	@warning_ignore("unsafe_cast")
	var find :int = (current as String).length() - expected.length()
	@warning_ignore("unsafe_cast")
	if (current as String).rfind(expected) != find:
		return report_error(GdAssertMessages.error_ends_with(current, expected))
	return report_success()


# gdlint:disable=max-returns
func has_length(expected :int, comparator := Comparator.EQUAL) -> GdUnitStringAssert:
	var current :Variant = current_value()
	if current == null:
		return report_error(GdAssertMessages.error_has_length(current, expected, comparator))
	var str_current: String = current
	match comparator:
		Comparator.EQUAL:
			if str_current.length() != expected:
				return report_error(GdAssertMessages.error_has_length(str_current, expected, comparator))
		Comparator.LESS_THAN:
			if str_current.length() >= expected:
				return report_error(GdAssertMessages.error_has_length(str_current, expected, comparator))
		Comparator.LESS_EQUAL:
			if str_current.length() > expected:
				return report_error(GdAssertMessages.error_has_length(str_current, expected, comparator))
		Comparator.GREATER_THAN:
			if str_current.length() <= expected:
				return report_error(GdAssertMessages.error_has_length(str_current, expected, comparator))
		Comparator.GREATER_EQUAL:
			if str_current.length() < expected:
				return report_error(GdAssertMessages.error_has_length(str_current, expected, comparator))
		_:
			return report_error("Comparator '%d' not implemented!" % comparator)
	return report_success()
extends GdUnitVectorAssert

var _base: GdUnitAssertImpl
var _current_type: int
var _type_check: bool

func _init(current: Variant, type_check := true) -> void:
	_type_check = type_check
	_base = GdUnitAssertImpl.new(current)
	# save the actual assert instance on the current thread context
	GdUnitThreadManager.get_current_context().set_assert(self)
	if not _validate_value_type(current):
		@warning_ignore("return_value_discarded")
		report_error("GdUnitVectorAssert error, the type <%s> is not supported." % GdObjects.typeof_as_string(current))
	_current_type = typeof(current)


func _notification(event :int) -> void:
	if event == NOTIFICATION_PREDELETE:
		if _base != null:
			_base.notification(event)
			_base = null


func _validate_value_type(value :Variant) -> bool:
	return (
		value == null
		or typeof(value) in [
			TYPE_VECTOR2,
			TYPE_VECTOR2I,
			TYPE_VECTOR3,
			TYPE_VECTOR3I,
			TYPE_VECTOR4,
			TYPE_VECTOR4I
		]
	)


func _validate_is_vector_type(value :Variant) -> bool:
	var type := typeof(value)
	if type == _current_type or _current_type == TYPE_NIL:
		return true
	@warning_ignore("return_value_discarded")
	report_error(GdAssertMessages.error_is_wrong_type(_current_type, type))
	return false


func current_value() -> Variant:
	return _base.current_value()


func report_success() -> GdUnitVectorAssert:
	_base.report_success()
	return self


func report_error(error :String) -> GdUnitVectorAssert:
	_base.report_error(error)
	return self


func failure_message() -> String:
	return _base.failure_message()


func override_failure_message(message :String) -> GdUnitVectorAssert:
	@warning_ignore("return_value_discarded")
	_base.override_failure_message(message)
	return self


func append_failure_message(message :String) -> GdUnitVectorAssert:
	@warning_ignore("return_value_discarded")
	_base.append_failure_message(message)
	return self


func is_null() -> GdUnitVectorAssert:
	@warning_ignore("return_value_discarded")
	_base.is_null()
	return self


func is_not_null() -> GdUnitVectorAssert:
	@warning_ignore("return_value_discarded")
	_base.is_not_null()
	return self


func is_equal(expected: Variant) -> GdUnitVectorAssert:
	if _type_check and not _validate_is_vector_type(expected):
		return self
	@warning_ignore("return_value_discarded")
	_base.is_equal(expected)
	return self


func is_not_equal(expected: Variant) -> GdUnitVectorAssert:
	if _type_check and not _validate_is_vector_type(expected):
		return self
	@warning_ignore("return_value_discarded")
	_base.is_not_equal(expected)
	return self


@warning_ignore("shadowed_global_identifier")
func is_equal_approx(expected :Variant, approx :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(expected) or not _validate_is_vector_type(approx):
		return self
	var current :Variant = current_value()
	var from :Variant = expected - approx
	var to :Variant = expected + approx
	if current == null or (not _is_equal_approx(current, from, to)):
		return report_error(GdAssertMessages.error_is_value(Comparator.BETWEEN_EQUAL, current, from, to))
	return report_success()


func _is_equal_approx(current :Variant, from :Variant, to :Variant) -> bool:
	match typeof(current):
		TYPE_VECTOR2, TYPE_VECTOR2I:
			return ((current.x >= from.x and current.y >= from.y)
				and (current.x <= to.x and current.y <= to.y))
		TYPE_VECTOR3, TYPE_VECTOR3I:
			return ((current.x >= from.x and current.y >= from.y and current.z >= from.z)
				and (current.x <= to.x and current.y <= to.y and current.z <= to.z))
		TYPE_VECTOR4, TYPE_VECTOR4I:
			return ((current.x >= from.x and current.y >= from.y and current.z >= from.z and current.w >= from.w)
				and (current.x <= to.x and current.y <= to.y and current.z <= to.z and current.w <= to.w))
		_:
			push_error("Missing implementation '_is_equal_approx' for vector type %s" % typeof(current))
			return false


func is_less(expected :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(expected):
		return self
	var current :Variant = current_value()
	if current == null or current >= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_THAN, current, expected))
	return report_success()


func is_less_equal(expected :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(expected):
		return self
	var current :Variant = current_value()
	if current == null or current > expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.LESS_EQUAL, current, expected))
	return report_success()


func is_greater(expected :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(expected):
		return self
	var current :Variant = current_value()
	if current == null or current <= expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_THAN, current, expected))
	return report_success()


func is_greater_equal(expected :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(expected):
		return self
	var current :Variant = current_value()
	if current == null or current < expected:
		return report_error(GdAssertMessages.error_is_value(Comparator.GREATER_EQUAL, current, expected))
	return report_success()


func is_between(from :Variant, to :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(from) or not _validate_is_vector_type(to):
		return self
	var current :Variant = current_value()
	if current == null or not (current >= from and current <= to):
		return report_error(GdAssertMessages.error_is_value(Comparator.BETWEEN_EQUAL, current, from, to))
	return report_success()


func is_not_between(from :Variant, to :Variant) -> GdUnitVectorAssert:
	if not _validate_is_vector_type(from) or not _validate_is_vector_type(to):
		return self
	var current :Variant = current_value()
	if (current != null and current >= from and current <= to):
		return report_error(GdAssertMessages.error_is_value(Comparator.NOT_BETWEEN_EQUAL, current, from, to))
	return report_success()
# base interface for assert value provider
class_name ValueProvider
extends RefCounted

func get_value() -> Variant:
	return null


func dispose() -> void:
	pass
class_name CmdArgumentParser
extends RefCounted

var _options :CmdOptions
var _tool_name :String
var _parsed_commands :Dictionary = Dictionary()


func _init(p_options :CmdOptions, p_tool_name :String) -> void:
	_options = p_options
	_tool_name = p_tool_name


func parse(args :Array, ignore_unknown_cmd := false) -> GdUnitResult:
	_parsed_commands.clear()

	# parse until first program argument
	while not args.is_empty():
		var arg :String = args.pop_front()
		if arg.find(_tool_name) != -1:
			break

	if args.is_empty():
		return GdUnitResult.empty()

	# now parse all arguments
	while not args.is_empty():
		var cmd :String = args.pop_front()
		var option := _options.get_option(cmd)

		if option:
			if _parse_cmd_arguments(option, args) == -1:
				return GdUnitResult.error("The '%s' command requires an argument!" % option.short_command())
		elif not ignore_unknown_cmd:
			return GdUnitResult.error("Unknown '%s' command!" % cmd)
	return GdUnitResult.success(_parsed_commands.values())


func options() -> CmdOptions:
	return _options


func _parse_cmd_arguments(option: CmdOption, args: Array) -> int:
	var command_name := option.short_command()
	var command: CmdCommand = _parsed_commands.get(command_name, CmdCommand.new(command_name))

	if option.has_argument():
		if not option.is_argument_optional() and args.is_empty():
			return -1
		if _is_next_value_argument(args):
			var value: String = args.pop_front()
			command.add_argument(value)
		elif not option.is_argument_optional():
			return -1
	_parsed_commands[command_name] = command
	return 0


func _is_next_value_argument(args: PackedStringArray) -> bool:
	if args.is_empty():
		return false
	return _options.get_option(args[0]) == null
class_name CmdCommand
extends RefCounted

var _name: String
var _arguments: PackedStringArray


func _init(p_name :String, p_arguments := []) -> void:
	_name = p_name
	_arguments = PackedStringArray(p_arguments)


func name() -> String:
	return _name


func arguments() -> PackedStringArray:
	return _arguments


func add_argument(arg :String) -> void:
	@warning_ignore("return_value_discarded")
	_arguments.append(arg)


func _to_string() -> String:
	return "%s:%s" % [_name, ", ".join(_arguments)]
class_name CmdCommandHandler
extends RefCounted

const CB_SINGLE_ARG = 0
const CB_MULTI_ARGS = 1
const NO_CB := Callable()

var _cmd_options :CmdOptions
# holds the command callbacks by key:<cmd_name>:String and value: [<cb single arg>, <cb multible args>]:Array
# Dictionary[String, Array[Callback]
var _command_cbs :Dictionary



func _init(cmd_options: CmdOptions) -> void:
	_cmd_options = cmd_options


# register a callback function for given command
# cmd_name short name of the command
# fr_arg a funcref to a function with a single argument
func register_cb(cmd_name: String, cb: Callable) -> CmdCommandHandler:
	var registered_cb: Array = _command_cbs.get(cmd_name, [NO_CB, NO_CB])
	if registered_cb[CB_SINGLE_ARG]:
		push_error("A function for command '%s' is already registered!" % cmd_name)
		return self

	if not _validate_cb_signature(cb, TYPE_STRING):
		push_error(
			("The callback '%s:%s' for command '%s' has invalid function signature. "
			+"The callback signature must be 'func name(value: PackedStringArray)'")
			% [cb.get_object().get_class(), cb.get_method(), cmd_name])
		return null

	registered_cb[CB_SINGLE_ARG] = cb
	_command_cbs[cmd_name] = registered_cb
	return self


# register a callback function for given command
# cb a funcref to a function with a variable number of arguments but expects all parameters to be passed via a single Array.
func register_cbv(cmd_name: String, cb: Callable) -> CmdCommandHandler:
	var registered_cb: Array = _command_cbs.get(cmd_name, [NO_CB, NO_CB])
	if registered_cb[CB_MULTI_ARGS]:
		push_error("A function for command '%s' is already registered!" % cmd_name)
		return self

	if not _validate_cb_signature(cb, TYPE_PACKED_STRING_ARRAY):
		push_error(
			("The callback '%s:%s' for command '%s' has invalid function signature. "
			+"The callback signature must be 'func name(value: PackedStringArray)'")
			% [cb.get_object().get_class(), cb.get_method(), cmd_name])
		return null

	registered_cb[CB_MULTI_ARGS] = cb
	_command_cbs[cmd_name] = registered_cb
	return self


func _validate() -> GdUnitResult:
	var errors := PackedStringArray()
	# Dictionary[StringName, String]
	var registered_cbs := Dictionary()

	for cmd_name in _command_cbs.keys() as Array[String]:
		var cb: Callable = (_command_cbs[cmd_name][CB_SINGLE_ARG]
			if _command_cbs[cmd_name][CB_SINGLE_ARG]
			else _command_cbs[cmd_name][CB_MULTI_ARGS])
		if cb != NO_CB and not cb.is_valid():
			@warning_ignore("return_value_discarded")
			errors.append("Invalid function reference for command '%s', Check the function reference!" % cmd_name)
		if _cmd_options.get_option(cmd_name) == null:
			@warning_ignore("return_value_discarded")
			errors.append("The command '%s' is unknown, verify your CmdOptions!" % cmd_name)
		# verify for multiple registered command callbacks
		if cb != NO_CB:
			var cb_method := cb.get_method()
			if registered_cbs.has(cb_method):
				var already_registered_cmd :String = registered_cbs[cb_method]
				@warning_ignore("return_value_discarded")
				errors.append("The function reference '%s' already registerd for command '%s'!" % [cb_method, already_registered_cmd])
			else:
				registered_cbs[cb_method] = cmd_name
	if errors.is_empty():
		return GdUnitResult.success(true)
	return GdUnitResult.error("\n".join(errors))


func execute(commands: Array[CmdCommand]) -> GdUnitResult:
	var result := _validate()
	if result.is_error():
		return result
	for cmd in commands:
		var cmd_name := cmd.name()
		if _command_cbs.has(cmd_name):
			var cb_s: Callable = _command_cbs.get(cmd_name)[CB_SINGLE_ARG]
			var arguments := cmd.arguments()
			var cmd_option := _cmd_options.get_option(cmd_name)

			if arguments.is_empty():
				cb_s.call()
			elif arguments.size() > 1:
				var cb_m: Callable = _command_cbs.get(cmd_name)[CB_MULTI_ARGS]
				cb_m.call(arguments)
			else:
				if cmd_option.type() == TYPE_BOOL:
					cb_s.call(true if arguments[0] == "true" else false)
				else:
					cb_s.call(arguments[0])

	return GdUnitResult.success(true)


func _validate_cb_signature(cb: Callable, arg_type: int) -> bool:
	for m in cb.get_object().get_method_list():
		if m["name"] == cb.get_method():
			@warning_ignore("unsafe_cast")
			return _validate_func_arguments(m["args"] as Array, arg_type)
	return true


func _validate_func_arguments(arguments: Array, arg_type: int) -> bool:
	# validate we have a single argument
	if arguments.size() > 1:
		return false
	# a cb with no arguments is also valid
	if arguments.size() == 0:
		return true
	# validate argument type
	var arg: Dictionary = arguments[0]
	@warning_ignore("unsafe_cast")
	if arg["usage"] as int == PROPERTY_USAGE_NIL_IS_VARIANT:
		return true
	if arg["type"] != arg_type:
		return false
	return true
# prototype of console with CSI support
# https://notes.burke.libbey.me/ansi-escape-codes/
class_name CmdConsole
extends RefCounted

enum {
	COLOR_TABLE,
	COLOR_RGB
}

const BOLD = 0x1
const ITALIC = 0x2
const UNDERLINE = 0x4

const CSI_BOLD = "[1m"
const CSI_ITALIC = "[3m"
const CSI_UNDERLINE = "[4m"

# Control Sequence Introducer
var _debug_show_color_codes := false
var _color_mode := COLOR_TABLE


func color(p_color :Color) -> CmdConsole:
	# using color table 16 - 231 a  6 x 6 x 6 RGB color cube  (16 + R * 36 + G * 6 + B)
	#if _color_mode == COLOR_TABLE:
	#	@warning_ignore("integer_division")
	#	var c2 := 16 + (int(p_color.r8/42) * 36) + (int(p_color.g8/42) * 6) + int(p_color.b8/42)
	#	if _debug_show_color_codes:
	#		printraw("%6d" % [c2])
	#	printraw("[38;5;%dm" % c2 )
	#else:
	printraw("[38;2;%d;%d;%dm" % [p_color.r8, p_color.g8, p_color.b8] )
	return self


func save_cursor() -> CmdConsole:
	printraw("[s")
	return self


func restore_cursor() -> CmdConsole:
	printraw("[u")
	return self


func end_color() -> CmdConsole:
	printraw("[0m")
	return self


func row_pos(row :int) -> CmdConsole:
	printraw("[%d;0H" % row )
	return self


func scroll_area(from :int, to :int) -> CmdConsole:
	printraw("[%d;%dr" % [from ,to])
	return self


@warning_ignore("return_value_discarded")
func progress_bar(p_progress :int, p_color :Color = Color.POWDER_BLUE) -> CmdConsole:
	if p_progress < 0:
		p_progress = 0
	if p_progress > 100:
		p_progress = 100
	color(p_color)
	printraw("[%-50s] %-3d%%\r" % ["".lpad(int(p_progress/2.0), "■").rpad(50, "-"), p_progress])
	end_color()
	return self


func printl(value :String) -> CmdConsole:
	printraw(value)
	return self


func new_line() -> CmdConsole:
	prints()
	return self


func reset() -> CmdConsole:
	return self


func bold(enable :bool) -> CmdConsole:
	if enable:
		printraw(CSI_BOLD)
	return self


func italic(enable :bool) -> CmdConsole:
	if enable:
		printraw(CSI_ITALIC)
	return self


func underline(enable :bool) -> CmdConsole:
	if enable:
		printraw(CSI_UNDERLINE)
	return self


func prints_error(message :String) -> CmdConsole:
	return color(Color.CRIMSON).printl(message).end_color().new_line()


func prints_warning(message :String) -> CmdConsole:
	return color(Color.GOLDENROD).printl(message).end_color().new_line()


func prints_color(p_message :String, p_color :Color, p_flags := 0) -> CmdConsole:
	return print_color(p_message, p_color, p_flags).new_line()


func print_color(p_message :String, p_color :Color, p_flags := 0) -> CmdConsole:
	return color(p_color)\
		.bold(p_flags&BOLD == BOLD)\
		.italic(p_flags&ITALIC == ITALIC)\
		.underline(p_flags&UNDERLINE == UNDERLINE)\
		.printl(p_message)\
		.end_color()


@warning_ignore("return_value_discarded")
func print_color_table() -> void:
	prints_color("Color Table 6x6x6", Color.ANTIQUE_WHITE)
	_debug_show_color_codes = true
	for green in range(0, 6):
		for red in range(0, 6):
			for blue in range(0, 6):
				print_color("████████ ", Color8(red*42, green*42, blue*42))
			new_line()
		new_line()

	prints_color("Color Table RGB", Color.ANTIQUE_WHITE)
	_color_mode = COLOR_RGB
	for green in range(0, 6):
		for red in range(0, 6):
			for blue in range(0, 6):
				print_color("████████ ", Color8(red*42, green*42, blue*42))
			new_line()
		new_line()
	_color_mode = COLOR_TABLE
	_debug_show_color_codes = false
class_name CmdOption
extends RefCounted


var _commands :PackedStringArray
var _help :String
var _description :String
var _type :int
var _arg_optional :bool = false


# constructs a command option by given arguments
# commands : a string with comma separated list of available commands begining with the short form
# help: a help text show howto use
# description: a full description of the command
# type: the argument type
# arg_optional: defines of the argument optional
func _init(p_commands :String, p_help :String, p_description :String, p_type :int = TYPE_NIL, p_arg_optional :bool = false) -> void:
	_commands = p_commands.replace(" ", "").replace("\t", "").split(",")
	_help = p_help
	_description = p_description
	_type = p_type
	_arg_optional = p_arg_optional


func commands() -> PackedStringArray:
	return _commands


func short_command() -> String:
	return _commands[0]


func help() -> String:
	return _help


func description() -> String:
	return _description


func type() -> int:
	return _type


func is_argument_optional() -> bool:
	return _arg_optional


func has_argument() -> bool:
	return _type != TYPE_NIL


func describe() -> String:
	if help().is_empty():
		return "  %-32s %s \n" % [commands(), description()]
	return "  %-32s %s \n  %-32s %s\n" % [commands(), description(), "", help()]


func _to_string() -> String:
	return describe()
class_name CmdOptions
extends RefCounted


var _default_options :Array[CmdOption]
var _advanced_options :Array[CmdOption]


func _init(p_options :Array[CmdOption] = [], p_advanced_options :Array[CmdOption] = []) -> void:
	# default help options
	_default_options = p_options
	_advanced_options = p_advanced_options


func default_options() -> Array[CmdOption]:
	return _default_options


func advanced_options() -> Array[CmdOption]:
	return _advanced_options


func options() -> Array[CmdOption]:
	return default_options() + advanced_options()


func get_option(cmd :String) -> CmdOption:
	for option in options():
		if Array(option.commands()).has(cmd):
			return option
	return null
## Small helper tool to work with Godot Arrays
class_name GdArrayTools
extends RefCounted


const max_elements := 32
const ARRAY_TYPES := [
	TYPE_ARRAY,
	TYPE_PACKED_BYTE_ARRAY,
	TYPE_PACKED_INT32_ARRAY,
	TYPE_PACKED_INT64_ARRAY,
	TYPE_PACKED_FLOAT32_ARRAY,
	TYPE_PACKED_FLOAT64_ARRAY,
	TYPE_PACKED_STRING_ARRAY,
	TYPE_PACKED_VECTOR2_ARRAY,
	TYPE_PACKED_VECTOR3_ARRAY,
	TYPE_PACKED_COLOR_ARRAY
]


static func is_array_type(value :Variant) -> bool:
	return is_type_array(typeof(value))


static func is_type_array(type :int) -> bool:
	return  type in ARRAY_TYPES


## Filters an array by given value[br]
## If the given value not an array it returns null, will remove all occurence of given value.
@warning_ignore("unsafe_method_access")
static func filter_value(array: Variant, value: Variant) -> Variant:
	if not is_array_type(array):
		return null
	var filtered_array: Variant = array.duplicate()
	var index :int = filtered_array.find(value)
	while index != -1:
		filtered_array.remove_at(index)
		index = filtered_array.find(value)
	return filtered_array


## Erases a value from given array by using equals(l,r) to find the element to erase
static func erase_value(array :Array, value :Variant) -> void:
	for element :Variant in array:
		if GdObjects.equals(element, value):
			array.erase(element)


## Scans for the array build in type on a untyped array[br]
## Returns the buildin type by scan all values and returns the type if all values has the same type.
## If the values has different types TYPE_VARIANT is returend
static func scan_typed(array :Array) -> int:
	if array.is_empty():
		return TYPE_NIL
	var actual_type := GdObjects.TYPE_VARIANT
	for value :Variant in array:
		var current_type := typeof(value)
		if not actual_type in [GdObjects.TYPE_VARIANT, current_type]:
			return GdObjects.TYPE_VARIANT
		actual_type = current_type
	return actual_type


## Converts given array into a string presentation.[br]
## This function is different to the original Godot str(<array>) implementation.
## The string presentaion contains fullquallified typed informations.
##[br]
## Examples:
## 	[codeblock]
##		# will result in PackedString(["a", "b"])
## 		GdArrayTools.as_string(PackedStringArray("a", "b"))
##		# will result in PackedString(["a", "b"])
##		GdArrayTools.as_string(PackedColorArray(Color.RED, COLOR.GREEN))
## 	[/codeblock]
static func as_string(elements: Variant, encode_value := true) -> String:
	var delemiter := ", "
	if elements == null:
		return "<null>"
	@warning_ignore("unsafe_cast")
	if (elements as Array).is_empty():
		return "<empty>"
	var prefix := _typeof_as_string(elements) if encode_value else ""
	var formatted := ""
	var index := 0
	for element :Variant in elements:
		if max_elements != -1 and index > max_elements:
			return prefix + "[" + formatted + delemiter + "...]"
		if formatted.length() > 0 :
			formatted += delemiter
		formatted += GdDefaultValueDecoder.decode(element) if encode_value else str(element)
		index += 1
	return prefix + "[" + formatted + "]"


static func has_same_content(current: Array, other: Array) -> bool:
	if current.size() != other.size(): return false
	for element: Variant in current:
		if not other.has(element): return false
		if current.count(element) != other.count(element): return false
	return true


static func _typeof_as_string(value :Variant) -> String:
	var type := typeof(value)
	# for untyped array we retun empty string
	if type == TYPE_ARRAY:
		return ""
	return GdObjects.typeof_as_string(value)
# A tool to find differences between two objects
class_name GdDiffTool
extends RefCounted


const DIV_ADD :int = 214
const DIV_SUB :int = 215


static func _diff(lb: PackedByteArray, rb: PackedByteArray, lookup: Array[Array], ldiff: Array, rdiff: Array) -> void:
	var loffset := lb.size()
	var roffset := rb.size()

	while true:
		#if last character of X and Y matches
		if loffset > 0 && roffset > 0 && lb[loffset - 1] == rb[roffset - 1]:
			loffset -= 1
			roffset -= 1
			ldiff.push_front(lb[loffset])
			rdiff.push_front(rb[roffset])
			continue
		#current character of Y is not present in X
		else: if (roffset > 0 && (loffset == 0 || lookup[loffset][roffset - 1] >= lookup[loffset - 1][roffset])):
			roffset -= 1
			ldiff.push_front(rb[roffset])
			ldiff.push_front(DIV_ADD)
			rdiff.push_front(rb[roffset])
			rdiff.push_front(DIV_SUB)
			continue
		#current character of X is not present in Y
		else: if (loffset > 0 && (roffset == 0 || lookup[loffset][roffset - 1] < lookup[loffset - 1][roffset])):
			loffset -= 1
			ldiff.push_front(lb[loffset])
			ldiff.push_front(DIV_SUB)
			rdiff.push_front(lb[loffset])
			rdiff.push_front(DIV_ADD)
			continue
		break


# lookup[i][j] stores the length of LCS of substring X[0..i-1], Y[0..j-1]
static func _createLookUp(lb: PackedByteArray, rb: PackedByteArray) -> Array[Array]:
	var lookup: Array[Array] = []
	@warning_ignore("return_value_discarded")
	lookup.resize(lb.size() + 1)
	for i in lookup.size():
		var x := []
		@warning_ignore("return_value_discarded")
		x.resize(rb.size() + 1)
		lookup[i] = x
	return lookup


static func _buildLookup(lb: PackedByteArray, rb: PackedByteArray) -> Array[Array]:
	var lookup := _createLookUp(lb, rb)
	# first column of the lookup table will be all 0
	for i in lookup.size():
		lookup[i][0] = 0
	# first row of the lookup table will be all 0
	for j :int in lookup[0].size():
		lookup[0][j] = 0

	# fill the lookup table in bottom-up manner
	for i in range(1, lookup.size()):
		for j in range(1, lookup[0].size()):
			# if current character of left and right matches
			if lb[i - 1] == rb[j - 1]:
				lookup[i][j] = lookup[i - 1][j - 1] + 1;
			# else if current character of left and right don't match
			else:
				lookup[i][j] = max(lookup[i - 1][j], lookup[i][j - 1]);
	return lookup


static func string_diff(left :Variant, right :Variant) -> Array[PackedByteArray]:
	var lb := PackedByteArray() if left == null else str(left).to_utf8_buffer()
	var rb := PackedByteArray() if right == null else str(right).to_utf8_buffer()
	var ldiff := Array()
	var rdiff := Array()
	var lookup := _buildLookup(lb, rb);
	_diff(lb, rb, lookup, ldiff, rdiff)
	return [PackedByteArray(ldiff), PackedByteArray(rdiff)]


# prototype
static func longestCommonSubsequence(text1 :String, text2 :String) -> PackedStringArray:
	var text1Words := text1.split(" ")
	var text2Words := text2.split(" ")
	var text1WordCount := text1Words.size()
	var text2WordCount := text2Words.size()
	var solutionMatrix := Array()
	for i in text1WordCount+1:
		var ar := Array()
		for n in text2WordCount+1:
			ar.append(0)
		solutionMatrix.append(ar)

	for i in range(text1WordCount-1, 0, -1):
		for j in range(text2WordCount-1, 0, -1):
			if text1Words[i] == text2Words[j]:
				solutionMatrix[i][j] = solutionMatrix[i + 1][j + 1] + 1;
			else:
				solutionMatrix[i][j] = max(solutionMatrix[i + 1][j], solutionMatrix[i][j + 1]);

	var i := 0
	var j := 0
	var lcsResultList := PackedStringArray();
	while (i < text1WordCount && j < text2WordCount):
		if text1Words[i] == text2Words[j]:
			@warning_ignore("return_value_discarded")
			lcsResultList.append(text2Words[j])
			i += 1
			j += 1
		else: if (solutionMatrix[i + 1][j] >= solutionMatrix[i][j + 1]):
			i += 1
		else:
			j += 1
	return lcsResultList


static func markTextDifferences(text1 :String, text2 :String, lcsList :PackedStringArray, insertColor :Color, deleteColor:Color) -> String:
	var stringBuffer := ""
	if text1 == null and lcsList == null:
		return stringBuffer

	var text1Words := text1.split(" ")
	var text2Words := text2.split(" ")
	var i := 0
	var j := 0
	var word1LastIndex := 0
	var word2LastIndex := 0
	for k in lcsList.size():
		while i < text1Words.size() and j < text2Words.size():
			if text1Words[i] == lcsList[k] and text2Words[j] == lcsList[k]:
				stringBuffer += "<SPAN>" + lcsList[k] + " </SPAN>"
				word1LastIndex = i + 1
				word2LastIndex = j + 1
				i = text1Words.size()
				j = text2Words.size()

			else: if text1Words[i] != lcsList[k]:
				while i < text1Words.size() and text1Words[i] != lcsList[k]:
					stringBuffer += "<SPAN style='BACKGROUND-COLOR:" + deleteColor.to_html() + "'>" + text1Words[i] + " </SPAN>"
					i += 1
			else: if text2Words[j] != lcsList[k]:
				while j < text2Words.size() and text2Words[j] != lcsList[k]:
					stringBuffer += "<SPAN style='BACKGROUND-COLOR:" + insertColor.to_html() + "'>" + text2Words[j] + " </SPAN>"
					j += 1
			i = word1LastIndex
			j = word2LastIndex

			while word1LastIndex < text1Words.size():
				stringBuffer += "<SPAN style='BACKGROUND-COLOR:" + deleteColor.to_html() + "'>" + text1Words[word1LastIndex] + " </SPAN>"
				word1LastIndex += 1
			while word2LastIndex < text2Words.size():
				stringBuffer += "<SPAN style='BACKGROUND-COLOR:" + insertColor.to_html() + "'>" + text2Words[word2LastIndex] + " </SPAN>"
				word2LastIndex += 1
	return stringBuffer
class_name GdFunctionDoubler
extends RefCounted

const DEFAULT_TYPED_RETURN_VALUES := {
	TYPE_NIL: "null",
	TYPE_BOOL: "false",
	TYPE_INT: "0",
	TYPE_FLOAT: "0.0",
	TYPE_STRING: "\"\"",
	TYPE_STRING_NAME: "&\"\"",
	TYPE_VECTOR2: "Vector2.ZERO",
	TYPE_VECTOR2I: "Vector2i.ZERO",
	TYPE_RECT2: "Rect2()",
	TYPE_RECT2I: "Rect2i()",
	TYPE_VECTOR3: "Vector3.ZERO",
	TYPE_VECTOR3I: "Vector3i.ZERO",
	TYPE_VECTOR4: "Vector4.ZERO",
	TYPE_VECTOR4I: "Vector4i.ZERO",
	TYPE_TRANSFORM2D: "Transform2D()",
	TYPE_PLANE: "Plane()",
	TYPE_QUATERNION: "Quaternion()",
	TYPE_AABB: "AABB()",
	TYPE_BASIS: "Basis()",
	TYPE_TRANSFORM3D: "Transform3D()",
	TYPE_PROJECTION: "Projection()",
	TYPE_COLOR: "Color()",
	TYPE_NODE_PATH: "NodePath()",
	TYPE_RID: "RID()",
	TYPE_OBJECT: "null",
	TYPE_CALLABLE: "Callable()",
	TYPE_SIGNAL: "Signal()",
	TYPE_DICTIONARY: "Dictionary()",
	TYPE_ARRAY: "Array()",
	TYPE_PACKED_BYTE_ARRAY: "PackedByteArray()",
	TYPE_PACKED_INT32_ARRAY: "PackedInt32Array()",
	TYPE_PACKED_INT64_ARRAY: "PackedInt64Array()",
	TYPE_PACKED_FLOAT32_ARRAY: "PackedFloat32Array()",
	TYPE_PACKED_FLOAT64_ARRAY: "PackedFloat64Array()",
	TYPE_PACKED_STRING_ARRAY: "PackedStringArray()",
	TYPE_PACKED_VECTOR2_ARRAY: "PackedVector2Array()",
	TYPE_PACKED_VECTOR3_ARRAY: "PackedVector3Array()",
	# since Godot 4.3.beta1 TYPE_PACKED_VECTOR4_ARRAY = 38
	GdObjects.TYPE_PACKED_VECTOR4_ARRAY: "PackedVector4Array()",
	TYPE_PACKED_COLOR_ARRAY: "PackedColorArray()",
	GdObjects.TYPE_VARIANT: "null",
	GdObjects.TYPE_ENUM: "0"
}

# @GlobalScript enums
# needs to manually map because of https://github.com/godotengine/godot/issues/73835
const DEFAULT_ENUM_RETURN_VALUES = {
	"Side" : "SIDE_LEFT",
	"Corner" : "CORNER_TOP_LEFT",
	"Orientation" : "HORIZONTAL",
	"ClockDirection" : "CLOCKWISE",
	"HorizontalAlignment" : "HORIZONTAL_ALIGNMENT_LEFT",
	"VerticalAlignment" : "VERTICAL_ALIGNMENT_TOP",
	"InlineAlignment" : "INLINE_ALIGNMENT_TOP_TO",
	"EulerOrder" : "EULER_ORDER_XYZ",
	"Key" : "KEY_NONE",
	"KeyModifierMask" : "KEY_CODE_MASK",
	"MouseButton" : "MOUSE_BUTTON_NONE",
	"MouseButtonMask" : "MOUSE_BUTTON_MASK_LEFT",
	"JoyButton" : "JOY_BUTTON_INVALID",
	"JoyAxis" : "JOY_AXIS_INVALID",
	"MIDIMessage" : "MIDI_MESSAGE_NONE",
	"Error" : "OK",
	"PropertyHint" : "PROPERTY_HINT_NONE",
	"Variant.Type" : "TYPE_NIL",
}

var _push_errors :String


# Determine the enum default by reflection
static func get_enum_default(value :String) -> Variant:
	var script := GDScript.new()
	script.source_code = """
	extends Resource

	static func get_enum_default() -> Variant:
		return %s.values()[0]

	""".dedent() % value
	@warning_ignore("return_value_discarded")
	script.reload()
	@warning_ignore("unsafe_method_access")
	return script.new().call("get_enum_default")


static func default_return_value(func_descriptor :GdFunctionDescriptor) -> String:
	var return_type :Variant = func_descriptor.return_type()
	if return_type == GdObjects.TYPE_ENUM:
		var enum_class := func_descriptor._return_class
		var enum_path := enum_class.split(".")
		if enum_path.size() >= 2:
			var keys := ClassDB.class_get_enum_constants(enum_path[0], enum_path[1])
			if not keys.is_empty():
				return "%s.%s" % [enum_path[0], keys[0]]
			var enum_value :Variant = get_enum_default(enum_class)
			if enum_value != null:
				return str(enum_value)
		# we need fallback for @GlobalScript enums,
		return DEFAULT_ENUM_RETURN_VALUES.get(func_descriptor._return_class, "0")
	return DEFAULT_TYPED_RETURN_VALUES.get(return_type, "invalid")


func _init(push_errors :bool = false) -> void:
	_push_errors = "true" if push_errors else "false"
	for type_key in TYPE_MAX:
		if not DEFAULT_TYPED_RETURN_VALUES.has(type_key):
			push_error("missing default definitions! Expexting %d bud is %d" % [DEFAULT_TYPED_RETURN_VALUES.size(), TYPE_MAX])
			prints("missing default definition for type", type_key)
			assert(DEFAULT_TYPED_RETURN_VALUES.has(type_key), "Missing Type default definition!")


@warning_ignore("unused_parameter")
func get_template(return_type: GdFunctionDescriptor, is_callable: bool) -> String:
	assert(false, "'get_template' must be implemented!")
	return ""


func double(func_descriptor: GdFunctionDescriptor, is_callable: bool = false) -> PackedStringArray:
	var is_static := func_descriptor.is_static()
	var is_coroutine := func_descriptor.is_coroutine()
	var func_name := func_descriptor.name()
	var args := func_descriptor.args()
	var varargs := func_descriptor.varargs()
	var return_value := GdFunctionDoubler.default_return_value(func_descriptor)
	var arg_names := extract_arg_names(args, true)
	var vararg_names := extract_arg_names(varargs)

	# save original constructor arguments
	if func_name == "_init":
		var constructor_args := ",".join(GdFunctionDoubler.extract_constructor_args(args))
		var constructor := "func _init(%s) -> void:\n	super(%s)\n	pass\n" % [constructor_args, ", ".join(arg_names)]
		return constructor.split("\n")

	var double_src := "@warning_ignore('shadowed_variable', 'untyped_declaration', 'unsafe_call_argument', 'unsafe_method_access')\n"
	if func_descriptor.is_engine():
		double_src += '@warning_ignore("native_method_override")\n'
	if func_descriptor.return_type() == GdObjects.TYPE_ENUM:
		double_src += '@warning_ignore("int_as_enum_without_match")\n'
		double_src += '@warning_ignore("int_as_enum_without_cast")\n'
	double_src += GdFunctionDoubler.extract_func_signature(func_descriptor)
	# fix to  unix format, this is need when the template is edited under windows than the template is stored with \r\n
	var func_template := get_template(func_descriptor, is_callable).replace("\r\n", "\n")
	double_src += func_template\
		.replace("$(arguments)", ", ".join(arg_names))\
		.replace("$(varargs)", ", ".join(vararg_names))\
		.replace("$(await)", GdFunctionDoubler.await_is_coroutine(is_coroutine)) \
		.replace("$(func_name)", func_name )\
		.replace("${default_return_value}", return_value)\
		.replace("$(push_errors)", _push_errors)

	if is_static:
		double_src = double_src.replace("$(instance)", "__instance().")
	else:
		double_src = double_src.replace("$(instance)", "")
	return double_src.split("\n")


func extract_arg_names(argument_signatures: Array[GdFunctionArgument], add_suffix := false) -> PackedStringArray:
	var arg_names := PackedStringArray()
	for arg in argument_signatures:
		@warning_ignore("return_value_discarded")
		arg_names.append(arg._name + ("_" if add_suffix else ""))
	return arg_names


static func extract_constructor_args(args :Array[GdFunctionArgument]) -> PackedStringArray:
	var constructor_args := PackedStringArray()
	for arg in args:
		var arg_name := arg._name + "_"
		var default_value := get_default(arg)
		if default_value == "null":
			@warning_ignore("return_value_discarded")
			constructor_args.append(arg_name + ":Variant=" + default_value)
		else:
			@warning_ignore("return_value_discarded")
			constructor_args.append(arg_name + ":=" + default_value)
	return constructor_args


static func extract_func_signature(descriptor: GdFunctionDescriptor) -> String:
	var func_signature := ""
	if descriptor._return_type == TYPE_NIL:
		func_signature = "func %s(%s) -> void:" % [descriptor.name(), typeless_args(descriptor)]
	elif descriptor._return_type == GdObjects.TYPE_VARIANT:
		func_signature = "func %s(%s):" % [descriptor.name(), typeless_args(descriptor)]
	else:
		func_signature = "func %s(%s) -> %s:" % [descriptor.name(), typeless_args(descriptor), descriptor.return_type_as_string()]
	return "static " + func_signature if descriptor.is_static() else func_signature


static func typeless_args(descriptor: GdFunctionDescriptor) -> String:
	var collect := PackedStringArray()
	for arg in descriptor.args():
		if arg.has_default():
			@warning_ignore("return_value_discarded")
			collect.push_back(arg.name() + "_" + "=" + arg.value_as_string())
		else:
			@warning_ignore("return_value_discarded")
			collect.push_back(arg.name() + "_")
	for arg in descriptor.varargs():
		@warning_ignore("return_value_discarded")
		collect.push_back(arg.name() + "=" + arg.value_as_string())
	return ", ".join(collect)


static func get_default(arg :GdFunctionArgument) -> String:
	if arg.has_default():
		return arg.value_as_string()
	else:
		return DEFAULT_TYPED_RETURN_VALUES.get(arg.type(), "null")


static func await_is_coroutine(is_coroutine :bool) -> String:
	return "await " if is_coroutine else ""
# This is a helper class to compare two objects by equals
class_name GdObjects
extends Resource

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")


# introduced with Godot 4.3.beta1
const TYPE_PACKED_VECTOR4_ARRAY = 38 #TYPE_PACKED_VECTOR4_ARRAY

const TYPE_VOID 	= 1000
const TYPE_VARARG 	= 1001
const TYPE_VARIANT	= 1002
const TYPE_FUNC 	= 1003
const TYPE_FUZZER 	= 1004
# missing Godot types
const TYPE_NODE 	= 2001
const TYPE_CONTROL	= 2002
const TYPE_CANVAS	= 2003
const TYPE_ENUM		= 2004


# used as default value for varargs
const TYPE_VARARG_PLACEHOLDER_VALUE = "__null__"


const TYPE_AS_STRING_MAPPINGS := {
	TYPE_NIL: "null",
	TYPE_BOOL: "bool",
	TYPE_INT: "int",
	TYPE_FLOAT: "float",
	TYPE_STRING: "String",
	TYPE_VECTOR2: "Vector2",
	TYPE_VECTOR2I: "Vector2i",
	TYPE_RECT2: "Rect2",
	TYPE_RECT2I: "Rect2i",
	TYPE_VECTOR3: "Vector3",
	TYPE_VECTOR3I: "Vector3i",
	TYPE_TRANSFORM2D: "Transform2D",
	TYPE_VECTOR4: "Vector4",
	TYPE_VECTOR4I: "Vector4i",
	TYPE_PLANE: "Plane",
	TYPE_QUATERNION: "Quaternion",
	TYPE_AABB: "AABB",
	TYPE_BASIS: "Basis",
	TYPE_TRANSFORM3D: "Transform3D",
	TYPE_PROJECTION: "Projection",
	TYPE_COLOR: "Color",
	TYPE_STRING_NAME: "StringName",
	TYPE_NODE_PATH: "NodePath",
	TYPE_RID: "RID",
	TYPE_OBJECT: "Object",
	TYPE_CALLABLE: "Callable",
	TYPE_SIGNAL: "Signal",
	TYPE_DICTIONARY: "Dictionary",
	TYPE_ARRAY: "Array",
	TYPE_PACKED_BYTE_ARRAY: "PackedByteArray",
	TYPE_PACKED_INT32_ARRAY: "PackedInt32Array",
	TYPE_PACKED_INT64_ARRAY: "PackedInt64Array",
	TYPE_PACKED_FLOAT32_ARRAY: "PackedFloat32Array",
	TYPE_PACKED_FLOAT64_ARRAY: "PackedFloat64Array",
	TYPE_PACKED_STRING_ARRAY: "PackedStringArray",
	TYPE_PACKED_VECTOR2_ARRAY: "PackedVector2Array",
	TYPE_PACKED_VECTOR3_ARRAY: "PackedVector3Array",
	TYPE_PACKED_VECTOR4_ARRAY: "PackedVector4Array",
	TYPE_PACKED_COLOR_ARRAY: "PackedColorArray",
	TYPE_VOID: "void",
	TYPE_VARARG: "VarArg",
	TYPE_FUNC: "Func",
	TYPE_FUZZER: "Fuzzer",
	TYPE_VARIANT: "Variant"
}


const NOTIFICATION_AS_STRING_MAPPINGS := {
	TYPE_OBJECT: {
		Object.NOTIFICATION_POSTINITIALIZE : "POSTINITIALIZE",
		Object.NOTIFICATION_PREDELETE: "PREDELETE",
		EditorSettings.NOTIFICATION_EDITOR_SETTINGS_CHANGED: "EDITOR_SETTINGS_CHANGED",
	},
	TYPE_NODE: {
		Node.NOTIFICATION_ENTER_TREE : "ENTER_TREE",
		Node.NOTIFICATION_EXIT_TREE: "EXIT_TREE",
		Node.NOTIFICATION_CHILD_ORDER_CHANGED: "CHILD_ORDER_CHANGED",
		Node.NOTIFICATION_READY: "READY",
		Node.NOTIFICATION_PAUSED: "PAUSED",
		Node.NOTIFICATION_UNPAUSED: "UNPAUSED",
		Node.NOTIFICATION_PHYSICS_PROCESS: "PHYSICS_PROCESS",
		Node.NOTIFICATION_PROCESS: "PROCESS",
		Node.NOTIFICATION_PARENTED: "PARENTED",
		Node.NOTIFICATION_UNPARENTED: "UNPARENTED",
		Node.NOTIFICATION_SCENE_INSTANTIATED: "INSTANCED",
		Node.NOTIFICATION_DRAG_BEGIN: "DRAG_BEGIN",
		Node.NOTIFICATION_DRAG_END: "DRAG_END",
		Node.NOTIFICATION_PATH_RENAMED: "PATH_CHANGED",
		Node.NOTIFICATION_INTERNAL_PROCESS: "INTERNAL_PROCESS",
		Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS: "INTERNAL_PHYSICS_PROCESS",
		Node.NOTIFICATION_POST_ENTER_TREE: "POST_ENTER_TREE",
		Node.NOTIFICATION_WM_MOUSE_ENTER: "WM_MOUSE_ENTER",
		Node.NOTIFICATION_WM_MOUSE_EXIT: "WM_MOUSE_EXIT",
		Node.NOTIFICATION_APPLICATION_FOCUS_IN: "WM_FOCUS_IN",
		Node.NOTIFICATION_APPLICATION_FOCUS_OUT: "WM_FOCUS_OUT",
		#Node.NOTIFICATION_WM_QUIT_REQUEST: "WM_QUIT_REQUEST",
		Node.NOTIFICATION_WM_GO_BACK_REQUEST: "WM_GO_BACK_REQUEST",
		Node.NOTIFICATION_WM_WINDOW_FOCUS_OUT: "WM_UNFOCUS_REQUEST",
		Node.NOTIFICATION_OS_MEMORY_WARNING: "OS_MEMORY_WARNING",
		Node.NOTIFICATION_TRANSLATION_CHANGED: "TRANSLATION_CHANGED",
		Node.NOTIFICATION_WM_ABOUT: "WM_ABOUT",
		Node.NOTIFICATION_CRASH: "CRASH",
		Node.NOTIFICATION_OS_IME_UPDATE: "OS_IME_UPDATE",
		Node.NOTIFICATION_APPLICATION_RESUMED: "APP_RESUMED",
		Node.NOTIFICATION_APPLICATION_PAUSED: "APP_PAUSED",
		Node3D.NOTIFICATION_TRANSFORM_CHANGED: "TRANSFORM_CHANGED",
		Node3D.NOTIFICATION_ENTER_WORLD: "ENTER_WORLD",
		Node3D.NOTIFICATION_EXIT_WORLD: "EXIT_WORLD",
		Node3D.NOTIFICATION_VISIBILITY_CHANGED: "VISIBILITY_CHANGED",
		Skeleton3D.NOTIFICATION_UPDATE_SKELETON: "UPDATE_SKELETON",
		CanvasItem.NOTIFICATION_DRAW: "DRAW",
		CanvasItem.NOTIFICATION_VISIBILITY_CHANGED: "VISIBILITY_CHANGED",
		CanvasItem.NOTIFICATION_ENTER_CANVAS: "ENTER_CANVAS",
		CanvasItem.NOTIFICATION_EXIT_CANVAS: "EXIT_CANVAS",
		#Popup.NOTIFICATION_POST_POPUP: "POST_POPUP",
		#Popup.NOTIFICATION_POPUP_HIDE: "POPUP_HIDE",
	},
	TYPE_CONTROL : {
		Object.NOTIFICATION_PREDELETE: "PREDELETE",
		Container.NOTIFICATION_SORT_CHILDREN: "SORT_CHILDREN",
		Control.NOTIFICATION_RESIZED: "RESIZED",
		Control.NOTIFICATION_MOUSE_ENTER: "MOUSE_ENTER",
		Control.NOTIFICATION_MOUSE_EXIT: "MOUSE_EXIT",
		Control.NOTIFICATION_FOCUS_ENTER: "FOCUS_ENTER",
		Control.NOTIFICATION_FOCUS_EXIT: "FOCUS_EXIT",
		Control.NOTIFICATION_THEME_CHANGED: "THEME_CHANGED",
		#Control.NOTIFICATION_MODAL_CLOSE: "MODAL_CLOSE",
		Control.NOTIFICATION_SCROLL_BEGIN: "SCROLL_BEGIN",
		Control.NOTIFICATION_SCROLL_END: "SCROLL_END",
	}
}


enum COMPARE_MODE {
	OBJECT_REFERENCE,
	PARAMETER_DEEP_TEST
}


# prototype of better object to dictionary
@warning_ignore("unsafe_cast")
static func obj2dict(obj: Object, hashed_objects := Dictionary()) -> Dictionary:
	if obj == null:
		return {}
	var clazz_name := obj.get_class()
	var dict := Dictionary()
	var clazz_path := ""

	if is_instance_valid(obj) and obj.get_script() != null:
		var script: Script = obj.get_script()
		# handle build-in scripts
		if script.resource_path != null and script.resource_path.contains(".tscn"):
			var path_elements := script.resource_path.split(".tscn")
			clazz_name = path_elements[0].get_file()
			clazz_path = script.resource_path
		else:
			var d := inst_to_dict(obj)
			clazz_path = d["@path"]
			if d["@subpath"] != NodePath(""):
				clazz_name = d["@subpath"]
				dict["@inner_class"] = true
			else:
				clazz_name = clazz_path.get_file().replace(".gd", "")
	dict["@path"] = clazz_path

	for property in obj.get_property_list():
		var property_name :String = property["name"]
		var property_type :int = property["type"]
		var property_value :Variant = obj.get(property_name)
		if property_value is GDScript or property_value is Callable or property_value is RegEx:
			continue
		if (property["usage"] & PROPERTY_USAGE_SCRIPT_VARIABLE|PROPERTY_USAGE_DEFAULT
			and not property["usage"] & PROPERTY_USAGE_CATEGORY
			and not property["usage"] == 0):
			if property_type == TYPE_OBJECT:
				# prevent recursion
				if hashed_objects.has(obj):
					dict[property_name] = str(property_value)
					continue
				hashed_objects[obj] = true
				dict[property_name] = obj2dict(property_value as Object, hashed_objects)
			else:
				dict[property_name] = property_value
	if obj is Node:
		var childrens :Array = (obj as Node).get_children()
		dict["childrens"] = childrens.map(func (child :Object) -> Dictionary: return obj2dict(child, hashed_objects))
	if obj is TreeItem:
		var childrens :Array = (obj as TreeItem).get_children()
		dict["childrens"] = childrens.map(func (child :Object) -> Dictionary: return obj2dict(child, hashed_objects))

	return {"%s" % clazz_name : dict}


static func equals(obj_a :Variant, obj_b :Variant, case_sensitive :bool = false, compare_mode :COMPARE_MODE = COMPARE_MODE.PARAMETER_DEEP_TEST) -> bool:
	return _equals(obj_a, obj_b, case_sensitive, compare_mode, [], 0)


static func equals_sorted(obj_a: Array[Variant], obj_b: Array[Variant], case_sensitive: bool = false, compare_mode: COMPARE_MODE = COMPARE_MODE.PARAMETER_DEEP_TEST) -> bool:
	var a: Array[Variant] = obj_a.duplicate()
	var b: Array[Variant] = obj_b.duplicate()
	a.sort()
	b.sort()
	return equals(a, b, case_sensitive, compare_mode)


@warning_ignore("unsafe_method_access", "unsafe_cast")
static func _equals(obj_a :Variant, obj_b :Variant, case_sensitive :bool, compare_mode :COMPARE_MODE, deep_stack :Array, stack_depth :int ) -> bool:
	var type_a := typeof(obj_a)
	var type_b := typeof(obj_b)
	if stack_depth > 32:
		prints("stack_depth", stack_depth, deep_stack)
		push_error("GdUnit equals has max stack deep reached!")
		return false

	# use argument matcher if requested
	if is_instance_valid(obj_a) and obj_a is GdUnitArgumentMatcher:
		return (obj_a as GdUnitArgumentMatcher).is_match(obj_b)
	if is_instance_valid(obj_b) and obj_b is GdUnitArgumentMatcher:
		return (obj_b as GdUnitArgumentMatcher).is_match(obj_a)

	stack_depth += 1
	# fast fail is different types
	if not _is_type_equivalent(type_a, type_b):
		return false
	# is same instance
	if obj_a == obj_b:
		return true
	# handle null values
	if obj_a == null and obj_b != null:
		return false
	if obj_b == null and obj_a != null:
		return false

	match type_a:
		TYPE_OBJECT:
			if deep_stack.has(obj_a) or deep_stack.has(obj_b):
				return true
			deep_stack.append(obj_a)
			deep_stack.append(obj_b)
			if compare_mode == COMPARE_MODE.PARAMETER_DEEP_TEST:
				# fail fast
				if not is_instance_valid(obj_a) or not is_instance_valid(obj_b):
					return false
				if obj_a.get_class() != obj_b.get_class():
					return false
				var a := obj2dict(obj_a as Object)
				var b := obj2dict(obj_b as Object)
				return _equals(a, b, case_sensitive, compare_mode, deep_stack, stack_depth)
			return obj_a == obj_b

		TYPE_ARRAY:
			if obj_a.size() != obj_b.size():
				return false
			for index :int in obj_a.size():
				if not _equals(obj_a[index], obj_b[index], case_sensitive, compare_mode, deep_stack, stack_depth):
					return false
			return true

		TYPE_DICTIONARY:
			if obj_a.size() != obj_b.size():
				return false
			for key :Variant in obj_a.keys():
				var value_a :Variant = obj_a[key] if obj_a.has(key) else null
				var value_b :Variant = obj_b[key] if obj_b.has(key) else null
				if not _equals(value_a, value_b, case_sensitive, compare_mode, deep_stack, stack_depth):
					return false
			return true

		TYPE_STRING:
			if case_sensitive:
				return obj_a.to_lower() == obj_b.to_lower()
			else:
				return obj_a == obj_b
	return obj_a == obj_b


@warning_ignore("shadowed_variable_base_class")
static func notification_as_string(instance :Variant, notification :int) -> String:
	var error := "Unknown notification: '%s' at instance:  %s" % [notification, instance]
	if instance is Node and NOTIFICATION_AS_STRING_MAPPINGS[TYPE_NODE].has(notification):
		return NOTIFICATION_AS_STRING_MAPPINGS[TYPE_NODE].get(notification, error)
	if instance is Control and NOTIFICATION_AS_STRING_MAPPINGS[TYPE_CONTROL].has(notification):
		return NOTIFICATION_AS_STRING_MAPPINGS[TYPE_CONTROL].get(notification, error)
	return NOTIFICATION_AS_STRING_MAPPINGS[TYPE_OBJECT].get(notification, error)


static func string_to_type(value :String) -> int:
	for type :int in TYPE_AS_STRING_MAPPINGS.keys():
		if TYPE_AS_STRING_MAPPINGS.get(type) == value:
			return type
	return TYPE_NIL


static func to_camel_case(value :String) -> String:
	var p := to_pascal_case(value)
	if not p.is_empty():
		p[0] = p[0].to_lower()
	return p


static func to_pascal_case(value :String) -> String:
	return value.capitalize().replace(" ", "")


@warning_ignore("return_value_discarded")
static func to_snake_case(value :String) -> String:
	var result := PackedStringArray()
	for ch in value:
		var lower_ch := ch.to_lower()
		if ch != lower_ch and result.size() > 1:
			result.append('_')
		result.append(lower_ch)
	return ''.join(result)


static func is_snake_case(value :String) -> bool:
	for ch in value:
		if ch == '_':
			continue
		if ch == ch.to_upper():
			return false
	return true


static func type_as_string(type :int) -> String:
	if type < TYPE_MAX:
		return type_string(type)
	return TYPE_AS_STRING_MAPPINGS.get(type, "Variant")


static func typeof_as_string(value :Variant) -> String:
	return TYPE_AS_STRING_MAPPINGS.get(typeof(value), "Unknown type")


static func all_types() -> PackedInt32Array:
	return PackedInt32Array(TYPE_AS_STRING_MAPPINGS.keys())


static func string_as_typeof(type_name :String) -> int:
	var type :Variant = TYPE_AS_STRING_MAPPINGS.find_key(type_name)
	return type if type != null else TYPE_VARIANT


static func is_primitive_type(value :Variant) -> bool:
	return typeof(value) in [TYPE_BOOL, TYPE_STRING, TYPE_STRING_NAME, TYPE_INT, TYPE_FLOAT]


static func _is_type_equivalent(type_a :int, type_b :int) -> bool:
	# don't test for TYPE_STRING_NAME equivalenz
	if type_a == TYPE_STRING_NAME or type_b == TYPE_STRING_NAME:
		return true
	if GdUnitSettings.is_strict_number_type_compare():
		return type_a == type_b
	return (
		(type_a == TYPE_FLOAT and type_b == TYPE_INT)
		or (type_a == TYPE_INT and type_b == TYPE_FLOAT)
		or type_a == type_b)


static func is_engine_type(value :Variant) -> bool:
	if value is GDScript or value is ScriptExtension:
		return false
	var obj: Object = value
	if is_instance_valid(obj) and obj.has_method("is_class"):
		return obj.is_class("GDScriptNativeClass")
	return false


static func is_type(value :Variant) -> bool:
	# is an build-in type
	if typeof(value) != TYPE_OBJECT:
		return false
	# is a engine class type
	if is_engine_type(value):
		return true
	# is a custom class type
	@warning_ignore("unsafe_cast")
	if value is GDScript and (value as GDScript).can_instantiate():
		return true
	return false


static func _is_same(left :Variant, right :Variant) -> bool:
	var left_type := -1 if left == null else typeof(left)
	var right_type := -1 if right == null else typeof(right)

	# if typ different can't be the same
	if left_type != right_type:
		return false
	if left_type == TYPE_OBJECT and right_type == TYPE_OBJECT:
		@warning_ignore("unsafe_cast")
		return (left as Object).get_instance_id() == (right as Object).get_instance_id()
	return equals(left, right)


static func is_object(value :Variant) -> bool:
	return typeof(value) == TYPE_OBJECT


static func is_script(value :Variant) -> bool:
	return is_object(value) and value is Script


static func is_test_suite(script :Script) -> bool:
	return is_gd_testsuite(script) or GdUnit4CSharpApiLoader.is_test_suite(script.resource_path)


static func is_native_class(value :Variant) -> bool:
	return is_object(value) and is_engine_type(value)


static func is_scene(value :Variant) -> bool:
	return is_object(value) and value is PackedScene


static func is_scene_resource_path(value :Variant) -> bool:
	@warning_ignore("unsafe_cast")
	return value is String and (value as String).ends_with(".tscn")


static func is_gd_script(script :Script) -> bool:
	return script is GDScript


static func is_cs_script(script :Script) -> bool:
	# we need to check by stringify name because checked non mono Godot the class CSharpScript is not available
	return str(script).find("CSharpScript") != -1


static func is_gd_testsuite(script :Script) -> bool:
	if is_gd_script(script):
		var stack := [script]
		while not stack.is_empty():
			var current: Script = stack.pop_front()
			var base: Script = current.get_base_script()
			if base != null:
				if base.resource_path.find("GdUnitTestSuite") != -1:
					return true
				stack.push_back(base)
	return false


static func is_singleton(value: Variant) -> bool:
	if not is_instance_valid(value) or is_native_class(value):
		return false
	for name in Engine.get_singleton_list():
		@warning_ignore("unsafe_cast")
		if (value as Object).is_class(name):
			return true
	return false


static func is_instance(value :Variant) -> bool:
	if not is_instance_valid(value) or is_native_class(value):
		return false
	@warning_ignore("unsafe_cast")
	if is_script(value) and (value as Script).get_instance_base_type() == "":
		return true
	if is_scene(value):
		return true
	@warning_ignore("unsafe_cast")
	return not (value as Object).has_method('new') and not (value as Object).has_method('instance')


# only object form type Node and attached filename
static func is_instance_scene(instance :Variant) -> bool:
	if instance is Node:
		var node: Node = instance
		return node.get_scene_file_path() != null and not node.get_scene_file_path().is_empty()
	return false


static func can_be_instantiate(obj :Variant) -> bool:
	if not obj or is_engine_type(obj):
		return false
	@warning_ignore("unsafe_cast")
	return (obj as Object).has_method("new")


static func create_instance(clazz :Variant) -> GdUnitResult:
	match typeof(clazz):
		TYPE_OBJECT:
			# test is given clazz already an instance
			if is_instance(clazz):
				return GdUnitResult.success(clazz)
			@warning_ignore("unsafe_method_access")
			return GdUnitResult.success(clazz.new())
		TYPE_STRING:
			var clazz_name: String = clazz
			if ClassDB.class_exists(clazz_name):
				if Engine.has_singleton(clazz_name):
					return GdUnitResult.error("Not allowed to create a instance for singelton '%s'." % clazz_name)
				if not ClassDB.can_instantiate(clazz_name):
					return  GdUnitResult.error("Can't instance Engine class '%s'." % clazz_name)
				return GdUnitResult.success(ClassDB.instantiate(clazz_name))
			else:
				var clazz_path :String = extract_class_path(clazz_name)[0]
				if not FileAccess.file_exists(clazz_path):
					return GdUnitResult.error("Class '%s' not found." % clazz_name)
				var script: GDScript = load(clazz_path)
				if script != null:
					return GdUnitResult.success(script.new())
				else:
					return GdUnitResult.error("Can't create instance for '%s'." % clazz_name)
	return GdUnitResult.error("Can't create instance for class '%s'." % str(clazz))


@warning_ignore("return_value_discarded")
static func extract_class_path(clazz :Variant) -> PackedStringArray:
	var clazz_path := PackedStringArray()
	if clazz is String:
		@warning_ignore("unsafe_cast")
		clazz_path.append(clazz as String)
		return clazz_path
	if is_instance(clazz):
		# is instance a script instance?
		var script: GDScript = clazz.script
		if script != null:
			return extract_class_path(script)
		return clazz_path

	if clazz is GDScript:
		var script: GDScript = clazz
		if not script.resource_path.is_empty():
			clazz_path.append(script.resource_path)
			return clazz_path
		# if not found we go the expensive way and extract the path form the script by creating an instance
		var arg_list := build_function_default_arguments(script, "_init")
		var instance: Object = script.callv("new", arg_list)
		var clazz_info := inst_to_dict(instance)
		GdUnitTools.free_instance(instance)
		@warning_ignore("unsafe_cast")
		clazz_path.append(clazz_info["@path"] as String)
		if clazz_info.has("@subpath"):
			var sub_path :String = clazz_info["@subpath"]
			if not sub_path.is_empty():
				var sub_paths := sub_path.split("/")
				clazz_path += sub_paths
		return clazz_path
	return clazz_path


static func extract_class_name_from_class_path(clazz_path :PackedStringArray) -> String:
	var base_clazz := clazz_path[0]
	# return original class name if engine class
	if ClassDB.class_exists(base_clazz):
		return base_clazz
	var clazz_name := to_pascal_case(base_clazz.get_basename().get_file())
	for path_index in range(1, clazz_path.size()):
		clazz_name += "." + clazz_path[path_index]
	return  clazz_name


static func extract_class_name(clazz :Variant) -> GdUnitResult:
	if clazz == null:
		return GdUnitResult.error("Can't extract class name form a null value.")

	if is_instance(clazz):
		# is instance a script instance?
		var script: GDScript = clazz.script
		if script != null:
			return extract_class_name(script)
		@warning_ignore("unsafe_cast")
		return GdUnitResult.success((clazz as Object).get_class())

	# extract name form full qualified class path
	if clazz is String:
		var clazz_name: String = clazz
		if ClassDB.class_exists(clazz_name):
			return GdUnitResult.success(clazz_name)
		var source_script :GDScript = load(clazz_name)
		clazz_name = GdScriptParser.new().get_class_name(source_script)
		return GdUnitResult.success(to_pascal_case(clazz_name))

	if is_primitive_type(clazz):
		return GdUnitResult.error("Can't extract class name for an primitive '%s'" % type_as_string(typeof(clazz)))

	if is_script(clazz):
		@warning_ignore("unsafe_cast")
		if (clazz as Script).resource_path.is_empty():
			var class_path := extract_class_name_from_class_path(extract_class_path(clazz))
			return GdUnitResult.success(class_path);
		return extract_class_name(clazz.resource_path)

	# need to create an instance for a class typ the extract the class name
	@warning_ignore("unsafe_method_access")
	var instance :Variant = clazz.new()
	if instance == null:
		return GdUnitResult.error("Can't create a instance for class '%s'" % str(clazz))
	var result := extract_class_name(instance)
	@warning_ignore("return_value_discarded")
	GdUnitTools.free_instance(instance)
	return result


static func extract_inner_clazz_names(clazz_name :String, script_path :PackedStringArray) -> PackedStringArray:
	var inner_classes := PackedStringArray()

	if ClassDB.class_exists(clazz_name):
		return inner_classes
	var script :GDScript = load(script_path[0])
	var map := script.get_script_constant_map()
	for key :String in map.keys():
		var value :Variant = map.get(key)
		if value is GDScript:
			var class_path := extract_class_path(value)
			@warning_ignore("return_value_discarded")
			inner_classes.append(class_path[1])
	return inner_classes


static func extract_class_functions(clazz_name :String, script_path :PackedStringArray) -> Array:
	if ClassDB.class_get_method_list(clazz_name):
		return ClassDB.class_get_method_list(clazz_name)

	if not FileAccess.file_exists(script_path[0]):
		return Array()
	var script :GDScript = load(script_path[0])
	if script is GDScript:
		# if inner class on class path we have to load the script from the script_constant_map
		if script_path.size() == 2 and script_path[1] != "":
			var inner_classes := script_path[1]
			var map := script.get_script_constant_map()
			script = map[inner_classes]
		var clazz_functions :Array = script.get_method_list()
		var base_clazz :String = script.get_instance_base_type()
		if base_clazz:
			return extract_class_functions(base_clazz, script_path)
		return clazz_functions
	return Array()


# scans all registert script classes for given <clazz_name>
# if the class is public in the global space than return true otherwise false
# public class means the script class is defined by 'class_name <name>'
static func is_public_script_class(clazz_name :String) -> bool:
	var script_classes:Array[Dictionary] = ProjectSettings.get_global_class_list()
	for class_info in script_classes:
		if class_info.has("class"):
			if class_info["class"] == clazz_name:
				return true
	return false


static func build_function_default_arguments(script :GDScript, func_name :String) -> Array:
	var arg_list := Array()
	for func_sig in script.get_script_method_list():
		if func_sig["name"] == func_name:
			var args :Array[Dictionary] = func_sig["args"]
			for arg in args:
				var value_type :int = arg["type"]
				var default_value :Variant = default_value_by_type(value_type)
				arg_list.append(default_value)
			return arg_list
	return arg_list


static func default_value_by_type(type :int) -> Variant:
	assert(type < TYPE_MAX)
	assert(type >= 0)

	match type:
		TYPE_NIL: return null
		TYPE_BOOL: return false
		TYPE_INT: return 0
		TYPE_FLOAT: return 0.0
		TYPE_STRING: return ""
		TYPE_VECTOR2: return Vector2.ZERO
		TYPE_VECTOR2I: return Vector2i.ZERO
		TYPE_VECTOR3: return Vector3.ZERO
		TYPE_VECTOR3I: return Vector3i.ZERO
		TYPE_VECTOR4: return Vector4.ZERO
		TYPE_VECTOR4I: return Vector4i.ZERO
		TYPE_RECT2: return Rect2()
		TYPE_RECT2I: return Rect2i()
		TYPE_TRANSFORM2D: return Transform2D()
		TYPE_PLANE: return Plane()
		TYPE_QUATERNION: return Quaternion()
		TYPE_AABB: return AABB()
		TYPE_BASIS: return Basis()
		TYPE_TRANSFORM3D: return Transform3D()
		TYPE_COLOR: return Color()
		TYPE_NODE_PATH: return NodePath()
		TYPE_RID: return RID()
		TYPE_OBJECT: return null
		TYPE_CALLABLE: return Callable()
		TYPE_ARRAY: return []
		TYPE_DICTIONARY: return {}
		TYPE_PACKED_BYTE_ARRAY: return PackedByteArray()
		TYPE_PACKED_COLOR_ARRAY: return PackedColorArray()
		TYPE_PACKED_INT32_ARRAY: return PackedInt32Array()
		TYPE_PACKED_INT64_ARRAY: return PackedInt64Array()
		TYPE_PACKED_FLOAT32_ARRAY: return PackedFloat32Array()
		TYPE_PACKED_FLOAT64_ARRAY: return PackedFloat64Array()
		TYPE_PACKED_STRING_ARRAY: return PackedStringArray()
		TYPE_PACKED_VECTOR2_ARRAY: return PackedVector2Array()
		TYPE_PACKED_VECTOR3_ARRAY: return PackedVector3Array()

	push_error("Can't determine a default value for type: '%s', Please create a Bug issue and attach the stacktrace please." % type)
	return null


static func find_nodes_by_class(root: Node, cls: String, recursive: bool = false) -> Array[Node]:
	if not recursive:
		return _find_nodes_by_class_no_rec(root, cls)
	return _find_nodes_by_class(root, cls)


static func _find_nodes_by_class_no_rec(parent: Node, cls: String) -> Array[Node]:
	var result :Array[Node] = []
	for ch in parent.get_children():
		if ch.get_class() == cls:
			result.append(ch)
	return result


static func _find_nodes_by_class(root: Node, cls: String) -> Array[Node]:
	var result :Array[Node] = []
	var stack  :Array[Node] = [root]
	while stack:
		var node :Node = stack.pop_back()
		if node.get_class() == cls:
			result.append(node)
		for ch in node.get_children():
			stack.push_back(ch)
	return result
class_name GdUnit4Version
extends RefCounted

const VERSION_PATTERN = "[center][color=#9887c4]gd[/color][color=#7a57d6]Unit[/color][color=#9887c4]4[/color] [color=#9887c4]${version}[/color][/center]"

var _major :int
var _minor :int
var _patch :int


func _init(major :int, minor :int, patch :int) -> void:
	_major = major
	_minor = minor
	_patch = patch


static func parse(value :String) -> GdUnit4Version:
	var regex := RegEx.new()
	@warning_ignore("return_value_discarded")
	regex.compile("[a-zA-Z:,-]+")
	var cleaned := regex.sub(value, "", true)
	var parts := cleaned.split(".")
	var major := parts[0].to_int()
	var minor := parts[1].to_int()
	var patch := parts[2].to_int() if parts.size() > 2 else 0
	return GdUnit4Version.new(major, minor, patch)


static func current() -> GdUnit4Version:
	var config := ConfigFile.new()
	@warning_ignore("return_value_discarded")
	config.load('addons/gdUnit4/plugin.cfg')
	@warning_ignore("unsafe_cast")
	return parse(config.get_value('plugin', 'version') as String)


func equals(other :GdUnit4Version) -> bool:
	return _major == other._major and _minor == other._minor and _patch == other._patch


func is_greater(other :GdUnit4Version) -> bool:
	if _major > other._major:
		return true
	if _major == other._major and _minor > other._minor:
		return true
	return _major == other._major and _minor == other._minor and _patch > other._patch


static func init_version_label(label :Control) -> void:
	var config := ConfigFile.new()
	@warning_ignore("return_value_discarded")
	config.load('addons/gdUnit4/plugin.cfg')
	var version :String = config.get_value('plugin', 'version')
	if label is RichTextLabel:
		(label as RichTextLabel).text = VERSION_PATTERN.replace('${version}', version)
	else:
		(label as Label).text = "gdUnit4 " + version


func _to_string() -> String:
	return "v%d.%d.%d" % [_major, _minor, _patch]
# A class doubler used to mock and spy checked implementations
class_name GdUnitClassDoubler
extends RefCounted


const DOUBLER_INSTANCE_ID_PREFIX := "gdunit_doubler_instance_id_"
const DOUBLER_TEMPLATE :GDScript = preload("res://addons/gdUnit4/src/core/GdUnitObjectInteractionsTemplate.gd")
const EXCLUDE_VIRTUAL_FUNCTIONS = [
	# we have to exclude notifications because NOTIFICATION_PREDELETE is try
	# to delete already freed spy/mock resources and will result in a conflict
	"_notification",
	# https://github.com/godotengine/godot/issues/67461
	"get_name",
	"get_path",
	"duplicate",
	]
# define functions to be exclude when spy or mock checked a scene
const EXLCUDE_SCENE_FUNCTIONS = [
	# needs to exclude get/set script functions otherwise it endsup in recursive endless loop
	"set_script",
	"get_script",
	# needs to exclude otherwise verify fails checked collection arguments checked calling to string
	"_to_string",
]
const EXCLUDE_FUNCTIONS = ["new", "free", "get_instance_id", "get_tree"]


static func check_leaked_instances() -> void:
	## we check that all registered spy/mock instances are removed from the engine meta data
	for key in Engine.get_meta_list():
		if key.begins_with(DOUBLER_INSTANCE_ID_PREFIX):
			var instance :Variant = Engine.get_meta(key)
			push_error("GdUnit internal error: an spy/mock instance '%s', class:'%s' is not removed from the engine and will lead in a leaked instance!" % [instance, instance.__SOURCE_CLASS])


# loads the doubler template
# class_info = { "class_name": <>, "class_path" : <>}
static func load_template(template :String, class_info :Dictionary, instance :Object) -> PackedStringArray:
	# store instance id
	var clazz_name: String = class_info.get("class_name")
	var source_code := template\
		.replace("${instance_id}", "%s%d" % [DOUBLER_INSTANCE_ID_PREFIX, abs(instance.get_instance_id())])\
		.replace("${source_class}", clazz_name)
	var lines := GdScriptParser.to_unix_format(source_code).split("\n")
	# replace template class_name with Doubled<class> name and extends form source class
	@warning_ignore("return_value_discarded")
	lines.insert(0, "class_name Doubled%s" % clazz_name.replace(".", "_"))
	@warning_ignore("return_value_discarded")
	lines.insert(1, extends_clazz(class_info))
	# append Object interactions stuff
	lines.append_array(GdScriptParser.to_unix_format(DOUBLER_TEMPLATE.source_code).split("\n"))
	return lines


static func extends_clazz(class_info :Dictionary) -> String:
	var clazz_name :String = class_info.get("class_name")
	var clazz_path :PackedStringArray = class_info.get("class_path", [])
	# is inner class?
	if clazz_path.size() > 1:
		return "extends %s" % clazz_name
	if clazz_path.size() == 1 and clazz_path[0].ends_with(".gd"):
		return "extends '%s'" % clazz_path[0]
	return "extends %s" % clazz_name


# double all functions of given instance
static func double_functions(instance :Object, clazz_name :String, clazz_path :PackedStringArray, func_doubler: GdFunctionDoubler, exclude_functions :Array) -> PackedStringArray:
	var doubled_source := PackedStringArray()
	var parser := GdScriptParser.new()
	var exclude_override_functions := EXCLUDE_VIRTUAL_FUNCTIONS + EXCLUDE_FUNCTIONS + exclude_functions
	var functions := Array()

	# double script functions
	if not ClassDB.class_exists(clazz_name):
		var result := parser.parse(clazz_name, clazz_path)
		if result.is_error():
			push_error(result.error_message())
			return PackedStringArray()
		var class_descriptor :GdClassDescriptor = result.value()
		for func_descriptor in class_descriptor.functions():
			if instance != null and not instance.has_method(func_descriptor.name()):
				#prints("no virtual func implemented",clazz_name, func_descriptor.name() )
				continue
			if functions.has(func_descriptor.name()) or exclude_override_functions.has(func_descriptor.name()):
				continue
			doubled_source += func_doubler.double(func_descriptor, instance is CallableDoubler)
			functions.append(func_descriptor.name())

	# double regular class functions
	var clazz_functions := GdObjects.extract_class_functions(clazz_name, clazz_path)
	for method : Dictionary in clazz_functions:
		var func_descriptor := GdFunctionDescriptor.extract_from(method)
		# exclude private core functions
		if func_descriptor.is_private():
			continue
		if functions.has(func_descriptor.name()) or exclude_override_functions.has(func_descriptor.name()):
			continue
		# GD-110: Hotfix do not double invalid engine functions
		if is_invalid_method_descriptior(method):
			#prints("'%s': invalid method descriptor found! %s" % [clazz_name, method])
			continue
		# do not double on not implemented virtual functions
		if instance != null and not instance.has_method(func_descriptor.name()):
			#prints("no virtual func implemented",clazz_name, func_descriptor.name() )
			continue
		functions.append(func_descriptor.name())
		doubled_source.append_array(func_doubler.double(func_descriptor, instance is CallableDoubler))
	return doubled_source


# GD-110
static func is_invalid_method_descriptior(method :Dictionary) -> bool:
	var return_info :Dictionary = method["return"]
	var type :int = return_info["type"]
	var usage :int = return_info["usage"]
	var clazz_name :String = return_info["class_name"]
	# is method returning a type int with a given 'class_name' we have an enum
	# and the PROPERTY_USAGE_CLASS_IS_ENUM must be set
	if type == TYPE_INT and not clazz_name.is_empty() and not (usage & PROPERTY_USAGE_CLASS_IS_ENUM):
		return true
	if clazz_name == "Variant.Type":
		return true
	return false
class_name GdUnitFileAccess
extends RefCounted

const GDUNIT_TEMP := "user://tmp"


static func current_dir() -> String:
	return ProjectSettings.globalize_path("res://")


static func clear_tmp() -> void:
	delete_directory(GDUNIT_TEMP)


# Creates a new file under
static func create_temp_file(relative_path :String, file_name :String, mode := FileAccess.WRITE) -> FileAccess:
	var file_path := create_temp_dir(relative_path) + "/" + file_name
	var file := FileAccess.open(file_path, mode)
	if file == null:
		push_error("Error creating temporary file at: %s, %s" % [file_path, error_string(FileAccess.get_open_error())])
	return file


static func temp_dir() -> String:
	if not DirAccess.dir_exists_absolute(GDUNIT_TEMP):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(GDUNIT_TEMP)
	return GDUNIT_TEMP


static func create_temp_dir(folder_name :String) -> String:
	var new_folder := temp_dir() + "/" + folder_name
	if not DirAccess.dir_exists_absolute(new_folder):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(new_folder)
	return new_folder


static func copy_file(from_file :String, to_dir :String) -> GdUnitResult:
	var dir := DirAccess.open(to_dir)
	if dir != null:
		var to_file := to_dir + "/" + from_file.get_file()
		prints("Copy %s to %s" % [from_file, to_file])
		var error := dir.copy(from_file, to_file)
		if error != OK:
			return GdUnitResult.error("Can't copy file form '%s' to '%s'. Error: '%s'" % [from_file, to_file, error_string(error)])
		return GdUnitResult.success(to_file)
	return GdUnitResult.error("Directory not found: " + to_dir)


static func copy_directory(from_dir :String, to_dir :String, recursive :bool = false) -> bool:
	if not DirAccess.dir_exists_absolute(from_dir):
		push_error("Source directory not found '%s'" % from_dir)
		return false

	# check if destination exists
	if not DirAccess.dir_exists_absolute(to_dir):
		# create it
		var err := DirAccess.make_dir_recursive_absolute(to_dir)
		if err != OK:
			push_error("Can't create directory '%s'. Error: %s" % [to_dir, error_string(err)])
			return false
	var source_dir := DirAccess.open(from_dir)
	var dest_dir := DirAccess.open(to_dir)
	if source_dir != null:
		@warning_ignore("return_value_discarded")
		source_dir.list_dir_begin()
		var next := "."

		while next != "":
			next = source_dir.get_next()
			if next == "" or next == "." or next == "..":
				continue
			var source := source_dir.get_current_dir() + "/" + next
			var dest := dest_dir.get_current_dir() + "/" + next
			if source_dir.current_is_dir():
				if recursive:
					@warning_ignore("return_value_discarded")
					copy_directory(source + "/", dest, recursive)
				continue
			var err := source_dir.copy(source, dest)
			if err != OK:
				push_error("Error checked copy file '%s' to '%s'" % [source, dest])
				return false

		return true
	else:
		push_error("Directory not found: " + from_dir)
		return false


static func delete_directory(path :String, only_content := false) -> void:
	var dir := DirAccess.open(path)
	if dir != null:
		@warning_ignore("return_value_discarded")
		dir.list_dir_begin()
		var file_name := "."
		while file_name != "":
			file_name = dir.get_next()
			if file_name.is_empty() or file_name == "." or file_name == "..":
				continue
			var next := path + "/" +file_name
			if dir.current_is_dir():
				delete_directory(next)
			else:
				# delete file
				var err := dir.remove(next)
				if err:
					push_error("Delete %s failed: %s" % [next, error_string(err)])
		if not only_content:
			var err := dir.remove(path)
			if err:
				push_error("Delete %s failed: %s" % [path, error_string(err)])


static func delete_path_index_lower_equals_than(path :String, prefix :String, index :int) -> int:
	var dir := DirAccess.open(path)
	if dir == null:
		return 0
	var deleted := 0
	@warning_ignore("return_value_discarded")
	dir.list_dir_begin()
	var next := "."
	while next != "":
		next = dir.get_next()
		if next.is_empty() or next == "." or next == "..":
			continue
		if next.begins_with(prefix):
			var current_index := next.split("_")[1].to_int()
			if current_index <= index:
				deleted += 1
				delete_directory(path + "/" + next)
	return deleted


# scans given path for sub directories by given prefix and returns the highest index numer
# e.g. <prefix_%d>
static func find_last_path_index(path :String, prefix :String) -> int:
	var dir := DirAccess.open(path)
	if dir == null:
		return 0
	var last_iteration := 0
	@warning_ignore("return_value_discarded")
	dir.list_dir_begin()
	var next := "."
	while next != "":
		next = dir.get_next()
		if next.is_empty() or next == "." or next == "..":
			continue
		if next.begins_with(prefix):
			var iteration := next.split("_")[1].to_int()
			if iteration > last_iteration:
				last_iteration = iteration
	return last_iteration


static func scan_dir(path :String) -> PackedStringArray:
	var dir := DirAccess.open(path)
	if dir == null or not dir.dir_exists(path):
		return PackedStringArray()
	var content := PackedStringArray()
	@warning_ignore("return_value_discarded")
	dir.list_dir_begin()
	var next := "."
	while next != "":
		next = dir.get_next()
		if next.is_empty() or next == "." or next == "..":
			continue
		@warning_ignore("return_value_discarded")
		content.append(next)
	return content


static func resource_as_array(resource_path :String) -> PackedStringArray:
	var file := FileAccess.open(resource_path, FileAccess.READ)
	if file == null:
		push_error("ERROR: Can't read resource '%s'. %s" % [resource_path, error_string(FileAccess.get_open_error())])
		return PackedStringArray()
	var file_content := PackedStringArray()
	while not file.eof_reached():
		@warning_ignore("return_value_discarded")
		file_content.append(file.get_line())
	return file_content


static func resource_as_string(resource_path :String) -> String:
	var file := FileAccess.open(resource_path, FileAccess.READ)
	if file == null:
		push_error("ERROR: Can't read resource '%s'. %s" % [resource_path, error_string(FileAccess.get_open_error())])
		return ""
	return file.get_as_text(true)


static func make_qualified_path(path :String) -> String:
	if path.begins_with("res://"):
		return path
	if path.begins_with("//"):
		return path.replace("//", "res://")
	if path.begins_with("/"):
		return "res:/" + path
	return path


static func extract_zip(zip_package :String, dest_path :String) -> GdUnitResult:
	var zip: ZIPReader = ZIPReader.new()
	var err := zip.open(zip_package)
	if err != OK:
		return GdUnitResult.error("Extracting `%s` failed! Please collect the error log and report this. Error Code: %s" % [zip_package, err])
	var zip_entries: PackedStringArray = zip.get_files()
	# Get base path and step over archive folder
	var archive_path := zip_entries[0]
	zip_entries.remove_at(0)

	for zip_entry in zip_entries:
		var new_file_path: String = dest_path + "/" + zip_entry.replace(archive_path, "")
		if zip_entry.ends_with("/"):
			@warning_ignore("return_value_discarded")
			DirAccess.make_dir_recursive_absolute(new_file_path)
			continue
		var file: FileAccess = FileAccess.open(new_file_path, FileAccess.WRITE)
		file.store_buffer(zip.read_file(zip_entry))
	@warning_ignore("return_value_discarded")
	zip.close()
	return GdUnitResult.success(dest_path)
class_name GdUnitObjectInteractions
extends RefCounted


static func verify(interaction_object :Object, interactions_times :int) -> Variant:
	if not _is_mock_or_spy(interaction_object, "__verify"):
		return interaction_object
	@warning_ignore("unsafe_method_access")
	return interaction_object.__do_verify_interactions(interactions_times)


static func verify_no_interactions(interaction_object :Object) -> GdUnitAssert:
	var __gd_assert := GdUnitAssertImpl.new("")
	if not _is_mock_or_spy(interaction_object, "__verify"):
		return __gd_assert.report_success()
	@warning_ignore("unsafe_method_access")
	var __summary :Dictionary = interaction_object.__verify_no_interactions()
	if __summary.is_empty():
		return __gd_assert.report_success()
	return __gd_assert.report_error(GdAssertMessages.error_no_more_interactions(__summary))


static func verify_no_more_interactions(interaction_object :Object) -> GdUnitAssert:
	var __gd_assert := GdUnitAssertImpl.new("")
	if not _is_mock_or_spy(interaction_object, "__verify_no_more_interactions"):
		return __gd_assert
	@warning_ignore("unsafe_method_access")
	var __summary :Dictionary = interaction_object.__verify_no_more_interactions()
	if __summary.is_empty():
		return __gd_assert
	return __gd_assert.report_error(GdAssertMessages.error_no_more_interactions(__summary))


static func reset(interaction_object :Object) -> Object:
	if not _is_mock_or_spy(interaction_object, "__reset"):
		return interaction_object
	@warning_ignore("unsafe_method_access")
	interaction_object.__reset_interactions()
	return interaction_object


static func _is_mock_or_spy(interaction_object :Object, mock_function_signature :String) -> bool:
	@warning_ignore("unsafe_cast")
	if interaction_object is GDScript and not (interaction_object.get_script() as GDScript).has_method(mock_function_signature):
		push_error("Error: You try to use a non mock or spy!")
		return false
	return true

var __expected_interactions :int = -1
var __saved_interactions := Dictionary()
var __verified_interactions := Array()


func __save_function_interaction(function_args :Array[Variant]) -> void:
	var __matcher := GdUnitArgumentMatchers.to_matcher(function_args, true)
	for __index in __saved_interactions.keys().size():
		var __key :Variant = __saved_interactions.keys()[__index]
		if __matcher.is_match(__key):
			__saved_interactions[__key] += 1
			return
	__saved_interactions[function_args] = 1


func __is_verify_interactions() -> bool:
	return __expected_interactions != -1


func __do_verify_interactions(interactions_times :int = 1) -> Object:
	__expected_interactions = interactions_times
	return self


func __verify_interactions(function_args :Array[Variant]) -> void:
	var __summary := Dictionary()
	var __total_interactions := 0
	var __matcher := GdUnitArgumentMatchers.to_matcher(function_args, true)
	for __index in __saved_interactions.keys().size():
		var __key :Variant = __saved_interactions.keys()[__index]
		if __matcher.is_match(__key):
			var __interactions :int = __saved_interactions.get(__key, 0)
			__total_interactions += __interactions
			__summary[__key] = __interactions
			# add as verified
			__verified_interactions.append(__key)

	var __gd_assert := GdUnitAssertImpl.new("")
	if __total_interactions != __expected_interactions:
		var __expected_summary := {function_args : __expected_interactions}
		var __error_message :String
		# if no __interactions macht collect not verified __interactions for failure report
		if __summary.is_empty():
			var __current_summary := __verify_no_more_interactions()
			__error_message = GdAssertMessages.error_validate_interactions(__current_summary, __expected_summary)
		else:
			__error_message = GdAssertMessages.error_validate_interactions(__summary, __expected_summary)
		@warning_ignore("return_value_discarded")
		__gd_assert.report_error(__error_message)
	else:
		@warning_ignore("return_value_discarded")
		__gd_assert.report_success()
	__expected_interactions = -1


func __verify_no_interactions() -> Dictionary:
	var __summary := Dictionary()
	if not __saved_interactions.is_empty():
		for __index in __saved_interactions.keys().size():
			var func_call :Variant = __saved_interactions.keys()[__index]
			__summary[func_call] = __saved_interactions[func_call]
	return __summary


func __verify_no_more_interactions() -> Dictionary:
	var __summary := Dictionary()
	var called_functions :Array[Variant] = __saved_interactions.keys()
	if called_functions != __verified_interactions:
		# collect the not verified functions
		var called_but_not_verified := called_functions.duplicate()
		for __index in __verified_interactions.size():
			called_but_not_verified.erase(__verified_interactions[__index])

		for __index in called_but_not_verified.size():
			var not_verified :Variant = called_but_not_verified[__index]
			__summary[not_verified] = __saved_interactions[not_verified]
	return __summary


func __reset_interactions() -> void:
	__saved_interactions.clear()


func __filter_vargs(arg_values :Array[Variant]) -> Array[Variant]:
	var filtered :Array[Variant] = []
	for __index in arg_values.size():
		var arg :Variant = arg_values[__index]
		if typeof(arg) == TYPE_STRING and arg == GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE:
			continue
		filtered.append(arg)
	return filtered
class_name GdUnitProperty
extends RefCounted


var _name :String
var _help :String
var _type :int
var _value :Variant
var _value_set :PackedStringArray
var _default :Variant


func _init(p_name :String, p_type :int, p_value :Variant, p_default_value :Variant, p_help :="", p_value_set := PackedStringArray()) -> void:
	_name = p_name
	_type = p_type
	_value = p_value
	_value_set = p_value_set
	_default = p_default_value
	_help = p_help


func name() -> String:
	return _name


func type() -> int:
	return _type


func value() -> Variant:
	return _value


func value_as_string() -> String:
	return _value


func value_set() -> PackedStringArray:
	return _value_set


func is_selectable_value() -> bool:
	return not _value_set.is_empty()


func set_value(p_value :Variant) -> void:
	match _type:
		TYPE_STRING:
			_value = str(p_value)
		TYPE_BOOL:
			_value = convert(p_value, TYPE_BOOL)
		TYPE_INT:
			_value = convert(p_value, TYPE_INT)
		TYPE_FLOAT:
			_value = convert(p_value, TYPE_FLOAT)
		_:
			_value = p_value


func default() -> Variant:
	return _default


func category() -> String:
	var elements := _name.split("/")
	if elements.size() > 3:
		return elements[2]
	return ""


func help() -> String:
	return _help


func _to_string() -> String:
	return "%-64s %-10s %-10s (%s) help:%s set:%s" % [name(), type(), value(), default(), help(), _value_set]
class_name GdUnitResult
extends RefCounted

enum {
	SUCCESS,
	WARN,
	ERROR,
	EMPTY
}

var _state: int
var _warn_message := ""
var _error_message := ""
var _value :Variant = null


static func empty() -> GdUnitResult:
	var result := GdUnitResult.new()
	result._state = EMPTY
	return result


static func success(p_value :Variant) -> GdUnitResult:
	assert(p_value != null, "The value must not be NULL")
	var result := GdUnitResult.new()
	result._value = p_value
	result._state = SUCCESS
	return result


static func warn(p_warn_message :String, p_value :Variant = null) -> GdUnitResult:
	assert(not p_warn_message.is_empty()) #,"The message must not be empty")
	var result := GdUnitResult.new()
	result._value = p_value
	result._warn_message = p_warn_message
	result._state = WARN
	return result


static func error(p_error_message :String) -> GdUnitResult:
	assert(not p_error_message.is_empty(), "The message must not be empty")
	var result := GdUnitResult.new()
	result._value = null
	result._error_message = p_error_message
	result._state = ERROR
	return result


func is_success() -> bool:
	return _state == SUCCESS


func is_warn() -> bool:
	return _state == WARN


func is_error() -> bool:
	return _state == ERROR


func is_empty() -> bool:
	return _state == EMPTY


func value() -> Variant:
	return _value


func value_as_string() -> String:
	return _value


func or_else(p_value :Variant) -> Variant:
	if not is_success():
		return p_value
	return value()


func error_message() -> String:
	return _error_message


func warn_message() -> String:
	return _warn_message


func _to_string() -> String:
	return str(GdUnitResult.serialize(self))


static func serialize(result :GdUnitResult) -> Dictionary:
	if result == null:
		push_error("Can't serialize a Null object from type GdUnitResult")
	return {
		"state" : result._state,
		"value" : var_to_str(result._value),
		"warn_msg" : result._warn_message,
		"err_msg" : result._error_message
	}


static func deserialize(config :Dictionary) -> GdUnitResult:
	var result := GdUnitResult.new()
	var cfg_value: String = config.get("value", "")
	result._value = str_to_var(cfg_value)
	result._warn_message = config.get("warn_msg", null)
	result._error_message = config.get("err_msg", null)
	result._state = config.get("state")
	return result
extends Node

@onready var _client :GdUnitTcpClient = $GdUnitTcpClient
@onready var _executor :GdUnitTestSuiteExecutor = GdUnitTestSuiteExecutor.new()

enum {
	INIT,
	RUN,
	STOP,
	EXIT
}

const GDUNIT_RUNNER = "GdUnitRunner"

var _config := GdUnitRunnerConfig.new()
var _test_suites_to_process :Array[Node]
var _state :int = INIT
var _cs_executor :RefCounted


func _init() -> void:
	# minimize scene window checked debug mode
	if OS.get_cmdline_args().size() == 1:
		DisplayServer.window_set_title("GdUnit4 Runner (Debug Mode)")
	else:
		DisplayServer.window_set_title("GdUnit4 Runner (Release Mode)")
	DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_MINIMIZED)
	# store current runner instance to engine meta data to can be access in as a singleton
	Engine.set_meta(GDUNIT_RUNNER, self)
	_cs_executor = GdUnit4CSharpApiLoader.create_executor(self)


func _ready() -> void:
	var config_result := _config.load_config()
	if config_result.is_error():
		push_error(config_result.error_message())
		_state = EXIT
		return
	@warning_ignore("return_value_discarded")
	_client.connect("connection_failed", _on_connection_failed)
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	var result := _client.start("127.0.0.1", _config.server_port())
	if result.is_error():
		push_error(result.error_message())
		return
	_state = INIT


func _on_connection_failed(message :String) -> void:
	prints("_on_connection_failed", message, _test_suites_to_process)
	_state = STOP


func _notification(what :int) -> void:
	#prints("GdUnitRunner", self, GdObjects.notification_as_string(what))
	if what == NOTIFICATION_PREDELETE:
		Engine.remove_meta(GDUNIT_RUNNER)


func _process(_delta :float) -> void:
	match _state:
		INIT:
			# wait until client is connected to the GdUnitServer
			if _client.is_client_connected():
				var time := LocalTime.now()
				prints("Scan for test suites.")
				_test_suites_to_process = load_test_suites()
				prints("Scanning of %d test suites took" % _test_suites_to_process.size(), time.elapsed_since())
				gdUnitInit()
				_state = RUN
		RUN:
			# all test suites executed
			if _test_suites_to_process.is_empty():
				_state = STOP
			else:
				# process next test suite
				set_process(false)
				var test_suite :Node = _test_suites_to_process.pop_front()
				@warning_ignore("unsafe_method_access")
				if _cs_executor != null and _cs_executor.IsExecutable(test_suite):
					@warning_ignore("unsafe_method_access")
					_cs_executor.Execute(test_suite)
					@warning_ignore("unsafe_property_access")
					await _cs_executor.ExecutionCompleted
				else:
					await _executor.execute(test_suite as GdUnitTestSuite)
				set_process(true)
		STOP:
			_state = EXIT
			# give the engine small amount time to finish the rpc
			_on_gdunit_event(GdUnitStop.new())
			await get_tree().create_timer(0.1).timeout
			await get_tree().process_frame
			get_tree().quit(0)


func load_test_suites() -> Array[Node]:
	var to_execute := _config.to_execute()
	if to_execute.is_empty():
		prints("No tests selected to execute!")
		_state = EXIT
		return []
	# scan for the requested test suites
	var test_suites :Array[Node] = []
	var _scanner := GdUnitTestSuiteScanner.new()
	for resource_path :String in to_execute.keys():
		var selected_tests :PackedStringArray = to_execute.get(resource_path)
		var scanned_suites := _scanner.scan(resource_path)
		_filter_test_case(scanned_suites, selected_tests)
		test_suites += scanned_suites
	return test_suites


func gdUnitInit() -> void:
	#enable_manuall_polling()
	send_message("Scanned %d test suites" % _test_suites_to_process.size())
	var total_count := _collect_test_case_count(_test_suites_to_process)
	_on_gdunit_event(GdUnitInit.new(_test_suites_to_process.size(), total_count))
	if not GdUnitSettings.is_test_discover_enabled():
		for test_suite in _test_suites_to_process:
			send_test_suite(test_suite)


func _filter_test_case(test_suites :Array[Node], included_tests :PackedStringArray) -> void:
	if included_tests.is_empty():
		return
	for test_suite in test_suites:
		for test_case in test_suite.get_children():
			_do_filter_test_case(test_suite, test_case, included_tests)


func _do_filter_test_case(test_suite :Node, test_case :Node, included_tests :PackedStringArray) -> void:
	for included_test in included_tests:
		var test_meta :PackedStringArray = included_test.split(":")
		var test_name := test_meta[0]
		if test_case.get_name() == test_name:
			# we have a paremeterized test selection
			if test_meta.size() > 1:
				var test_param_index := test_meta[1]
				@warning_ignore("unsafe_method_access")
				test_case.set_test_parameter_index(test_param_index.to_int())
			return
	# the test is filtered out
	test_suite.remove_child(test_case)
	test_case.free()


func _collect_test_case_count(testSuites :Array[Node]) -> int:
	var total :int = 0
	for test_suite in testSuites:
		total += test_suite.get_child_count()
	return total


# RPC send functions
func send_message(message :String) -> void:
	_client.rpc_send(RPCMessage.of(message))


func send_test_suite(test_suite :Node) -> void:
	_client.rpc_send(RPCGdUnitTestSuite.of(test_suite))


func _on_gdunit_event(event :GdUnitEvent) -> void:
	_client.rpc_send(RPCGdUnitEvent.of(event))


# Event bridge from C# GdUnit4.ITestEventListener.cs
func PublishEvent(data :Dictionary) -> void:
	var event := GdUnitEvent.new().deserialize(data)
	_client.rpc_send(RPCGdUnitEvent.of(event))
class_name GdUnitRunnerConfig
extends Resource

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const CONFIG_VERSION = "1.0"
const VERSION = "version"
const INCLUDED = "included"
const SKIPPED = "skipped"
const SERVER_PORT = "server_port"
const EXIT_FAIL_FAST = "exit_on_first_fail"

const CONFIG_FILE = "res://addons/gdUnit4/GdUnitRunner.cfg"

var _config := {
		VERSION : CONFIG_VERSION,
		# a set of directories or testsuite paths as key and a optional set of testcases as values
		INCLUDED :  Dictionary(),
		# a set of skipped directories or testsuite paths
		SKIPPED : Dictionary(),
		# the port of running test server for this session
		SERVER_PORT : -1
	}


func clear() -> GdUnitRunnerConfig:
	_config[INCLUDED] = Dictionary()
	_config[SKIPPED] = Dictionary()
	return self


func set_server_port(port: int) -> GdUnitRunnerConfig:
	_config[SERVER_PORT] = port
	return self


func server_port() -> int:
	return _config.get(SERVER_PORT, -1)


@warning_ignore("return_value_discarded")
func self_test() -> GdUnitRunnerConfig:
	add_test_suite("res://addons/gdUnit4/test/")
	add_test_suite("res://addons/gdUnit4/mono/test/")
	return self


func add_test_suite(p_resource_path: String) -> GdUnitRunnerConfig:
	var to_execute_ := to_execute()
	to_execute_[p_resource_path] = to_execute_.get(p_resource_path, PackedStringArray())
	return self


func add_test_suites(resource_paths: PackedStringArray) -> GdUnitRunnerConfig:
	for resource_path_ in resource_paths:
		@warning_ignore("return_value_discarded")
		add_test_suite(resource_path_)
	return self


func add_test_case(p_resource_path: String, test_name: String, test_param_index: int = -1) -> GdUnitRunnerConfig:
	var to_execute_ := to_execute()
	var test_cases: PackedStringArray = to_execute_.get(p_resource_path, PackedStringArray())
	if test_param_index != -1:
		@warning_ignore("return_value_discarded")
		test_cases.append("%s:%d" % [test_name, test_param_index])
	else:
		@warning_ignore("return_value_discarded")
		test_cases.append(test_name)
	to_execute_[p_resource_path] = test_cases
	return self


# supports full path or suite name with optional test case name
# <test_suite_name|path>[:<test_case_name>]
# '/path/path', res://path/path', 'res://path/path/testsuite.gd' or 'testsuite'
# 'res://path/path/testsuite.gd:test_case' or 'testsuite:test_case'
func skip_test_suite(value: String) -> GdUnitRunnerConfig:
	var parts: PackedStringArray = GdUnitFileAccess.make_qualified_path(value).rsplit(":")
	if parts[0] == "res":
		parts.remove_at(0)
	parts[0] = GdUnitFileAccess.make_qualified_path(parts[0])
	match parts.size():
		1:
			skipped()[parts[0]] = PackedStringArray()
		2:
			@warning_ignore("return_value_discarded")
			_skip_test_case(parts[0], parts[1])
	return self


func skip_test_suites(resource_paths: PackedStringArray) -> GdUnitRunnerConfig:
	for resource_path_ in resource_paths:
		@warning_ignore("return_value_discarded")
		skip_test_suite(resource_path_)
	return self


func _skip_test_case(p_resource_path: String, test_name: String) -> GdUnitRunnerConfig:
	var to_ignore := skipped()
	var test_cases: PackedStringArray = to_ignore.get(p_resource_path, PackedStringArray())
	@warning_ignore("return_value_discarded")
	test_cases.append(test_name)
	to_ignore[p_resource_path] = test_cases
	return self


# Dictionary[String, Dictionary[String, PackedStringArray]]
func to_execute() -> Dictionary:
	return _config.get(INCLUDED, {"res://" : PackedStringArray()})


func skipped() -> Dictionary:
	return _config.get(SKIPPED, {})


func save_config(path: String = CONFIG_FILE) -> GdUnitResult:
	var file := FileAccess.open(path, FileAccess.WRITE)
	if file == null:
		var error := FileAccess.get_open_error()
		return GdUnitResult.error("Can't write test runner configuration '%s'! %s" % [path, error_string(error)])
	_config[VERSION] = CONFIG_VERSION
	file.store_string(JSON.stringify(_config))
	return GdUnitResult.success(path)


func load_config(path: String = CONFIG_FILE) -> GdUnitResult:
	if not FileAccess.file_exists(path):
		return GdUnitResult.error("Can't find test runner configuration '%s'! Please select a test to run." % path)
	var file := FileAccess.open(path, FileAccess.READ)
	if file == null:
		var error := FileAccess.get_open_error()
		return GdUnitResult.error("Can't load test runner configuration '%s'! ERROR: %s." % [path, error_string(error)])
	var content := file.get_as_text()
	if not content.is_empty() and content[0] == '{':
		# Parse as json
		var test_json_conv := JSON.new()
		var error := test_json_conv.parse(content)
		if error != OK:
			return GdUnitResult.error("The runner configuration '%s' is invalid! The format is changed please delete it manually and start a new test run." % path)
		_config = test_json_conv.get_data()
		if not _config.has(VERSION):
			return GdUnitResult.error("The runner configuration '%s' is invalid! The format is changed please delete it manually and start a new test run." % path)
		fix_value_types()
	return GdUnitResult.success(path)


@warning_ignore("unsafe_cast")
func fix_value_types() -> void:
	# fix float value to int json stores all numbers as float
	var server_port_: int = _config.get(SERVER_PORT, -1)
	_config[SERVER_PORT] = server_port_
	convert_Array_to_PackedStringArray(_config[INCLUDED] as Dictionary)
	convert_Array_to_PackedStringArray(_config[SKIPPED] as Dictionary)


func convert_Array_to_PackedStringArray(data: Dictionary) -> void:
	for key in data.keys() as Array[String]:
		var values :Array = data[key]
		data[key] = PackedStringArray(values)


func _to_string() -> String:
	return str(_config)
# This class provides a runner for scense to simulate interactions like keyboard or mouse
class_name GdUnitSceneRunnerImpl
extends GdUnitSceneRunner


var GdUnitFuncAssertImpl: GDScript = ResourceLoader.load("res://addons/gdUnit4/src/asserts/GdUnitFuncAssertImpl.gd", "GDScript", ResourceLoader.CACHE_MODE_REUSE)


# mapping of mouse buttons and his masks
const MAP_MOUSE_BUTTON_MASKS := {
	MOUSE_BUTTON_LEFT : MOUSE_BUTTON_MASK_LEFT,
	MOUSE_BUTTON_RIGHT : MOUSE_BUTTON_MASK_RIGHT,
	MOUSE_BUTTON_MIDDLE : MOUSE_BUTTON_MASK_MIDDLE,
	# https://github.com/godotengine/godot/issues/73632
	MOUSE_BUTTON_WHEEL_UP : 1 << (MOUSE_BUTTON_WHEEL_UP - 1),
	MOUSE_BUTTON_WHEEL_DOWN : 1 << (MOUSE_BUTTON_WHEEL_DOWN - 1),
	MOUSE_BUTTON_XBUTTON1 : MOUSE_BUTTON_MASK_MB_XBUTTON1,
	MOUSE_BUTTON_XBUTTON2 : MOUSE_BUTTON_MASK_MB_XBUTTON2,
}

var _is_disposed := false
var _current_scene: Node = null
var _awaiter: GdUnitAwaiter = GdUnitAwaiter.new()
var _verbose: bool
var _simulate_start_time: LocalTime
var _last_input_event: InputEvent = null
var _mouse_button_on_press := []
var _key_on_press := []
var _action_on_press := []
var _curent_mouse_position: Vector2
# holds the touch position for each touch index
# { index: int = position: Vector2}
var _current_touch_position: Dictionary = {}
# holds the curretn touch drag position
var _current_touch_drag_position: Vector2 = Vector2.ZERO

# time factor settings
var _time_factor := 1.0
var _saved_iterations_per_second: float
var _scene_auto_free := false


func _init(p_scene: Variant, p_verbose: bool, p_hide_push_errors := false) -> void:
	_verbose = p_verbose
	_saved_iterations_per_second = Engine.get_physics_ticks_per_second()
	@warning_ignore("return_value_discarded")
	set_time_factor(1)
	# handle scene loading by resource path
	if typeof(p_scene) == TYPE_STRING:
		@warning_ignore("unsafe_cast")
		if !ResourceLoader.exists(p_scene as String):
			if not p_hide_push_errors:
				push_error("GdUnitSceneRunner: Can't load scene by given resource path: '%s'. The resource does not exists." % p_scene)
			return
		if !str(p_scene).ends_with(".tscn") and !str(p_scene).ends_with(".scn") and !str(p_scene).begins_with("uid://"):
			if not p_hide_push_errors:
				push_error("GdUnitSceneRunner: The given resource: '%s'. is not a scene." % p_scene)
			return
		@warning_ignore("unsafe_cast")
		_current_scene = (load(p_scene as String) as PackedScene).instantiate()
		_scene_auto_free = true
	else:
		# verify we have a node instance
		if not p_scene is Node:
			if not p_hide_push_errors:
				push_error("GdUnitSceneRunner: The given instance '%s' is not a Node." % p_scene)
			return
		_current_scene = p_scene
	if _current_scene == null:
		if not p_hide_push_errors:
			push_error("GdUnitSceneRunner: Scene must be not null!")
		return

	_scene_tree().root.add_child(_current_scene)
	# do finally reset all open input events when the scene is removed
	@warning_ignore("return_value_discarded")
	_scene_tree().root.child_exiting_tree.connect(func f(child :Node) -> void:
		if child == _current_scene:
			# we need to disable the processing to avoid input flush buffer errors
			_current_scene.process_mode = Node.PROCESS_MODE_DISABLED
			_reset_input_to_default()
	)
	_simulate_start_time = LocalTime.now()
	# we need to set inital a valid window otherwise the warp_mouse() is not handled
	DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)
	# set inital mouse pos to 0,0
	var max_iteration_to_wait := 0
	while get_global_mouse_position() != Vector2.ZERO and max_iteration_to_wait < 100:
		Input.warp_mouse(Vector2.ZERO)
		max_iteration_to_wait += 1


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE and is_instance_valid(self):
		# reset time factor to normal
		__deactivate_time_factor()
		if is_instance_valid(_current_scene):
			_scene_tree().root.remove_child(_current_scene)
			# do only free scenes instanciated by this runner
			if _scene_auto_free:
				_current_scene.free()
		_is_disposed = true
		_current_scene = null


func _scene_tree() -> SceneTree:
	return Engine.get_main_loop() as SceneTree


@warning_ignore("return_value_discarded")
func simulate_action_pressed(action: String) -> GdUnitSceneRunner:
	simulate_action_press(action)
	simulate_action_release(action)
	return self


func simulate_action_press(action: String) -> GdUnitSceneRunner:
	__print_current_focus()
	var event := InputEventAction.new()
	event.pressed = true
	event.action = action
	if Engine.get_version_info().hex >= 0x40300:
		@warning_ignore("unsafe_property_access")
		event.event_index = InputMap.get_actions().find(action)
	_action_on_press.append(action)
	return _handle_input_event(event)


func simulate_action_release(action: String) -> GdUnitSceneRunner:
	__print_current_focus()
	var event := InputEventAction.new()
	event.pressed = false
	event.action = action
	if Engine.get_version_info().hex >= 0x40300:
		@warning_ignore("unsafe_property_access")
		event.event_index = InputMap.get_actions().find(action)
	_action_on_press.erase(action)
	return _handle_input_event(event)


@warning_ignore("return_value_discarded")
func simulate_key_pressed(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	simulate_key_press(key_code, shift_pressed, ctrl_pressed)
	await _scene_tree().process_frame
	simulate_key_release(key_code, shift_pressed, ctrl_pressed)
	return self


func simulate_key_press(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	__print_current_focus()
	var event := InputEventKey.new()
	event.pressed = true
	event.keycode = key_code as Key
	event.physical_keycode = key_code as Key
	event.alt_pressed = key_code == KEY_ALT
	event.shift_pressed = shift_pressed or key_code == KEY_SHIFT
	event.ctrl_pressed = ctrl_pressed or key_code == KEY_CTRL
	_apply_input_modifiers(event)
	_key_on_press.append(key_code)
	return _handle_input_event(event)


func simulate_key_release(key_code: int, shift_pressed := false, ctrl_pressed := false) -> GdUnitSceneRunner:
	__print_current_focus()
	var event := InputEventKey.new()
	event.pressed = false
	event.keycode = key_code as Key
	event.physical_keycode = key_code as Key
	event.alt_pressed = key_code == KEY_ALT
	event.shift_pressed = shift_pressed or key_code == KEY_SHIFT
	event.ctrl_pressed = ctrl_pressed or key_code == KEY_CTRL
	_apply_input_modifiers(event)
	_key_on_press.erase(key_code)
	return _handle_input_event(event)


func set_mouse_pos(pos: Vector2) -> GdUnitSceneRunner:
	return set_mouse_position(pos)


func set_mouse_position(pos: Vector2) -> GdUnitSceneRunner:
	var event := InputEventMouseMotion.new()
	event.position = pos
	event.global_position = get_global_mouse_position()
	_apply_input_modifiers(event)
	return _handle_input_event(event)


func get_mouse_position() -> Vector2:
	if _last_input_event is InputEventMouse:
		return (_last_input_event as InputEventMouse).position
	var current_scene := scene()
	if current_scene != null:
		return current_scene.get_viewport().get_mouse_position()
	return Vector2.ZERO


func get_global_mouse_position() -> Vector2:
	return (Engine.get_main_loop() as SceneTree).root.get_mouse_position()


func simulate_mouse_move(position: Vector2) -> GdUnitSceneRunner:
	var event := InputEventMouseMotion.new()
	event.position = position
	event.relative = position - get_mouse_position()
	event.global_position = get_global_mouse_position()
	_apply_input_mouse_mask(event)
	_apply_input_modifiers(event)
	return _handle_input_event(event)


@warning_ignore("return_value_discarded")
func simulate_mouse_move_relative(relative: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	var tween := _scene_tree().create_tween()
	_curent_mouse_position = get_mouse_position()
	var final_position := _curent_mouse_position + relative
	tween.tween_property(self, "_curent_mouse_position", final_position, time).set_trans(trans_type)
	tween.play()

	while not get_mouse_position().is_equal_approx(final_position):
		simulate_mouse_move(_curent_mouse_position)
		await _scene_tree().process_frame
	return self


@warning_ignore("return_value_discarded")
func simulate_mouse_move_absolute(position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	var tween := _scene_tree().create_tween()
	_curent_mouse_position = get_mouse_position()
	tween.tween_property(self, "_curent_mouse_position", position, time).set_trans(trans_type)
	tween.play()

	while not get_mouse_position().is_equal_approx(position):
		simulate_mouse_move(_curent_mouse_position)
		await _scene_tree().process_frame
	return self


@warning_ignore("return_value_discarded")
func simulate_mouse_button_pressed(button_index: MouseButton, double_click := false) -> GdUnitSceneRunner:
	simulate_mouse_button_press(button_index, double_click)
	simulate_mouse_button_release(button_index)
	return self


func simulate_mouse_button_press(button_index: MouseButton, double_click := false) -> GdUnitSceneRunner:
	var event := InputEventMouseButton.new()
	event.button_index = button_index
	event.pressed = true
	event.double_click = double_click
	_apply_input_mouse_position(event)
	_apply_input_mouse_mask(event)
	_apply_input_modifiers(event)
	_mouse_button_on_press.append(button_index)
	return _handle_input_event(event)


func simulate_mouse_button_release(button_index: MouseButton) -> GdUnitSceneRunner:
	var event := InputEventMouseButton.new()
	event.button_index = button_index
	event.pressed = false
	_apply_input_mouse_position(event)
	_apply_input_mouse_mask(event)
	_apply_input_modifiers(event)
	_mouse_button_on_press.erase(button_index)
	return _handle_input_event(event)


@warning_ignore("return_value_discarded")
func simulate_screen_touch_pressed(index: int, position: Vector2, double_tap := false) -> GdUnitSceneRunner:
	simulate_screen_touch_press(index, position, double_tap)
	simulate_screen_touch_release(index)
	return self


@warning_ignore("return_value_discarded")
func simulate_screen_touch_press(index: int, position: Vector2, double_tap := false) -> GdUnitSceneRunner:
	if is_emulate_mouse_from_touch():
		# we need to simulate in addition to the touch the mouse events
		set_mouse_pos(position)
		simulate_mouse_button_press(MOUSE_BUTTON_LEFT)
	# push touch press event at position
	var event := InputEventScreenTouch.new()
	event.window_id = scene().get_window().get_window_id()
	event.index = index
	event.position = position
	event.double_tap = double_tap
	event.pressed = true
	_current_scene.get_viewport().push_input(event)
	# save current drag position by index
	_current_touch_position[index] = position
	return self


@warning_ignore("return_value_discarded")
func simulate_screen_touch_release(index: int, double_tap := false) -> GdUnitSceneRunner:
	if is_emulate_mouse_from_touch():
		# we need to simulate in addition to the touch the mouse events
		simulate_mouse_button_release(MOUSE_BUTTON_LEFT)
	# push touch release event at position
	var event := InputEventScreenTouch.new()
	event.window_id = scene().get_window().get_window_id()
	event.index = index
	event.position = get_screen_touch_drag_position(index)
	event.pressed = false
	event.double_tap = (_last_input_event as InputEventScreenTouch).double_tap if _last_input_event is InputEventScreenTouch else double_tap
	_current_scene.get_viewport().push_input(event)
	return self


func simulate_screen_touch_drag_relative(index: int, relative: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	var current_position: Vector2 = _current_touch_position[index]
	return await _do_touch_drag_at(index, current_position + relative, time, trans_type)


func simulate_screen_touch_drag_absolute(index: int, position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	return await _do_touch_drag_at(index, position, time, trans_type)


@warning_ignore("return_value_discarded")
func simulate_screen_touch_drag_drop(index: int, position: Vector2, drop_position: Vector2, time: float = 1.0, trans_type: Tween.TransitionType = Tween.TRANS_LINEAR) -> GdUnitSceneRunner:
	simulate_screen_touch_press(index, position)
	return await _do_touch_drag_at(index, drop_position, time, trans_type)


@warning_ignore("return_value_discarded")
func simulate_screen_touch_drag(index: int, position: Vector2) -> GdUnitSceneRunner:
	if is_emulate_mouse_from_touch():
		simulate_mouse_move(position)
	var event := InputEventScreenDrag.new()
	event.window_id = scene().get_window().get_window_id()
	event.index = index
	event.position = position
	event.relative = _get_screen_touch_drag_position_or_default(index, position) - position
	event.velocity = event.relative / _scene_tree().root.get_process_delta_time()
	event.pressure = 1.0
	_current_touch_position[index] = position
	_current_scene.get_viewport().push_input(event)
	return self


func get_screen_touch_drag_position(index: int) -> Vector2:
	if _current_touch_position.has(index):
		return _current_touch_position[index]
	push_error("No touch drag position for index '%d' is set!" % index)
	return Vector2.ZERO


func is_emulate_mouse_from_touch() -> bool:
	return ProjectSettings.get_setting("input_devices/pointing/emulate_mouse_from_touch", true)


func _get_screen_touch_drag_position_or_default(index: int, default_position: Vector2) -> Vector2:
	if _current_touch_position.has(index):
		return _current_touch_position[index]
	return default_position


@warning_ignore("return_value_discarded")
func _do_touch_drag_at(index: int, drag_position: Vector2, time: float, trans_type: Tween.TransitionType) -> GdUnitSceneRunner:
	# start draging
	var event := InputEventScreenDrag.new()
	event.window_id = scene().get_window().get_window_id()
	event.index = index
	event.position = get_screen_touch_drag_position(index)
	event.pressure = 1.0
	_current_touch_drag_position = event.position

	var tween := _scene_tree().create_tween()
	tween.tween_property(self, "_current_touch_drag_position", drag_position, time).set_trans(trans_type)
	tween.play()

	while not _current_touch_drag_position.is_equal_approx(drag_position):
		if is_emulate_mouse_from_touch():
			# we need to simulate in addition to the drag the mouse move events
			simulate_mouse_move(event.position)
		# send touche drag event to new position
		event.relative = _current_touch_drag_position - event.position
		event.velocity = event.relative / _scene_tree().root.get_process_delta_time()
		event.position = _current_touch_drag_position
		_current_scene.get_viewport().push_input(event)
		await _scene_tree().process_frame

	# finaly drop it
	if is_emulate_mouse_from_touch():
		simulate_mouse_move(drag_position)
		simulate_mouse_button_release(MOUSE_BUTTON_LEFT)
	var touch_drop_event := InputEventScreenTouch.new()
	touch_drop_event.window_id = event.window_id
	touch_drop_event.index = event.index
	touch_drop_event.position = drag_position
	touch_drop_event.pressed = false
	_current_scene.get_viewport().push_input(touch_drop_event)
	await _scene_tree().process_frame
	return self


func set_time_factor(time_factor: float = 1.0) -> GdUnitSceneRunner:
	_time_factor = min(9.0, time_factor)
	__activate_time_factor()
	__print("set time factor: %f" % _time_factor)
	__print("set physics physics_ticks_per_second: %d" % (_saved_iterations_per_second*_time_factor))
	return self


func simulate_frames(frames: int, delta_milli: int = -1) -> GdUnitSceneRunner:
	var time_shift_frames :int = max(1, frames / _time_factor)
	for frame in time_shift_frames:
		if delta_milli == -1:
			await _scene_tree().process_frame
		else:
			await _scene_tree().create_timer(delta_milli * 0.001).timeout
	return self


func simulate_until_signal(
	signal_name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> GdUnitSceneRunner:
	var args: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], NO_ARG)
	await _awaiter.await_signal_idle_frames(scene(), signal_name, args, 10000)
	return self


func simulate_until_object_signal(
	source: Object,
	signal_name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> GdUnitSceneRunner:
	var args: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], NO_ARG)
	await _awaiter.await_signal_idle_frames(source, signal_name, args, 10000)
	return self


func await_func(func_name: String, args := []) -> GdUnitFuncAssert:
	return GdUnitFuncAssertImpl.new(scene(), func_name, args)


func await_func_on(instance: Object, func_name: String, args := []) -> GdUnitFuncAssert:
	return GdUnitFuncAssertImpl.new(instance, func_name, args)


func await_signal(signal_name: String, args := [], timeout := 2000 ) -> void:
	await _awaiter.await_signal_on(scene(), signal_name, args, timeout)


func await_signal_on(source: Object, signal_name: String, args := [], timeout := 2000 ) -> void:
	await _awaiter.await_signal_on(source, signal_name, args, timeout)


func maximize_view() -> GdUnitSceneRunner:
	DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)
	DisplayServer.window_move_to_foreground()
	return self


func _property_exists(name: String) -> bool:
	return scene().get_property_list().any(func(properties :Dictionary) -> bool: return properties["name"] == name)


func get_property(name: String) -> Variant:
	if not _property_exists(name):
		return "The property '%s' not exist checked loaded scene." % name
	return scene().get(name)


func set_property(name: String, value: Variant) -> bool:
	if not _property_exists(name):
		push_error("The property named '%s' cannot be set, it does not exist!" % name)
		return false;
	scene().set(name, value)
	return true


func invoke(
	name: String,
	arg0: Variant = NO_ARG,
	arg1: Variant = NO_ARG,
	arg2: Variant = NO_ARG,
	arg3: Variant = NO_ARG,
	arg4: Variant = NO_ARG,
	arg5: Variant = NO_ARG,
	arg6: Variant = NO_ARG,
	arg7: Variant = NO_ARG,
	arg8: Variant = NO_ARG,
	arg9: Variant = NO_ARG) -> Variant:
	var args: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], NO_ARG)
	if scene().has_method(name):
		return scene().callv(name, args)
	return "The method '%s' not exist checked loaded scene." % name


func find_child(name: String, recursive: bool = true, owned: bool = false) -> Node:
	return scene().find_child(name, recursive, owned)


func _scene_name() -> String:
	var scene_script :GDScript = scene().get_script()
	var scene_name :String = scene().get_name()
	if not scene_script:
		return scene_name
	if not scene_name.begins_with("@"):
		return scene_name
	return scene_script.resource_name.get_basename()


func __activate_time_factor() -> void:
	Engine.set_time_scale(_time_factor)
	Engine.set_physics_ticks_per_second((_saved_iterations_per_second * _time_factor) as int)


func __deactivate_time_factor() -> void:
	Engine.set_time_scale(1)
	Engine.set_physics_ticks_per_second(_saved_iterations_per_second as int)


# copy over current active modifiers
func _apply_input_modifiers(event: InputEvent) -> void:
	if _last_input_event is InputEventWithModifiers and event is InputEventWithModifiers:
		var last_input_event := _last_input_event as InputEventWithModifiers
		var _event := event as InputEventWithModifiers
		_event.meta_pressed = _event.meta_pressed or last_input_event.meta_pressed
		_event.alt_pressed = _event.alt_pressed or last_input_event.alt_pressed
		_event.shift_pressed = _event.shift_pressed or last_input_event.shift_pressed
		_event.ctrl_pressed = _event.ctrl_pressed or last_input_event.ctrl_pressed
		# this line results into reset the control_pressed state!!!
		#event.command_or_control_autoremap = event.command_or_control_autoremap or _last_input_event.command_or_control_autoremap


# copy over current active mouse mask and combine with curren mask
func _apply_input_mouse_mask(event: InputEvent) -> void:
	# first apply last mask
	if _last_input_event is InputEventMouse and event is InputEventMouse:
		(event as InputEventMouse).button_mask |= (_last_input_event as InputEventMouse).button_mask
	if event is InputEventMouseButton:
		var _event := event as InputEventMouseButton
		var button_mask :int = MAP_MOUSE_BUTTON_MASKS.get(_event.get_button_index(), 0)
		if _event.is_pressed():
			_event.button_mask |= button_mask
		else:
			_event.button_mask ^= button_mask


# copy over last mouse position if need
func _apply_input_mouse_position(event: InputEvent) -> void:
	if _last_input_event is InputEventMouse and event is InputEventMouseButton:
		(event as InputEventMouseButton).position = (_last_input_event as InputEventMouse).position


## handle input action via Input modifieres
func _handle_actions(event: InputEventAction) -> bool:
	if not InputMap.event_is_action(event, event.action, true):
		return false
	__print("	process action %s (%s) <- %s" % [scene(), _scene_name(), event.as_text()])
	if event.is_pressed():
		Input.action_press(event.action, InputMap.action_get_deadzone(event.action))
	else:
		Input.action_release(event.action)
	return true


# for handling read https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html?highlight=inputevent#how-does-it-work
@warning_ignore("return_value_discarded")
func _handle_input_event(event: InputEvent) -> GdUnitSceneRunner:
	if event is InputEventMouse:
		Input.warp_mouse((event as InputEventMouse).position as Vector2)
	Input.parse_input_event(event)

	if event is InputEventAction:
		_handle_actions(event as InputEventAction)

	var current_scene := scene()
	if is_instance_valid(current_scene):
		# do not flush events if node processing disabled otherwise we run into errors at tree removed
		if _current_scene.process_mode != Node.PROCESS_MODE_DISABLED:
			Input.flush_buffered_events()
		__print("	process event %s (%s) <- %s" % [current_scene, _scene_name(), event.as_text()])
		if(current_scene.has_method("_gui_input")):
			(current_scene as Control)._gui_input(event)
		if(current_scene.has_method("_unhandled_input")):
			current_scene._unhandled_input(event)
		current_scene.get_viewport().set_input_as_handled()

	# save last input event needs to be merged with next InputEventMouseButton
	_last_input_event = event
	return self


@warning_ignore("return_value_discarded")
func _reset_input_to_default() -> void:
	# reset all mouse button to inital state if need
	for m_button :int in _mouse_button_on_press.duplicate():
		if Input.is_mouse_button_pressed(m_button):
			simulate_mouse_button_release(m_button)
	_mouse_button_on_press.clear()

	for key_scancode :int in _key_on_press.duplicate():
		if Input.is_key_pressed(key_scancode):
			simulate_key_release(key_scancode)
	_key_on_press.clear()

	for action :String in _action_on_press.duplicate():
		if Input.is_action_pressed(action):
			simulate_action_release(action)
	_action_on_press.clear()

	if is_instance_valid(_current_scene) and _current_scene.process_mode != Node.PROCESS_MODE_DISABLED:
		Input.flush_buffered_events()
	_last_input_event = null


func __print(message: String) -> void:
	if _verbose:
		prints(message)


func __print_current_focus() -> void:
	if not _verbose:
		return
	var focused_node := scene().get_viewport().gui_get_focus_owner()
	if focused_node:
		prints("	focus checked %s" % focused_node)
	else:
		prints("	no focus set")


func scene() -> Node:
	if is_instance_valid(_current_scene):
		return _current_scene
	if not _is_disposed:
		push_error("The current scene instance is not valid anymore! check your test is valid. e.g. check for missing awaits.")
	return null
class_name GdUnitScriptType
extends RefCounted

const UNKNOWN := ""
const CS := "cs"
const GD := "gd"


static func type_of(script :Script) -> String:
	if script == null:
		return UNKNOWN
	if GdObjects.is_gd_script(script):
		return GD
	if GdObjects.is_cs_script(script):
		return CS
	return UNKNOWN
@tool
class_name GdUnitSettings
extends RefCounted


const MAIN_CATEGORY = "gdunit4"
# Common Settings
const COMMON_SETTINGS = MAIN_CATEGORY + "/settings"

const GROUP_COMMON = COMMON_SETTINGS + "/common"
const UPDATE_NOTIFICATION_ENABLED = GROUP_COMMON + "/update_notification_enabled"
const SERVER_TIMEOUT = GROUP_COMMON + "/server_connection_timeout_minutes"

const GROUP_TEST = COMMON_SETTINGS + "/test"
const TEST_TIMEOUT = GROUP_TEST + "/test_timeout_seconds"
const TEST_LOOKUP_FOLDER = GROUP_TEST + "/test_lookup_folder"
const TEST_SUITE_NAMING_CONVENTION = GROUP_TEST + "/test_suite_naming_convention"
const TEST_DISCOVER_ENABLED = GROUP_TEST + "/test_discovery"
const TEST_FLAKY_CHECK = GROUP_TEST + "/flaky_check_enable"
const TEST_FLAKY_MAX_RETRIES = GROUP_TEST + "/flaky_max_retries"


# Report Setiings
const REPORT_SETTINGS = MAIN_CATEGORY + "/report"
const GROUP_GODOT = REPORT_SETTINGS + "/godot"
const REPORT_PUSH_ERRORS = GROUP_GODOT + "/push_error"
const REPORT_SCRIPT_ERRORS = GROUP_GODOT + "/script_error"
const REPORT_ORPHANS  = REPORT_SETTINGS + "/verbose_orphans"
const GROUP_ASSERT = REPORT_SETTINGS + "/assert"
const REPORT_ASSERT_WARNINGS = GROUP_ASSERT + "/verbose_warnings"
const REPORT_ASSERT_ERRORS   = GROUP_ASSERT + "/verbose_errors"
const REPORT_ASSERT_STRICT_NUMBER_TYPE_COMPARE = GROUP_ASSERT + "/strict_number_type_compare"

# Godot debug stdout/logging settings
const CATEGORY_LOGGING := "debug/file_logging/"
const STDOUT_ENABLE_TO_FILE = CATEGORY_LOGGING + "enable_file_logging"
const STDOUT_WITE_TO_FILE = CATEGORY_LOGGING + "log_path"


# GdUnit Templates
const TEMPLATES = MAIN_CATEGORY + "/templates"
const TEMPLATES_TS = TEMPLATES + "/testsuite"
const TEMPLATE_TS_GD = TEMPLATES_TS + "/GDScript"
const TEMPLATE_TS_CS = TEMPLATES_TS + "/CSharpScript"


# UI Setiings
const UI_SETTINGS = MAIN_CATEGORY + "/ui"
const GROUP_UI_INSPECTOR = UI_SETTINGS + "/inspector"
const INSPECTOR_NODE_COLLAPSE = GROUP_UI_INSPECTOR + "/node_collapse"
const INSPECTOR_TREE_VIEW_MODE = GROUP_UI_INSPECTOR + "/tree_view_mode"
const INSPECTOR_TREE_SORT_MODE = GROUP_UI_INSPECTOR + "/tree_sort_mode"


# Shortcut Setiings
const SHORTCUT_SETTINGS = MAIN_CATEGORY + "/Shortcuts"
const GROUP_SHORTCUT_INSPECTOR = SHORTCUT_SETTINGS + "/inspector"
const SHORTCUT_INSPECTOR_RERUN_TEST = GROUP_SHORTCUT_INSPECTOR + "/rerun_test"
const SHORTCUT_INSPECTOR_RERUN_TEST_DEBUG = GROUP_SHORTCUT_INSPECTOR + "/rerun_test_debug"
const SHORTCUT_INSPECTOR_RUN_TEST_OVERALL = GROUP_SHORTCUT_INSPECTOR + "/run_test_overall"
const SHORTCUT_INSPECTOR_RUN_TEST_STOP = GROUP_SHORTCUT_INSPECTOR + "/run_test_stop"

const GROUP_SHORTCUT_EDITOR = SHORTCUT_SETTINGS + "/editor"
const SHORTCUT_EDITOR_RUN_TEST = GROUP_SHORTCUT_EDITOR + "/run_test"
const SHORTCUT_EDITOR_RUN_TEST_DEBUG = GROUP_SHORTCUT_EDITOR + "/run_test_debug"
const SHORTCUT_EDITOR_CREATE_TEST = GROUP_SHORTCUT_EDITOR + "/create_test"

const GROUP_SHORTCUT_FILESYSTEM = SHORTCUT_SETTINGS + "/filesystem"
const SHORTCUT_FILESYSTEM_RUN_TEST = GROUP_SHORTCUT_FILESYSTEM + "/run_test"
const SHORTCUT_FILESYSTEM_RUN_TEST_DEBUG = GROUP_SHORTCUT_FILESYSTEM + "/run_test_debug"


# Toolbar Setiings
const GROUP_UI_TOOLBAR = UI_SETTINGS + "/toolbar"
const INSPECTOR_TOOLBAR_BUTTON_RUN_OVERALL = GROUP_UI_TOOLBAR + "/run_overall"

# defaults
# server connection timeout in minutes
const DEFAULT_SERVER_TIMEOUT :int = 30
# test case runtime timeout in seconds
const DEFAULT_TEST_TIMEOUT :int = 60*5
# the folder to create new test-suites
const DEFAULT_TEST_LOOKUP_FOLDER := "test"

# help texts
const HELP_TEST_LOOKUP_FOLDER := "Subfolder where test suites are located (or empty to use source folder directly)"

enum NAMING_CONVENTIONS {
	AUTO_DETECT,
	SNAKE_CASE,
	PASCAL_CASE,
}


const _VALUE_SET_SEPARATOR = "\f" # ASCII Form-feed character (AKA page break)


static func setup() -> void:
	create_property_if_need(UPDATE_NOTIFICATION_ENABLED, true, "Show notification if new gdUnit4 version is found")
	# test settings
	create_property_if_need(SERVER_TIMEOUT, DEFAULT_SERVER_TIMEOUT, "Server connection timeout in minutes")
	create_property_if_need(TEST_TIMEOUT, DEFAULT_TEST_TIMEOUT, "Test case runtime timeout in seconds")
	create_property_if_need(TEST_LOOKUP_FOLDER, DEFAULT_TEST_LOOKUP_FOLDER, HELP_TEST_LOOKUP_FOLDER)
	create_property_if_need(TEST_SUITE_NAMING_CONVENTION, NAMING_CONVENTIONS.AUTO_DETECT, "Naming convention to use when generating testsuites", NAMING_CONVENTIONS.keys())
	create_property_if_need(TEST_DISCOVER_ENABLED, false, "Automatically detect new tests in test lookup folders at runtime")
	create_property_if_need(TEST_FLAKY_CHECK, false, "Rerun tests on failure and mark them as FLAKY")
	create_property_if_need(TEST_FLAKY_MAX_RETRIES, 3, "Sets the number of retries for rerunning a flaky test")
	# report settings
	create_property_if_need(REPORT_PUSH_ERRORS, false, "Report push_error() as failure")
	create_property_if_need(REPORT_SCRIPT_ERRORS, true, "Report script errors as failure")
	create_property_if_need(REPORT_ORPHANS, true, "Report orphaned nodes after tests finish")
	create_property_if_need(REPORT_ASSERT_ERRORS, true, "Report assertion failures as errors")
	create_property_if_need(REPORT_ASSERT_WARNINGS, true, "Report assertion failures as warnings")
	create_property_if_need(REPORT_ASSERT_STRICT_NUMBER_TYPE_COMPARE, true, "Compare number values strictly by type (real vs int)")
	# inspector
	create_property_if_need(INSPECTOR_NODE_COLLAPSE, true,
		"Close testsuite node after a successful test run.")
	create_property_if_need(INSPECTOR_TREE_VIEW_MODE, GdUnitInspectorTreeConstants.TREE_VIEW_MODE.TREE,
		"Inspector panel presentation mode", GdUnitInspectorTreeConstants.TREE_VIEW_MODE.keys())
	create_property_if_need(INSPECTOR_TREE_SORT_MODE, GdUnitInspectorTreeConstants.SORT_MODE.UNSORTED,
		"Inspector panel sorting mode", GdUnitInspectorTreeConstants.SORT_MODE.keys())
	create_property_if_need(INSPECTOR_TOOLBAR_BUTTON_RUN_OVERALL, false,
		"Show 'Run overall Tests' button in the inspector toolbar")
	create_property_if_need(TEMPLATE_TS_GD, GdUnitTestSuiteTemplate.default_GD_template(), "Test suite template to use")
	create_shortcut_properties_if_need()
	migrate_properties()


static func migrate_properties() -> void:
	var TEST_ROOT_FOLDER := "gdunit4/settings/test/test_root_folder"
	if get_property(TEST_ROOT_FOLDER) != null:
		migrate_property(TEST_ROOT_FOLDER,\
			TEST_LOOKUP_FOLDER,\
			DEFAULT_TEST_LOOKUP_FOLDER,\
			HELP_TEST_LOOKUP_FOLDER,\
			func(value :Variant) -> String: return DEFAULT_TEST_LOOKUP_FOLDER if value == null else value)


static func create_shortcut_properties_if_need() -> void:
	# inspector
	create_property_if_need(SHORTCUT_INSPECTOR_RERUN_TEST, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.RERUN_TESTS), "Rerun the most recently executed tests")
	create_property_if_need(SHORTCUT_INSPECTOR_RERUN_TEST_DEBUG, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG), "Rerun the most recently executed tests (Debug mode)")
	create_property_if_need(SHORTCUT_INSPECTOR_RUN_TEST_OVERALL, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL), "Runs all tests (Debug mode)")
	create_property_if_need(SHORTCUT_INSPECTOR_RUN_TEST_STOP, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.STOP_TEST_RUN), "Stop the current test execution")
	# script editor
	create_property_if_need(SHORTCUT_EDITOR_RUN_TEST, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.RUN_TESTCASE), "Run the currently selected test")
	create_property_if_need(SHORTCUT_EDITOR_RUN_TEST_DEBUG, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.RUN_TESTCASE_DEBUG), "Run the currently selected test (Debug mode).")
	create_property_if_need(SHORTCUT_EDITOR_CREATE_TEST, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.CREATE_TEST), "Create a new test case for the currently selected function")
	# filesystem
	create_property_if_need(SHORTCUT_FILESYSTEM_RUN_TEST, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.NONE), "Run all test suites in the selected folder or file")
	create_property_if_need(SHORTCUT_FILESYSTEM_RUN_TEST_DEBUG, GdUnitShortcut.default_keys(GdUnitShortcut.ShortCut.NONE), "Run all test suites in the selected folder or file (Debug)")


static func create_property_if_need(name :String, default :Variant, help :="", value_set := PackedStringArray()) -> void:
	if not ProjectSettings.has_setting(name):
		#prints("GdUnit4: Set inital settings '%s' to '%s'." % [name, str(default)])
		ProjectSettings.set_setting(name, default)

	ProjectSettings.set_initial_value(name, default)
	help = help if value_set.is_empty() else "%s%s%s" % [help, _VALUE_SET_SEPARATOR, value_set]
	set_help(name, default, help)


static func set_help(property_name :String, value :Variant, help :String) -> void:
	ProjectSettings.add_property_info({
		"name": property_name,
		"type": typeof(value),
		"hint": PROPERTY_HINT_TYPE_STRING,
		"hint_string": help
	})


static func get_setting(name :String, default :Variant) -> Variant:
	if ProjectSettings.has_setting(name):
		return ProjectSettings.get_setting(name)
	return default


static func is_update_notification_enabled() -> bool:
	if ProjectSettings.has_setting(UPDATE_NOTIFICATION_ENABLED):
		return ProjectSettings.get_setting(UPDATE_NOTIFICATION_ENABLED)
	return false


static func set_update_notification(enable :bool) -> void:
	ProjectSettings.set_setting(UPDATE_NOTIFICATION_ENABLED, enable)
	@warning_ignore("return_value_discarded")
	ProjectSettings.save()


static func get_log_path() -> String:
	return ProjectSettings.get_setting(STDOUT_WITE_TO_FILE)


static func set_log_path(path :String) -> void:
	ProjectSettings.set_setting(STDOUT_ENABLE_TO_FILE, true)
	ProjectSettings.set_setting(STDOUT_WITE_TO_FILE, path)
	@warning_ignore("return_value_discarded")
	ProjectSettings.save()


static func set_inspector_tree_sort_mode(sort_mode: GdUnitInspectorTreeConstants.SORT_MODE) -> void:
	var property := get_property(INSPECTOR_TREE_SORT_MODE)
	property.set_value(sort_mode)
	update_property(property)


static func get_inspector_tree_sort_mode() -> GdUnitInspectorTreeConstants.SORT_MODE:
	var property := get_property(INSPECTOR_TREE_SORT_MODE)
	return property.value() if property != null else GdUnitInspectorTreeConstants.SORT_MODE.UNSORTED


static func set_inspector_tree_view_mode(tree_view_mode: GdUnitInspectorTreeConstants.TREE_VIEW_MODE) -> void:
	var property := get_property(INSPECTOR_TREE_VIEW_MODE)
	property.set_value(tree_view_mode)
	update_property(property)


static func get_inspector_tree_view_mode() -> GdUnitInspectorTreeConstants.TREE_VIEW_MODE:
	var property := get_property(INSPECTOR_TREE_VIEW_MODE)
	return property.value() if property != null else GdUnitInspectorTreeConstants.TREE_VIEW_MODE.TREE


# the configured server connection timeout in ms
static func server_timeout() -> int:
	return get_setting(SERVER_TIMEOUT, DEFAULT_SERVER_TIMEOUT) * 60 * 1000


# the configured test case timeout in ms
static func test_timeout() -> int:
	return get_setting(TEST_TIMEOUT, DEFAULT_TEST_TIMEOUT) * 1000


# the root folder to store/generate test-suites
static func test_root_folder() -> String:
	return get_setting(TEST_LOOKUP_FOLDER, DEFAULT_TEST_LOOKUP_FOLDER)


static func is_verbose_assert_warnings() -> bool:
	return get_setting(REPORT_ASSERT_WARNINGS, true)


static func is_verbose_assert_errors() -> bool:
	return get_setting(REPORT_ASSERT_ERRORS, true)


static func is_verbose_orphans() -> bool:
	return get_setting(REPORT_ORPHANS, true)


static func is_strict_number_type_compare() -> bool:
	return get_setting(REPORT_ASSERT_STRICT_NUMBER_TYPE_COMPARE, true)


static func is_report_push_errors() -> bool:
	return get_setting(REPORT_PUSH_ERRORS, false)


static func is_report_script_errors() -> bool:
	return get_setting(REPORT_SCRIPT_ERRORS, true)


static func is_inspector_node_collapse() -> bool:
	return get_setting(INSPECTOR_NODE_COLLAPSE, true)


static func is_inspector_toolbar_button_show() -> bool:
	return get_setting(INSPECTOR_TOOLBAR_BUTTON_RUN_OVERALL, true)


static func is_test_discover_enabled() -> bool:
	return get_setting(TEST_DISCOVER_ENABLED, false)


static func is_test_flaky_check_enabled() -> bool:
	return get_setting(TEST_FLAKY_CHECK, false)


static func get_flaky_max_retries() -> int:
	return get_setting(TEST_FLAKY_MAX_RETRIES, 3)


static func set_test_discover_enabled(enable :bool) -> void:
	var property := get_property(TEST_DISCOVER_ENABLED)
	property.set_value(enable)
	update_property(property)


static func is_log_enabled() -> bool:
	return ProjectSettings.get_setting(STDOUT_ENABLE_TO_FILE)


static func list_settings(category: String) -> Array[GdUnitProperty]:
	var settings: Array[GdUnitProperty] = []
	for property in ProjectSettings.get_property_list():
		var property_name :String = property["name"]
		if property_name.begins_with(category):
			settings.append(build_property(property_name, property))
	return settings


static func extract_value_set_from_help(value :String) -> PackedStringArray:
	var split_value := value.split(_VALUE_SET_SEPARATOR)
	if not split_value.size() > 1:
		return PackedStringArray()

	var regex := RegEx.new()
	@warning_ignore("return_value_discarded")
	regex.compile("\\[(.+)\\]")
	var matches := regex.search_all(split_value[1])
	if matches.is_empty():
		return PackedStringArray()
	var values: String = matches[0].get_string(1)
	return values.replacen(" ", "").replacen("\"", "").split(",", false)


static func extract_help_text(value :String) -> String:
	return value.split(_VALUE_SET_SEPARATOR)[0]


static func update_property(property :GdUnitProperty) -> Variant:
	var current_value :Variant = ProjectSettings.get_setting(property.name())
	if current_value != property.value():
		var error :Variant = validate_property_value(property)
		if error != null:
			return error
		ProjectSettings.set_setting(property.name(), property.value())
		GdUnitSignals.instance().gdunit_settings_changed.emit(property)
		_save_settings()
	return null


static func reset_property(property :GdUnitProperty) -> void:
	ProjectSettings.set_setting(property.name(), property.default())
	GdUnitSignals.instance().gdunit_settings_changed.emit(property)
	_save_settings()


static func validate_property_value(property :GdUnitProperty) -> Variant:
	match property.name():
		TEST_LOOKUP_FOLDER:
			return validate_lookup_folder(property.value_as_string())
		_: return null


static func validate_lookup_folder(value :String) -> Variant:
	if value.is_empty() or value == "/":
		return null
	if value.contains("res:"):
		return "Test Lookup Folder: do not allowed to contains 'res://'"
	if not value.is_valid_filename():
		return "Test Lookup Folder: contains invalid characters! e.g (: / \\ ? * \" | % < >)"
	return null


static func save_property(name :String, value :Variant) -> void:
	ProjectSettings.set_setting(name, value)
	_save_settings()


static func _save_settings() -> void:
	var err := ProjectSettings.save()
	if err != OK:
		push_error("Save GdUnit4 settings failed : %s" % error_string(err))
		return


static func has_property(name :String) -> bool:
	return ProjectSettings.get_property_list().any(func(property :Dictionary) -> bool: return property["name"] == name)


static func get_property(name :String) -> GdUnitProperty:
	for property in ProjectSettings.get_property_list():
		var property_name :String = property["name"]
		if property_name == name:
			return build_property(name, property)
	return null


static func build_property(property_name: String, property: Dictionary) -> GdUnitProperty:
	var value: Variant = ProjectSettings.get_setting(property_name)
	var value_type: int = property["type"]
	var default: Variant = ProjectSettings.property_get_revert(property_name)
	var help: String = property["hint_string"]
	var value_set := extract_value_set_from_help(help)
	return GdUnitProperty.new(property_name, value_type, value, default, extract_help_text(help), value_set)


static func migrate_property(old_property :String, new_property :String, default_value :Variant, help :String, converter := Callable()) -> void:
	var property := get_property(old_property)
	if property == null:
		prints("Migration not possible, property '%s' not found" % old_property)
		return
	var value :Variant = converter.call(property.value()) if converter.is_valid() else property.value()
	ProjectSettings.set_setting(new_property, value)
	ProjectSettings.set_initial_value(new_property, default_value)
	set_help(new_property, value, help)
	ProjectSettings.clear(old_property)
	prints("Successfully migrated property '%s' -> '%s' value: %s" % [old_property, new_property, value])


static func dump_to_tmp() -> void:
	@warning_ignore("return_value_discarded")
	ProjectSettings.save_custom("user://project_settings.godot")


static func restore_dump_from_tmp() -> void:
	@warning_ignore("return_value_discarded")
	DirAccess.copy_absolute("user://project_settings.godot", "res://project.godot")
class_name GdUnitSignalAwaiter
extends RefCounted

signal signal_emitted(action :Variant)

const NO_ARG :Variant = GdUnitConstants.NO_ARG

var _wait_on_idle_frame := false
var _interrupted := false
var _time_left :float = 0
var _timeout_millis :int


func _init(timeout_millis :int, wait_on_idle_frame := false) -> void:
	_timeout_millis = timeout_millis
	_wait_on_idle_frame = wait_on_idle_frame


func _on_signal_emmited(
	arg0 :Variant = NO_ARG,
	arg1 :Variant = NO_ARG,
	arg2 :Variant = NO_ARG,
	arg3 :Variant = NO_ARG,
	arg4 :Variant = NO_ARG,
	arg5 :Variant = NO_ARG,
	arg6 :Variant = NO_ARG,
	arg7 :Variant = NO_ARG,
	arg8 :Variant = NO_ARG,
	arg9 :Variant = NO_ARG) -> void:
	var signal_args :Variant = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], NO_ARG)
	signal_emitted.emit(signal_args)


func is_interrupted() -> bool:
	return _interrupted


func elapsed_time() -> float:
	return _time_left


func on_signal(source :Object, signal_name :String, expected_signal_args :Array) -> Variant:
	# register checked signal to wait for
	@warning_ignore("return_value_discarded")
	source.connect(signal_name, _on_signal_emmited)
	# install timeout timer
	var scene_tree := Engine.get_main_loop() as SceneTree
	var timer := Timer.new()
	scene_tree.root.add_child(timer)
	timer.add_to_group("GdUnitTimers")
	timer.set_one_shot(true)
	@warning_ignore("return_value_discarded")
	timer.timeout.connect(_do_interrupt, CONNECT_DEFERRED)
	timer.start(_timeout_millis * 0.001 * Engine.get_time_scale())

	# holds the emited value
	var value :Variant
	# wait for signal is emitted or a timeout is happen
	while true:
		value = await signal_emitted
		if _interrupted:
			break
		if not (value is Array):
			value = [value]
		if expected_signal_args.size() == 0 or GdObjects.equals(value, expected_signal_args):
			break
		await scene_tree.process_frame

	source.disconnect(signal_name, _on_signal_emmited)
	_time_left = timer.time_left
	await scene_tree.process_frame
	@warning_ignore("unsafe_cast")
	if value is Array and (value as Array).size() == 1:
		return value[0]
	return value


func _do_interrupt() -> void:
	_interrupted = true
	signal_emitted.emit(null)
# It connects to all signals of given emitter and collects received signals and arguments
# The collected signals are cleand finally when the emitter is freed.
class_name GdUnitSignalCollector
extends RefCounted

const NO_ARG :Variant = GdUnitConstants.NO_ARG
const SIGNAL_BLACK_LIST = []#["tree_exiting", "tree_exited", "child_exiting_tree"]

# {
#	emitter<Object> : {
#		signal_name<String> : [signal_args<Array>],
#		...
#	}
# }
var _collected_signals :Dictionary = {}


func clear() -> void:
	for emitter :Object in _collected_signals.keys():
		if is_instance_valid(emitter):
			unregister_emitter(emitter)


# connect to all possible signals defined by the emitter
# prepares the signal collection to store received signals and arguments
func register_emitter(emitter :Object) -> void:
	if is_instance_valid(emitter):
		# check emitter is already registerd
		if _collected_signals.has(emitter):
			return
		_collected_signals[emitter] = Dictionary()
		# connect to 'tree_exiting' of the emitter to finally release all acquired resources/connections.
		if emitter is Node and !(emitter as Node).tree_exiting.is_connected(unregister_emitter):
			(emitter as Node).tree_exiting.connect(unregister_emitter.bind(emitter))
		# connect to all signals of the emitter we want to collect
		for signal_def in emitter.get_signal_list():
			var signal_name :String = signal_def["name"]
			# set inital collected to empty
			if not is_signal_collecting(emitter, signal_name):
				_collected_signals[emitter][signal_name] = Array()
			if SIGNAL_BLACK_LIST.find(signal_name) != -1:
				continue
			if !emitter.is_connected(signal_name, _on_signal_emmited):
				var err := emitter.connect(signal_name, _on_signal_emmited.bind(emitter, signal_name))
				if err != OK:
					push_error("Can't connect to signal %s on %s. Error: %s" % [signal_name, emitter, error_string(err)])


# unregister all acquired resources/connections, otherwise it ends up in orphans
# is called when the emitter is removed from the parent
func unregister_emitter(emitter :Object) -> void:
	if is_instance_valid(emitter):
		for signal_def in emitter.get_signal_list():
			var signal_name :String = signal_def["name"]
			if emitter.is_connected(signal_name, _on_signal_emmited):
				emitter.disconnect(signal_name, _on_signal_emmited.bind(emitter, signal_name))
		@warning_ignore("return_value_discarded")
		_collected_signals.erase(emitter)


# receives the signal from the emitter with all emitted signal arguments and additional the emitter and signal_name as last two arguements
func _on_signal_emmited(
	arg0 :Variant= NO_ARG,
	arg1 :Variant= NO_ARG,
	arg2 :Variant= NO_ARG,
	arg3 :Variant= NO_ARG,
	arg4 :Variant= NO_ARG,
	arg5 :Variant= NO_ARG,
	arg6 :Variant= NO_ARG,
	arg7 :Variant= NO_ARG,
	arg8 :Variant= NO_ARG,
	arg9 :Variant= NO_ARG,
	arg10 :Variant= NO_ARG,
	arg11 :Variant= NO_ARG) -> void:
	var signal_args :Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11], NO_ARG)
	# extract the emitter and signal_name from the last two arguments (see line 61 where is added)
	var signal_name :String = signal_args.pop_back()
	var emitter :Object = signal_args.pop_back()
	#prints("_on_signal_emmited:", emitter, signal_name, signal_args)
	if is_signal_collecting(emitter, signal_name):
		@warning_ignore("unsafe_cast")
		(_collected_signals[emitter][signal_name] as Array).append(signal_args)


func reset_received_signals(emitter :Object, signal_name: String, signal_args :Array) -> void:
	#_debug_signal_list("before claer");
	if _collected_signals.has(emitter):
		var signals_by_emitter :Dictionary = _collected_signals[emitter]
		if signals_by_emitter.has(signal_name):
			@warning_ignore("unsafe_cast")
			(_collected_signals[emitter][signal_name] as Array).erase(signal_args)
	#_debug_signal_list("after claer");


func is_signal_collecting(emitter :Object, signal_name :String) -> bool:
	@warning_ignore("unsafe_cast")
	return _collected_signals.has(emitter) and (_collected_signals[emitter] as Dictionary).has(signal_name)


func match(emitter :Object, signal_name :String, args :Array) -> bool:
	#prints("match", signal_name,  _collected_signals[emitter][signal_name]);
	if _collected_signals.is_empty() or not _collected_signals.has(emitter):
		return false
	for received_args :Variant in _collected_signals[emitter][signal_name]:
		#prints("testing", signal_name, received_args, "vs", args)
		if GdObjects.equals(received_args, args):
			return true
	return false


func _debug_signal_list(message :String) -> void:
	prints("-----", message, "-------")
	prints("senders {")
	for emitter :Object in _collected_signals:
		prints("\t", emitter)
		for signal_name :String in _collected_signals[emitter]:
			var args :Variant = _collected_signals[emitter][signal_name]
			prints("\t\t", signal_name, args)
	prints("}")
class_name GdUnitSignals
extends RefCounted

@warning_ignore("unused_signal")
signal gdunit_client_connected(client_id :int)
@warning_ignore("unused_signal")
signal gdunit_client_disconnected(client_id :int)
@warning_ignore("unused_signal")
signal gdunit_client_terminated()

@warning_ignore("unused_signal")
signal gdunit_event(event :GdUnitEvent)
@warning_ignore("unused_signal")
signal gdunit_event_debug(event :GdUnitEvent)
@warning_ignore("unused_signal")
signal gdunit_add_test_suite(test_suite :GdUnitTestSuiteDto)
@warning_ignore("unused_signal")
signal gdunit_message(message :String)
@warning_ignore("unused_signal")
signal gdunit_set_test_failed(is_failed :bool)
@warning_ignore("unused_signal")
signal gdunit_settings_changed(property :GdUnitProperty)

const META_KEY := "GdUnitSignals"


static func instance() -> GdUnitSignals:
	if Engine.has_meta(META_KEY):
		return Engine.get_meta(META_KEY)
	var instance_ := GdUnitSignals.new()
	Engine.set_meta(META_KEY, instance_)
	return instance_


static func dispose() -> void:
	var signals := instance()
	# cleanup connected signals
	for signal_ in signals.get_signal_list():
		@warning_ignore("unsafe_cast")
		for connection in signals.get_signal_connection_list(signal_["name"] as StringName):
			var _signal: Signal = connection["signal"]
			var _callable: Callable = connection["callable"]
			_signal.disconnect(_callable)
	signals = null
	Engine.remove_meta(META_KEY)
################################################################################
# Provides access to a global accessible singleton
#
# This is a workarount to the existing auto load singleton because of some bugs
# around plugin handling
################################################################################
class_name GdUnitSingleton
extends Object


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const MEATA_KEY := "GdUnitSingletons"


static func instance(name :String, clazz :Callable) -> Variant:
	if Engine.has_meta(name):
		return Engine.get_meta(name)
	var singleton :Variant = clazz.call()
	if  is_instance_of(singleton, RefCounted):
		@warning_ignore("unsafe_cast")
		push_error("Invalid singleton implementation detected for '%s' is `%s`!" % [name, (singleton as RefCounted).get_class()])
		return

	Engine.set_meta(name, singleton)
	GdUnitTools.prints_verbose("Register singleton '%s:%s'" % [name, singleton])
	var singletons :PackedStringArray = Engine.get_meta(MEATA_KEY, PackedStringArray())
	@warning_ignore("return_value_discarded")
	singletons.append(name)
	Engine.set_meta(MEATA_KEY, singletons)
	return singleton


static func unregister(p_singleton :String, use_call_deferred :bool = false) -> void:
	var singletons :PackedStringArray = Engine.get_meta(MEATA_KEY, PackedStringArray())
	if singletons.has(p_singleton):
		GdUnitTools.prints_verbose("\n	Unregister singleton '%s'" % p_singleton);
		var index := singletons.find(p_singleton)
		singletons.remove_at(index)
		var instance_ :Object = Engine.get_meta(p_singleton)
		GdUnitTools.prints_verbose("	Free singleton instance '%s:%s'" % [p_singleton, instance_])
		@warning_ignore("return_value_discarded")
		GdUnitTools.free_instance(instance_, use_call_deferred)
		Engine.remove_meta(p_singleton)
		GdUnitTools.prints_verbose("	Successfully freed '%s'" % p_singleton)
	Engine.set_meta(MEATA_KEY, singletons)


static func dispose(use_call_deferred :bool = false) -> void:
	# use a copy because unregister is modify the singletons array
	var singletons :PackedStringArray = Engine.get_meta(MEATA_KEY, PackedStringArray())
	GdUnitTools.prints_verbose("----------------------------------------------------------------")
	GdUnitTools.prints_verbose("Cleanup singletons %s" % singletons)
	for singleton in PackedStringArray(singletons):
		unregister(singleton, use_call_deferred)
	Engine.remove_meta(MEATA_KEY)
	GdUnitTools.prints_verbose("----------------------------------------------------------------")
class_name GdUnitTestSuiteBuilder
extends RefCounted


static func create(source :Script, line_number :int) -> GdUnitResult:
	var test_suite_path := GdUnitTestSuiteScanner.resolve_test_suite_path(source.resource_path, GdUnitSettings.test_root_folder())
	# we need to save and close the testsuite and source if is current opened before modify
	@warning_ignore("return_value_discarded")
	ScriptEditorControls.save_an_open_script(source.resource_path)
	@warning_ignore("return_value_discarded")
	ScriptEditorControls.save_an_open_script(test_suite_path, true)
	if GdObjects.is_cs_script(source):
		return GdUnit4CSharpApiLoader.create_test_suite(source.resource_path, line_number+1, test_suite_path)
	var parser := GdScriptParser.new()
	var lines := source.source_code.split("\n")
	var current_line := lines[line_number]
	var func_name := parser.parse_func_name(current_line)
	if func_name.is_empty():
		return GdUnitResult.error("No function found at line: %d." % line_number)
	return GdUnitTestSuiteScanner.create_test_case(test_suite_path, func_name, source.resource_path)
class_name GdUnitTestSuiteScanner
extends RefCounted

const TEST_FUNC_TEMPLATE ="""

func test_${func_name}() -> void:
	# remove this line and complete your test
	assert_not_yet_implemented()
"""


# we exclude the gdunit source directorys by default
const exclude_scan_directories = [
	"res://addons/gdUnit4/bin",
	"res://addons/gdUnit4/src",
	"res://reports"]


var _script_parser := GdScriptParser.new()
var _included_resources :PackedStringArray = []
var _excluded_resources :PackedStringArray = []
var _expression_runner := GdUnitExpressionRunner.new()
var _regex_extends_clazz_name := RegEx.create_from_string("extends[\\s]+([\\S]+)")


func prescan_testsuite_classes() -> void:
	# scan and cache extends GdUnitTestSuite by class name an resource paths
	var script_classes :Array[Dictionary] = ProjectSettings.get_global_class_list()
	for script_meta in script_classes:
		var base_class :String = script_meta["base"]
		var resource_path :String = script_meta["path"]
		if base_class == "GdUnitTestSuite":
			@warning_ignore("return_value_discarded")
			_included_resources.append(resource_path)
		elif ClassDB.class_exists(base_class):
			@warning_ignore("return_value_discarded")
			_excluded_resources.append(resource_path)


func scan(resource_path :String) -> Array[Node]:
	prescan_testsuite_classes()
	# if single testsuite requested
	if FileAccess.file_exists(resource_path):
		var test_suite := _parse_is_test_suite(resource_path)
		if test_suite != null:
			return [test_suite]
		return [] as Array[Node]
	var base_dir := DirAccess.open(resource_path)
	if base_dir == null:
			prints("Given directory or file does not exists:", resource_path)
			return []
	return _scan_test_suites(base_dir, [])


func _scan_test_suites(dir :DirAccess, collected_suites :Array[Node]) -> Array[Node]:
	if exclude_scan_directories.has(dir.get_current_dir()):
		return collected_suites
	prints("Scanning for test suites in:", dir.get_current_dir())
	@warning_ignore("return_value_discarded")
	dir.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
	var file_name := dir.get_next()
	while file_name != "":
		var resource_path := GdUnitTestSuiteScanner._file(dir, file_name)
		if dir.current_is_dir():
			var sub_dir := DirAccess.open(resource_path)
			if sub_dir != null:
				@warning_ignore("return_value_discarded")
				_scan_test_suites(sub_dir, collected_suites)
		else:
			var time := LocalTime.now()
			var test_suite := _parse_is_test_suite(resource_path)
			if test_suite:
				collected_suites.append(test_suite)
			if OS.is_stdout_verbose() and time.elapsed_since_ms() > 300:
				push_warning("Scanning of test-suite '%s' took more than 300ms: " % resource_path, time.elapsed_since())
		file_name = dir.get_next()
	return collected_suites


static func _file(dir :DirAccess, file_name :String) -> String:
	var current_dir := dir.get_current_dir()
	if current_dir.ends_with("/"):
		return current_dir + file_name
	return current_dir + "/" + file_name


func _parse_is_test_suite(resource_path :String) -> Node:
	if not GdUnitTestSuiteScanner._is_script_format_supported(resource_path):
		return null
	if GdUnit4CSharpApiLoader.is_test_suite(resource_path):
		return GdUnit4CSharpApiLoader.parse_test_suite(resource_path)

	# We use the global cache to fast scan for test suites.
	if _excluded_resources.has(resource_path):
		return null
	# Check in the global class cache whether the GdUnitTestSuite class has been extended.
	if _included_resources.has(resource_path):
		return _parse_test_suite(GdUnitTestSuiteScanner.load_with_disabled_warnings(resource_path))

	# Otherwise we need to scan manual, we need to exclude classes where direct extends form Godot classes
	# the resource loader can fail to load e.g. plugin classes with do preload other scripts
	var extends_from := get_extends_classname(resource_path)
	# If not extends is defined or extends from a Godot class
	if extends_from.is_empty() or ClassDB.class_exists(extends_from):
		return null
	# Finally, we need to load the class to determine it is a test suite
	var script := GdUnitTestSuiteScanner.load_with_disabled_warnings(resource_path)
	if not GdObjects.is_test_suite(script):
		return null
	return _parse_test_suite(script)


# We load the test suites with disabled unsafe_method_access to avoid spamming loading errors
# `unsafe_method_access` will happen when using `assert_that`
static func load_with_disabled_warnings(resource_path: String) -> GDScript:
	# grap current level
	var unsafe_method_access: Variant = ProjectSettings.get_setting("debug/gdscript/warnings/unsafe_method_access")

	# disable and load the script
	ProjectSettings.set_setting("debug/gdscript/warnings/unsafe_method_access", 0)
	var script: GDScript = ResourceLoader.load(resource_path)

	# restore
	ProjectSettings.set_setting("debug/gdscript/warnings/unsafe_method_access", unsafe_method_access)
	return script


static func _is_script_format_supported(resource_path :String) -> bool:
	var ext := resource_path.get_extension()
	if ext == "gd":
		return true
	return GdUnit4CSharpApiLoader.is_csharp_file(resource_path)


func _parse_test_suite(script: Script) -> GdUnitTestSuite:
	if not GdObjects.is_test_suite(script):
		return null

	# If test suite a C# script
	if GdUnit4CSharpApiLoader.is_test_suite(script.resource_path):
		return GdUnit4CSharpApiLoader.parse_test_suite(script.resource_path)

	# Do pares as GDScript
	var test_suite: GdUnitTestSuite = (script as GDScript).new()
	test_suite.set_name(GdUnitTestSuiteScanner.parse_test_suite_name(script))
	# add test cases to test suite and parse test case line nummber
	var test_case_names := _extract_test_case_names(script as GDScript)
	_parse_and_add_test_cases(test_suite, script as GDScript, test_case_names)
	return test_suite


func _extract_test_case_names(script :GDScript) -> PackedStringArray:
	return script.get_script_method_list()\
		.map(func(descriptor: Dictionary) -> String: return descriptor["name"])\
		.filter(func(func_name: String) -> bool: return func_name.begins_with("test"))


static func parse_test_suite_name(script :Script) -> String:
	return script.resource_path.get_file().replace(".gd", "")


func _handle_test_suite_arguments(test_suite: GdUnitTestSuite, script: GDScript, fd: GdFunctionDescriptor) -> void:
	for arg in fd.args():
		match arg.name():
			_TestCase.ARGUMENT_SKIP:
				var result: Variant = _expression_runner.execute(script, arg.plain_value())
				if result is bool:
					test_suite.__is_skipped = result
				else:
					push_error("Test expression '%s' cannot be evaluated because it is not of type bool!" % arg.plain_value())
			_TestCase.ARGUMENT_SKIP_REASON:
				test_suite.__skip_reason = arg.plain_value()
			_:
				push_error("Unsuported argument `%s` found on before() at '%s'!" % [arg.name(), script.resource_path])


func _handle_test_case_arguments(test_suite: GdUnitTestSuite, script: GDScript, fd: GdFunctionDescriptor) -> void:
	var timeout := _TestCase.DEFAULT_TIMEOUT
	var iterations := Fuzzer.ITERATION_DEFAULT_COUNT
	var seed_value := -1
	var is_skipped := false
	var skip_reason := "Unknown."
	var fuzzers: Array[GdFunctionArgument] = []
	var test := _TestCase.new()

	for arg: GdFunctionArgument in fd.args():
		# verify argument is allowed
		# is test using fuzzers?
		if arg.type() == GdObjects.TYPE_FUZZER:
			fuzzers.append(arg)
		elif arg.has_default():
			match arg.name():
				_TestCase.ARGUMENT_TIMEOUT:
					timeout = arg.default()
				_TestCase.ARGUMENT_SKIP:
					var result :Variant = _expression_runner.execute(script, arg.plain_value())
					if result is bool:
						is_skipped = result
					else:
						push_error("Test expression '%s' cannot be evaluated because it is not of type bool!" % arg.plain_value())
				_TestCase.ARGUMENT_SKIP_REASON:
					skip_reason = arg.plain_value()
				Fuzzer.ARGUMENT_ITERATIONS:
					iterations = arg.default()
				Fuzzer.ARGUMENT_SEED:
					seed_value = arg.default()
	# create new test
	@warning_ignore("return_value_discarded")
	test.configure(fd.name(), fd.line_number(), fd.source_path(), timeout, fuzzers, iterations, seed_value)
	test.set_function_descriptor(fd)
	test.skip(is_skipped, skip_reason)
	_validate_argument(fd, test)
	test_suite.add_child(test)


func _parse_and_add_test_cases(test_suite: GdUnitTestSuite, script: GDScript, test_case_names: PackedStringArray) -> void:
	var test_cases_to_find := Array(test_case_names)
	var functions_to_scan := test_case_names.duplicate()
	@warning_ignore("return_value_discarded")
	functions_to_scan.append("before")

	var function_descriptors := _script_parser.get_function_descriptors(script, functions_to_scan)
	for fd in function_descriptors:
		if fd.name() == "before":
			_handle_test_suite_arguments(test_suite, script, fd)
		if test_cases_to_find.has(fd.name()):
			_handle_test_case_arguments(test_suite, script, fd)


const TEST_CASE_ARGUMENTS = [_TestCase.ARGUMENT_TIMEOUT, _TestCase.ARGUMENT_SKIP, _TestCase.ARGUMENT_SKIP_REASON, Fuzzer.ARGUMENT_ITERATIONS, Fuzzer.ARGUMENT_SEED]

func _validate_argument(fd :GdFunctionDescriptor, test_case :_TestCase) -> void:
	if fd.is_parameterized():
		return
	for argument in fd.args():
		if argument.type() == GdObjects.TYPE_FUZZER or argument.name() in TEST_CASE_ARGUMENTS:
			continue
		test_case.skip(true, "Unknown test case argument '%s' found." % argument.name())


# converts given file name by configured naming convention
static func _to_naming_convention(file_name :String) -> String:
	var nc :int = GdUnitSettings.get_setting(GdUnitSettings.TEST_SUITE_NAMING_CONVENTION, 0)
	match nc:
		GdUnitSettings.NAMING_CONVENTIONS.AUTO_DETECT:
			if GdObjects.is_snake_case(file_name):
				return GdObjects.to_snake_case(file_name + "Test")
			return GdObjects.to_pascal_case(file_name + "Test")
		GdUnitSettings.NAMING_CONVENTIONS.SNAKE_CASE:
			return GdObjects.to_snake_case(file_name + "Test")
		GdUnitSettings.NAMING_CONVENTIONS.PASCAL_CASE:
			return GdObjects.to_pascal_case(file_name + "Test")
	push_error("Unexpected case")
	return "-<Unexpected>-"


static func resolve_test_suite_path(source_script_path :String, test_root_folder :String = "test") -> String:
	var file_name := source_script_path.get_basename().get_file()
	var suite_name := _to_naming_convention(file_name)
	if test_root_folder.is_empty() or test_root_folder == "/":
		return source_script_path.replace(file_name, suite_name)

	# is user tmp
	if source_script_path.begins_with("user://tmp"):
		return normalize_path(source_script_path.replace("user://tmp", "user://tmp/" + test_root_folder)).replace(file_name, suite_name)

	# at first look up is the script under a "src" folder located
	var test_suite_path :String
	var src_folder := source_script_path.find("/src/")
	if src_folder != -1:
		test_suite_path = source_script_path.replace("/src/", "/"+test_root_folder+"/")
	else:
		var paths := source_script_path.split("/", false)
		# is a plugin script?
		if paths[1] == "addons":
			test_suite_path = "%s//addons/%s/%s" % [paths[0], paths[2], test_root_folder]
			# rebuild plugin path
			for index in range(3, paths.size()):
				test_suite_path += "/" + paths[index]
		else:
			test_suite_path = paths[0] + "//" + test_root_folder
			for index in range(1, paths.size()):
				test_suite_path += "/" + paths[index]
	return normalize_path(test_suite_path).replace(file_name, suite_name)


static func normalize_path(path :String) -> String:
	return path.replace("///", "/")


static func create_test_suite(test_suite_path :String, source_path :String) -> GdUnitResult:
	# create directory if not exists
	if not DirAccess.dir_exists_absolute(test_suite_path.get_base_dir()):
		var error_ := DirAccess.make_dir_recursive_absolute(test_suite_path.get_base_dir())
		if error_ != OK:
			return GdUnitResult.error("Can't create directoy  at: %s. Error code %s" % [test_suite_path.get_base_dir(), error_])
	var script := GDScript.new()
	script.source_code = GdUnitTestSuiteTemplate.build_template(source_path)
	var error := ResourceSaver.save(script, test_suite_path)
	if error != OK:
		return GdUnitResult.error("Can't create test suite at: %s. Error code %s" % [test_suite_path, error])
	return GdUnitResult.success(test_suite_path)


static func get_test_case_line_number(resource_path :String, func_name :String) -> int:
	var file := FileAccess.open(resource_path, FileAccess.READ)
	if file != null:
		var line_number := 0
		while not file.eof_reached():
			var row := file.get_line()
			line_number += 1
			# ignore comments and empty lines and not test functions
			if row.begins_with("#") || row.length() == 0 || row.find("func test_") == -1:
				continue
			# abort if test case name found
			if row.find("func") != -1 and row.find("test_" + func_name) != -1:
				return line_number
	return -1


func get_extends_classname(resource_path :String) -> String:
	var file := FileAccess.open(resource_path, FileAccess.READ)
	if file != null:
		while not file.eof_reached():
			var row := file.get_line()
			# skip comments and empty lines
			if row.begins_with("#") || row.length() == 0:
				continue
			# Stop at first function
			if row.contains("func"):
				return ""
			var result := _regex_extends_clazz_name.search(row)
			if result != null:
				return result.get_string(1)
	return ""


static func add_test_case(resource_path :String, func_name :String)  -> GdUnitResult:
	var script := load_with_disabled_warnings(resource_path)
	# count all exiting lines and add two as space to add new test case
	var line_number := count_lines(script) + 2
	var func_body := TEST_FUNC_TEMPLATE.replace("${func_name}", func_name)
	if Engine.is_editor_hint():
		var settings := EditorInterface.get_editor_settings()
		var ident_type :int = settings.get_setting("text_editor/behavior/indent/type")
		var ident_size :int = settings.get_setting("text_editor/behavior/indent/size")
		if ident_type == 1:
			func_body = func_body.replace("	", "".lpad(ident_size, " "))
	script.source_code += func_body
	var error := ResourceSaver.save(script, resource_path)
	if error != OK:
		return GdUnitResult.error("Can't add test case at: %s to '%s'. Error code %s" % [func_name, resource_path, error])
	return GdUnitResult.success({ "path" : resource_path, "line" : line_number})


static func count_lines(script : GDScript) -> int:
	return script.source_code.split("\n").size()


static func test_suite_exists(test_suite_path :String) -> bool:
	return FileAccess.file_exists(test_suite_path)

static func test_case_exists(test_suite_path :String, func_name :String) -> bool:
	if not test_suite_exists(test_suite_path):
		return false
	var script := load_with_disabled_warnings(test_suite_path)
	for f in script.get_script_method_list():
		if f["name"] == "test_" + func_name:
			return true
	return false

static func create_test_case(test_suite_path :String, func_name :String, source_script_path :String) -> GdUnitResult:
	if test_case_exists(test_suite_path, func_name):
		var line_number := get_test_case_line_number(test_suite_path, func_name)
		return GdUnitResult.success({ "path" : test_suite_path, "line" : line_number})

	if not test_suite_exists(test_suite_path):
		var result := create_test_suite(test_suite_path, source_script_path)
		if result.is_error():
			return result
	return add_test_case(test_suite_path, func_name)
extends RefCounted


static var _richtext_normalize: RegEx


static func normalize_text(text :String) -> String:
	return text.replace("\r", "");


static func richtext_normalize(input :String) -> String:
	if _richtext_normalize == null:
		_richtext_normalize = to_regex("\\[/?(b|color|bgcolor|right|table|cell).*?\\]")
	return _richtext_normalize.sub(input, "", true).replace("\r", "")


static func to_regex(pattern :String) -> RegEx:
	var regex := RegEx.new()
	var err := regex.compile(pattern)
	if err != OK:
		push_error("Can't compiling regx '%s'.\n ERROR: %s" % [pattern, error_string(err)])
	return regex


static func prints_verbose(message :String) -> void:
	if OS.is_stdout_verbose():
		prints(message)


@warning_ignore("unsafe_cast")
static func free_instance(instance :Variant, use_call_deferred :bool = false, is_stdout_verbose := false) -> bool:
	if instance is Array:
		for element :Variant in instance:
			@warning_ignore("return_value_discarded")
			free_instance(element)
		(instance as Array).clear()
		return true
	# do not free an already freed instance
	if not is_instance_valid(instance):
		return false
	# do not free a class refernece
	if typeof(instance) == TYPE_OBJECT and (instance as Object).is_class("GDScriptNativeClass"):
		return false
	if is_stdout_verbose:
		print_verbose("GdUnit4:gc():free instance ", instance)
	release_double(instance as Object)
	if instance is RefCounted:
		(instance as RefCounted).notification(Object.NOTIFICATION_PREDELETE)
		# If scene runner freed we explicit await all inputs are processed
		if instance is GdUnitSceneRunnerImpl:
			await (instance as GdUnitSceneRunnerImpl).await_input_processed()
		return true
	else:
		if instance is Timer:
			var timer := instance as Timer
			timer.stop()
			if use_call_deferred:
				timer.call_deferred("free")
			else:
				timer.free()
				await (Engine.get_main_loop() as SceneTree).process_frame
			return true

		if instance is Node and (instance as Node).get_parent() != null:
			var node := instance as Node
			if is_stdout_verbose:
				print_verbose("GdUnit4:gc():remove node from parent ", node.get_parent(), node)
			if use_call_deferred:
				node.get_parent().remove_child.call_deferred(node)
				#instance.call_deferred("set_owner", null)
			else:
				node.get_parent().remove_child(node)
		if is_stdout_verbose:
			print_verbose("GdUnit4:gc():freeing `free()` the instance ", instance)
		if use_call_deferred:
			(instance as Object).call_deferred("free")
		else:
			(instance as Object).free()
		return !is_instance_valid(instance)


static func _release_connections(instance :Object) -> void:
	if is_instance_valid(instance):
		# disconnect from all connected signals to force freeing, otherwise it ends up in orphans
		for connection in instance.get_incoming_connections():
			var signal_ :Signal = connection["signal"]
			var callable_ :Callable = connection["callable"]
			#prints(instance, connection)
			#prints("signal", signal_.get_name(), signal_.get_object())
			#prints("callable", callable_.get_object())
			if instance.has_signal(signal_.get_name()) and instance.is_connected(signal_.get_name(), callable_):
				#prints("disconnect signal", signal_.get_name(), callable_)
				instance.disconnect(signal_.get_name(), callable_)
	release_timers()


static func release_timers() -> void:
	# we go the new way to hold all gdunit timers in group 'GdUnitTimers'
	var scene_tree := Engine.get_main_loop() as SceneTree
	if scene_tree.root == null:
		return
	for node :Node in scene_tree.root.get_children():
		if is_instance_valid(node) and node.is_in_group("GdUnitTimers"):
			if is_instance_valid(node):
				scene_tree.root.remove_child.call_deferred(node)
				(node as Timer).stop()
				node.queue_free()


# the finally cleaup unfreed resources and singletons
static func dispose_all(use_call_deferred :bool = false) -> void:
	release_timers()
	GdUnitSingleton.dispose(use_call_deferred)
	GdUnitSignals.dispose()


# if instance an mock or spy we need manually freeing the self reference
static func release_double(instance :Object) -> void:
	if instance.has_method("__release_double"):
		instance.call("__release_double")


static func register_expect_interupted_by_timeout(test_suite :Node, test_case_name :String) -> void:
	var test_case: _TestCase = test_suite.find_child(test_case_name, false, false)
	test_case.expect_to_interupt()
## This service class contains helpers to wrap Godot functions and handle them carefully depending on the current Godot version
class_name GodotVersionFixures
extends RefCounted


@warning_ignore("shadowed_global_identifier")
static func type_convert(value: Variant, type: int) -> Variant:
	return convert(value, type)


@warning_ignore("shadowed_global_identifier")
static func convert(value: Variant, type: int) -> Variant:
	return type_convert(value, type)


# handle global_position fixed by https://github.com/godotengine/godot/pull/88473
static func set_event_global_position(event: InputEventMouseMotion, global_position: Vector2) -> void:
	if Engine.get_version_info().hex >= 0x40202 or Engine.get_version_info().hex == 0x40104:
		event.global_position = event.position
	else:
		event.global_position = global_position
# This class provides Date/Time functionallity to Godot
class_name LocalTime
extends Resource

enum TimeUnit {
	DEFAULT = 0,
	MILLIS = 1,
	SECOND = 2,
	MINUTE = 3,
	HOUR   = 4,
	DAY    = 5,
	MONTH  = 6,
	YEAR   = 7
}

const SECONDS_PER_MINUTE:int = 60
const MINUTES_PER_HOUR:int = 60
const HOURS_PER_DAY:int = 24
const MILLIS_PER_SECOND:int = 1000
const MILLIS_PER_MINUTE:int = MILLIS_PER_SECOND * SECONDS_PER_MINUTE
const MILLIS_PER_HOUR:int   = MILLIS_PER_MINUTE * MINUTES_PER_HOUR

var _time :int
var _hour :int
var _minute :int
var _second :int
var _millisecond :int


static func now() -> LocalTime:
	return LocalTime.new(_get_system_time_msecs())


static func of_unix_time(time_ms :int) -> LocalTime:
	return LocalTime.new(time_ms)


static func local_time(hours :int, minutes :int, seconds :int, milliseconds :int) -> LocalTime:
	return LocalTime.new(MILLIS_PER_HOUR * hours\
		+ MILLIS_PER_MINUTE * minutes\
		+ MILLIS_PER_SECOND * seconds\
		+ milliseconds)


func elapsed_since() -> String:
	return LocalTime.elapsed(LocalTime._get_system_time_msecs() - _time)


func elapsed_since_ms() -> int:
	return LocalTime._get_system_time_msecs() - _time


func plus(time_unit :TimeUnit, value :int) -> LocalTime:
	var addValue:int = 0
	match time_unit:
		TimeUnit.MILLIS:
			addValue = value
		TimeUnit.SECOND:
			addValue = value * MILLIS_PER_SECOND
		TimeUnit.MINUTE:
			addValue = value * MILLIS_PER_MINUTE
		TimeUnit.HOUR:
			addValue = value * MILLIS_PER_HOUR
	@warning_ignore("return_value_discarded")
	_init(_time + addValue)
	return self


static func elapsed(p_time_ms :int) -> String:
	var local_time_ := LocalTime.new(p_time_ms)
	if local_time_._hour > 0:
		return "%dh %dmin %ds %dms" % [local_time_._hour, local_time_._minute, local_time_._second, local_time_._millisecond]
	if local_time_._minute > 0:
		return "%dmin %ds %dms" % [local_time_._minute, local_time_._second, local_time_._millisecond]
	if local_time_._second > 0:
		return "%ds %dms" % [local_time_._second, local_time_._millisecond]
	return "%dms" % local_time_._millisecond


@warning_ignore("integer_division")
# create from epoch timestamp in ms
func _init(time :int) -> void:
	_time = time
	_hour  =  (time / MILLIS_PER_HOUR) % 24
	_minute =  (time / MILLIS_PER_MINUTE) % 60
	_second =  (time / MILLIS_PER_SECOND) % 60
	_millisecond = time % 1000


func hour() -> int:
	return _hour


func minute() -> int:
	return _minute


func second() -> int:
	return _second


func millis() -> int:
	return _millisecond


func _to_string() -> String:
	return "%02d:%02d:%02d.%03d" % [_hour, _minute, _second, _millisecond]


# wraper to old OS.get_system_time_msecs() function
static func _get_system_time_msecs() -> int:
	return Time.get_unix_time_from_system() * 1000 as int
class_name _TestCase
extends Node

signal completed()

# default timeout 5min
const DEFAULT_TIMEOUT := -1
const ARGUMENT_TIMEOUT := "timeout"
const ARGUMENT_SKIP := "do_skip"
const ARGUMENT_SKIP_REASON := "skip_reason"

var _iterations: int = 1
var _current_iteration: int = -1
var _seed: int
var _fuzzers: Array[GdFunctionArgument] = []
var _test_param_index := -1
var _line_number: int = -1
var _script_path: String
var _skipped := false
var _skip_reason := ""
var _expect_to_interupt := false
var _timer: Timer
var _interupted: bool = false
var _failed := false
var _parameter_set_resolver: GdUnitTestParameterSetResolver
var _is_disposed := false

var timeout: int = DEFAULT_TIMEOUT:
	set(value):
		timeout = value
	get:
		if timeout == DEFAULT_TIMEOUT:
			timeout = GdUnitSettings.test_timeout()
		return timeout


@warning_ignore("shadowed_variable_base_class")
func configure(p_name: String, p_line_number: int, p_script_path: String, p_timeout: int=DEFAULT_TIMEOUT, p_fuzzers: Array[GdFunctionArgument]=[], p_iterations: int=1, p_seed: int=-1) -> _TestCase:
	set_name(p_name)
	_line_number = p_line_number
	_fuzzers = p_fuzzers
	_iterations = p_iterations
	_seed = p_seed
	_script_path = p_script_path
	timeout = p_timeout
	return self


func execute(p_test_parameter := Array(), p_iteration := 0) -> void:
	_failure_received(false)
	_current_iteration = p_iteration - 1
	if _current_iteration == - 1:
		_set_failure_handler()
		set_timeout()
	if not p_test_parameter.is_empty():
		update_fuzzers(p_test_parameter, p_iteration)
		_execute_test_case(name, p_test_parameter)
	else:
		_execute_test_case(name, [])
	await completed


func execute_paramaterized(p_test_parameter: Array) -> void:
	_failure_received(false)
	set_timeout()
	# We need here to add a empty array to override the `test_parameters` to prevent initial "default" parameters from being used.
	# This prevents objects in the argument list from being unnecessarily re-instantiated.
	var test_parameters := p_test_parameter.duplicate() # is strictly need to duplicate the paramters before extend
	test_parameters.append([])
	_execute_test_case(name, test_parameters)
	await completed


func dispose() -> void:
	if _is_disposed:
		return
	_is_disposed = true
	Engine.remove_meta("GD_TEST_FAILURE")
	stop_timer()
	_remove_failure_handler()
	_fuzzers.clear()


@warning_ignore("shadowed_variable_base_class", "redundant_await")
func _execute_test_case(name: String, test_parameter: Array) -> void:
	# needs at least on await otherwise it breaks the awaiting chain
	await get_parent().callv(name, test_parameter)
	await (Engine.get_main_loop() as SceneTree).process_frame
	completed.emit()


func update_fuzzers(input_values: Array, iteration: int) -> void:
	for fuzzer :Variant in input_values:
		if fuzzer is Fuzzer:
			fuzzer._iteration_index = iteration + 1


func set_timeout() -> void:
	if is_instance_valid(_timer):
		return
	var time: float = timeout / 1000.0
	_timer = Timer.new()
	add_child(_timer)
	_timer.set_name("gdunit_test_case_timer_%d" % _timer.get_instance_id())
	@warning_ignore("return_value_discarded")
	_timer.timeout.connect(do_interrupt, CONNECT_DEFERRED)
	_timer.set_one_shot(true)
	_timer.set_wait_time(time)
	_timer.set_autostart(false)
	_timer.start()


func do_interrupt() -> void:
	_interupted = true
	if not is_expect_interupted():
		var execution_context:= GdUnitThreadManager.get_current_context().get_execution_context()
		if is_fuzzed():
			execution_context.add_report(GdUnitReport.new()\
				.create(GdUnitReport.INTERUPTED, line_number(), GdAssertMessages.fuzzer_interuped(_current_iteration, "timedout")))
		else:
			execution_context.add_report(GdUnitReport.new()\
				.create(GdUnitReport.INTERUPTED, line_number(), GdAssertMessages.test_timeout(timeout)))
	completed.emit()


func _set_failure_handler() -> void:
	if not GdUnitSignals.instance().gdunit_set_test_failed.is_connected(_failure_received):
		@warning_ignore("return_value_discarded")
		GdUnitSignals.instance().gdunit_set_test_failed.connect(_failure_received)


func _remove_failure_handler() -> void:
	if GdUnitSignals.instance().gdunit_set_test_failed.is_connected(_failure_received):
		GdUnitSignals.instance().gdunit_set_test_failed.disconnect(_failure_received)


func _failure_received(is_failed: bool) -> void:
	# is already failed?
	if _failed:
		return
	_failed = is_failed
	Engine.set_meta("GD_TEST_FAILURE", is_failed)


func stop_timer() -> void:
	# finish outstanding timeouts
	if is_instance_valid(_timer):
		_timer.stop()
		_timer.call_deferred("free")
		_timer = null


func expect_to_interupt() -> void:
	_expect_to_interupt = true


func is_interupted() -> bool:
	return _interupted


func is_expect_interupted() -> bool:
	return _expect_to_interupt


func is_parameterized() -> bool:
	return _parameter_set_resolver.is_parameterized()


func is_skipped() -> bool:
	return _skipped


func skip_info() -> String:
	return _skip_reason


func line_number() -> int:
	return _line_number


func iterations() -> int:
	return _iterations


func seed_value() -> int:
	return _seed


func is_fuzzed() -> bool:
	return not _fuzzers.is_empty()


func fuzzer_arguments() -> Array[GdFunctionArgument]:
	return _fuzzers


func script_path() -> String:
	return _script_path


func ResourcePath() -> String:
	return _script_path


func generate_seed() -> void:
	if _seed != -1:
		seed(_seed)


func skip(skipped: bool, reason: String="") -> void:
	_skipped = skipped
	_skip_reason = reason


func set_function_descriptor(fd: GdFunctionDescriptor) -> void:
	_parameter_set_resolver = GdUnitTestParameterSetResolver.new(fd)


func set_test_parameter_index(index: int) -> void:
	_test_param_index = index


func test_parameter_index() -> int:
	return _test_param_index


func test_case_names() -> PackedStringArray:
	return _parameter_set_resolver.build_test_case_names(self)


func load_parameter_sets() -> Array:
	return _parameter_set_resolver.load_parameter_sets(self, true)


func parameter_set_resolver() -> GdUnitTestParameterSetResolver:
	return _parameter_set_resolver


func _to_string() -> String:
	return "%s :%d (%dms)" % [get_name(), _line_number, timeout]
class_name GdUnitCommand
extends RefCounted


func _init(p_name :String, p_is_enabled: Callable, p_runnable: Callable, p_shortcut :GdUnitShortcut.ShortCut = GdUnitShortcut.ShortCut.NONE) -> void:
	assert(p_name != null, "(%s) missing parameter 'name'" % p_name)
	assert(p_is_enabled != null, "(%s) missing parameter 'is_enabled'" % p_name)
	assert(p_runnable != null, "(%s) missing parameter 'runnable'" % p_name)
	assert(p_shortcut != null, "(%s) missing parameter 'shortcut'" % p_name)
	self.name = p_name
	self.is_enabled = p_is_enabled
	self.shortcut = p_shortcut
	self.runnable = p_runnable


var name: String:
	set(value):
		name = value
	get:
		return name


var shortcut: GdUnitShortcut.ShortCut:
	set(value):
		shortcut = value
	get:
		return shortcut


var is_enabled: Callable:
	set(value):
		is_enabled = value
	get:
		return is_enabled


var runnable: Callable:
	set(value):
		runnable = value
	get:
		return runnable
class_name GdUnitCommandHandler
extends Object

signal gdunit_runner_start()
signal gdunit_runner_stop(client_id :int)


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const CMD_RUN_OVERALL = "Debug Overall TestSuites"
const CMD_RUN_TESTCASE = "Run TestCases"
const CMD_RUN_TESTCASE_DEBUG = "Run TestCases (Debug)"
const CMD_RUN_TESTSUITE = "Run TestSuites"
const CMD_RUN_TESTSUITE_DEBUG = "Run TestSuites (Debug)"
const CMD_RERUN_TESTS = "ReRun Tests"
const CMD_RERUN_TESTS_DEBUG = "ReRun Tests (Debug)"
const CMD_STOP_TEST_RUN = "Stop Test Run"
const CMD_CREATE_TESTCASE = "Create TestCase"

const SETTINGS_SHORTCUT_MAPPING := {
	"N/A" : GdUnitShortcut.ShortCut.NONE,
	GdUnitSettings.SHORTCUT_INSPECTOR_RERUN_TEST : GdUnitShortcut.ShortCut.RERUN_TESTS,
	GdUnitSettings.SHORTCUT_INSPECTOR_RERUN_TEST_DEBUG : GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG,
	GdUnitSettings.SHORTCUT_INSPECTOR_RUN_TEST_OVERALL : GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL,
	GdUnitSettings.SHORTCUT_INSPECTOR_RUN_TEST_STOP : GdUnitShortcut.ShortCut.STOP_TEST_RUN,
	GdUnitSettings.SHORTCUT_EDITOR_RUN_TEST : GdUnitShortcut.ShortCut.RUN_TESTCASE,
	GdUnitSettings.SHORTCUT_EDITOR_RUN_TEST_DEBUG : GdUnitShortcut.ShortCut.RUN_TESTCASE_DEBUG,
	GdUnitSettings.SHORTCUT_EDITOR_CREATE_TEST : GdUnitShortcut.ShortCut.CREATE_TEST,
	GdUnitSettings.SHORTCUT_FILESYSTEM_RUN_TEST : GdUnitShortcut.ShortCut.RUN_TESTCASE,
	GdUnitSettings.SHORTCUT_FILESYSTEM_RUN_TEST_DEBUG : GdUnitShortcut.ShortCut.RUN_TESTCASE_DEBUG
}

# the current test runner config
var _runner_config := GdUnitRunnerConfig.new()

# holds the current connected gdUnit runner client id
var _client_id: int
# if no debug mode we have an process id
var _current_runner_process_id: int = 0
# hold is current an test running
var _is_running: bool = false
# holds if the current running tests started in debug mode
var _running_debug_mode: bool

var _commands := {}
var _shortcuts := {}


static func instance() -> GdUnitCommandHandler:
	return GdUnitSingleton.instance("GdUnitCommandHandler", func() -> GdUnitCommandHandler: return GdUnitCommandHandler.new())


@warning_ignore("return_value_discarded")
func _init() -> void:
	assert_shortcut_mappings(SETTINGS_SHORTCUT_MAPPING)

	GdUnitSignals.instance().gdunit_event.connect(_on_event)
	GdUnitSignals.instance().gdunit_client_connected.connect(_on_client_connected)
	GdUnitSignals.instance().gdunit_client_disconnected.connect(_on_client_disconnected)
	GdUnitSignals.instance().gdunit_settings_changed.connect(_on_settings_changed)
	# preload previous test execution
	@warning_ignore("return_value_discarded")
	_runner_config.load_config()

	init_shortcuts()
	var is_running := func(_script :Script) -> bool: return _is_running
	var is_not_running := func(_script :Script) -> bool: return !_is_running
	register_command(GdUnitCommand.new(CMD_RUN_OVERALL, is_not_running, cmd_run_overall.bind(true), GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL))
	register_command(GdUnitCommand.new(CMD_RUN_TESTCASE, is_not_running, cmd_editor_run_test.bind(false), GdUnitShortcut.ShortCut.RUN_TESTCASE))
	register_command(GdUnitCommand.new(CMD_RUN_TESTCASE_DEBUG, is_not_running, cmd_editor_run_test.bind(true), GdUnitShortcut.ShortCut.RUN_TESTCASE_DEBUG))
	register_command(GdUnitCommand.new(CMD_RUN_TESTSUITE, is_not_running, cmd_run_test_suites.bind(false)))
	register_command(GdUnitCommand.new(CMD_RUN_TESTSUITE_DEBUG, is_not_running, cmd_run_test_suites.bind(true)))
	register_command(GdUnitCommand.new(CMD_RERUN_TESTS, is_not_running, cmd_run.bind(false), GdUnitShortcut.ShortCut.RERUN_TESTS))
	register_command(GdUnitCommand.new(CMD_RERUN_TESTS_DEBUG, is_not_running, cmd_run.bind(true), GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG))
	register_command(GdUnitCommand.new(CMD_CREATE_TESTCASE, is_not_running, cmd_create_test, GdUnitShortcut.ShortCut.CREATE_TEST))
	register_command(GdUnitCommand.new(CMD_STOP_TEST_RUN, is_running, cmd_stop.bind(_client_id), GdUnitShortcut.ShortCut.STOP_TEST_RUN))

	# schedule discover tests if enabled and running inside the editor
	if Engine.is_editor_hint() and GdUnitSettings.is_test_discover_enabled():
		var timer :SceneTreeTimer = (Engine.get_main_loop() as SceneTree).create_timer(5)
		@warning_ignore("return_value_discarded")
		timer.timeout.connect(cmd_discover_tests)


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		_commands.clear()
		_shortcuts.clear()


func _do_process() -> void:
	check_test_run_stopped_manually()


# is checking if the user has press the editor stop scene
func check_test_run_stopped_manually() -> void:
	if is_test_running_but_stop_pressed():
		if GdUnitSettings.is_verbose_assert_warnings():
			push_warning("Test Runner scene was stopped manually, force stopping the current test run!")
		cmd_stop(_client_id)


func is_test_running_but_stop_pressed() -> bool:
	return _running_debug_mode and _is_running and not EditorInterface.is_playing_scene()


func assert_shortcut_mappings(mappings: Dictionary) -> void:
	for shortcut: int in GdUnitShortcut.ShortCut.values():
		assert(mappings.values().has(shortcut), "missing settings mapping for shortcut '%s'!" % GdUnitShortcut.ShortCut.keys()[shortcut])


func init_shortcuts() -> void:
	for shortcut: int in GdUnitShortcut.ShortCut.values():
		if shortcut == GdUnitShortcut.ShortCut.NONE:
			continue
		var property_name: String = SETTINGS_SHORTCUT_MAPPING.find_key(shortcut)
		var property := GdUnitSettings.get_property(property_name)
		var keys := GdUnitShortcut.default_keys(shortcut)
		if property != null:
			keys = property.value()
		var inputEvent := create_shortcut_input_even(keys)
		register_shortcut(shortcut, inputEvent)


func create_shortcut_input_even(key_codes: PackedInt32Array) -> InputEventKey:
	var inputEvent := InputEventKey.new()
	inputEvent.pressed = true
	for key_code in key_codes:
		match key_code:
			KEY_ALT:
				inputEvent.alt_pressed = true
			KEY_SHIFT:
				inputEvent.shift_pressed = true
			KEY_CTRL:
				inputEvent.ctrl_pressed = true
			_:
				inputEvent.keycode = key_code as Key
				inputEvent.physical_keycode = key_code as Key
	return inputEvent


func register_shortcut(p_shortcut: GdUnitShortcut.ShortCut, p_input_event: InputEvent) -> void:
	GdUnitTools.prints_verbose("register shortcut: '%s' to '%s'" % [GdUnitShortcut.ShortCut.keys()[p_shortcut], p_input_event.as_text()])
	var shortcut := Shortcut.new()
	shortcut.set_events([p_input_event])
	var command_name := get_shortcut_command(p_shortcut)
	_shortcuts[p_shortcut] = GdUnitShortcutAction.new(p_shortcut, shortcut, command_name)


func get_shortcut(shortcut_type: GdUnitShortcut.ShortCut) -> Shortcut:
	return get_shortcut_action(shortcut_type).shortcut


func get_shortcut_action(shortcut_type: GdUnitShortcut.ShortCut) -> GdUnitShortcutAction:
	return _shortcuts.get(shortcut_type)


func get_shortcut_command(p_shortcut: GdUnitShortcut.ShortCut) -> String:
	return GdUnitShortcut.CommandMapping.get(p_shortcut, "unknown command")


func register_command(p_command: GdUnitCommand) -> void:
	_commands[p_command.name] = p_command


func command(cmd_name: String) -> GdUnitCommand:
	return _commands.get(cmd_name)


func cmd_run_test_suites(test_suite_paths: PackedStringArray, debug: bool, rerun := false) -> void:
	# create new runner runner_config for fresh run otherwise use saved one
	if not rerun:
		var result := _runner_config.clear()\
			.add_test_suites(test_suite_paths)\
			.save_config()
		if result.is_error():
			push_error(result.error_message())
			return
	cmd_run(debug)


func cmd_run_test_case(test_suite_resource_path: String, test_case: String, test_param_index: int, debug: bool, rerun := false) -> void:
	# create new runner config for fresh run otherwise use saved one
	if not rerun:
		var result := _runner_config.clear()\
			.add_test_case(test_suite_resource_path, test_case, test_param_index)\
			.save_config()
		if result.is_error():
			push_error(result.error_message())
			return
	cmd_run(debug)


func cmd_run_overall(debug: bool) -> void:
	var test_suite_paths: PackedStringArray = GdUnitCommandHandler.scan_all_test_directories(GdUnitSettings.test_root_folder())
	var result := _runner_config.clear()\
		.add_test_suites(test_suite_paths)\
		.save_config()
	if result.is_error():
		push_error(result.error_message())
		return
	cmd_run(debug)


func cmd_run(debug: bool) -> void:
	# don't start is already running
	if _is_running:
		return
	# save current selected excution config
	var server_port: int = Engine.get_meta("gdunit_server_port")
	var result := _runner_config.set_server_port(server_port).save_config()
	if result.is_error():
		push_error(result.error_message())
		return
	# before start we have to save all changes
	ScriptEditorControls.save_all_open_script()
	gdunit_runner_start.emit()
	_current_runner_process_id = -1
	_running_debug_mode = debug
	if debug:
		run_debug_mode()
	else:
		run_release_mode()


func cmd_stop(client_id: int) -> void:
	# don't stop if is already stopped
	if not _is_running:
		return
	_is_running = false
	gdunit_runner_stop.emit(client_id)
	if _running_debug_mode:
		EditorInterface.stop_playing_scene()
	elif _current_runner_process_id > 0:
		if OS.is_process_running(_current_runner_process_id):
			var result := OS.kill(_current_runner_process_id)
			if result != OK:
				push_error("ERROR checked stopping GdUnit Test Runner. error code: %s" % result)
	_current_runner_process_id = -1


func cmd_editor_run_test(debug: bool) -> void:
	var cursor_line := active_base_editor().get_caret_line()
	#run test case?
	var regex := RegEx.new()
	@warning_ignore("return_value_discarded")
	regex.compile("(^func[ ,\t])(test_[a-zA-Z0-9_]*)")
	var result := regex.search(active_base_editor().get_line(cursor_line))
	if result:
		var func_name := result.get_string(2).strip_edges()
		prints("Run test:", func_name, "debug", debug)
		if func_name.begins_with("test_"):
			cmd_run_test_case(active_script().resource_path, func_name, -1, debug)
			return
	# otherwise run the full test suite
	var selected_test_suites := [active_script().resource_path]
	cmd_run_test_suites(selected_test_suites, debug)


func cmd_create_test() -> void:
	var cursor_line := active_base_editor().get_caret_line()
	var result := GdUnitTestSuiteBuilder.create(active_script(), cursor_line)
	if result.is_error():
		# show error dialog
		push_error("Failed to create test case: %s" % result.error_message())
		return
	var info: Dictionary = result.value()
	var script_path: String = info.get("path")
	var script_line: int = info.get("line")
	ScriptEditorControls.edit_script(script_path, script_line)


func cmd_discover_tests() -> void:
	await GdUnitTestDiscoverer.run()

static func scan_all_test_directories(root: String) -> PackedStringArray:
	var base_directory := "res://"
	# If the test root folder is configured as blank, "/", or "res://", use the root folder as described in the settings panel
	if root.is_empty() or root == "/" or root == base_directory:
		return [base_directory]
	return scan_test_directories(base_directory, root, [])

static func scan_test_directories(base_directory: String, test_directory: String, test_suite_paths: PackedStringArray) -> PackedStringArray:
	print_verbose("Scannning for test directory '%s' at %s" % [test_directory, base_directory])
	for directory in DirAccess.get_directories_at(base_directory):
		if directory.begins_with("."):
			continue
		var current_directory := normalize_path(base_directory + "/" + directory)
		if GdUnitTestSuiteScanner.exclude_scan_directories.has(current_directory):
			continue
		if match_test_directory(directory, test_directory):
			@warning_ignore("return_value_discarded")
			test_suite_paths.append(current_directory)
		else:
			@warning_ignore("return_value_discarded")
			scan_test_directories(current_directory, test_directory, test_suite_paths)
	return test_suite_paths


static func normalize_path(path: String) -> String:
	return path.replace("///", "//")


static func match_test_directory(directory: String, test_directory: String) -> bool:
	return directory == test_directory or test_directory.is_empty() or test_directory == "/" or test_directory == "res://"


func run_debug_mode() -> void:
	EditorInterface.play_custom_scene("res://addons/gdUnit4/src/core/GdUnitRunner.tscn")
	_is_running = true


func run_release_mode() -> void:
	var arguments := Array()
	if OS.is_stdout_verbose():
		arguments.append("--verbose")
	arguments.append("--no-window")
	arguments.append("--path")
	arguments.append(ProjectSettings.globalize_path("res://"))
	arguments.append("res://addons/gdUnit4/src/core/GdUnitRunner.tscn")
	_current_runner_process_id = OS.create_process(OS.get_executable_path(), arguments, false);
	_is_running = true


func active_base_editor() -> TextEdit:
	return EditorInterface.get_script_editor().get_current_editor().get_base_editor()


func active_script() -> Script:
	return EditorInterface.get_script_editor().get_current_script()



################################################################################
# signals handles
################################################################################
func _on_event(event: GdUnitEvent) -> void:
	if event.type() == GdUnitEvent.STOP:
		cmd_stop(_client_id)


func _on_stop_pressed() -> void:
	cmd_stop(_client_id)


func _on_run_pressed(debug := false) -> void:
	cmd_run(debug)


func _on_run_overall_pressed(_debug := false) -> void:
	cmd_run_overall(true)


func _on_settings_changed(property: GdUnitProperty) -> void:
	if SETTINGS_SHORTCUT_MAPPING.has(property.name()):
		var shortcut :GdUnitShortcut.ShortCut = SETTINGS_SHORTCUT_MAPPING.get(property.name())
		var value: PackedInt32Array = property.value()
		var input_event := create_shortcut_input_even(value)
		prints("Shortcut changed: '%s' to '%s'" % [GdUnitShortcut.ShortCut.keys()[shortcut], input_event.as_text()])
		register_shortcut(shortcut, input_event)
	if property.name() == GdUnitSettings.TEST_DISCOVER_ENABLED:
		var timer :SceneTreeTimer = (Engine.get_main_loop() as SceneTree).create_timer(3)
		@warning_ignore("return_value_discarded")
		timer.timeout.connect(cmd_discover_tests)


################################################################################
# Network stuff
################################################################################
func _on_client_connected(client_id: int) -> void:
	_client_id = client_id


func _on_client_disconnected(client_id: int) -> void:
	# only stops is not in debug mode running and the current client
	if not _running_debug_mode and _client_id == client_id:
		cmd_stop(client_id)
	_client_id = -1
class_name GdUnitShortcut
extends RefCounted


enum ShortCut {
	NONE,
	RUN_TESTS_OVERALL,
	RUN_TESTCASE,
	RUN_TESTCASE_DEBUG,
	RERUN_TESTS,
	RERUN_TESTS_DEBUG,
	STOP_TEST_RUN,
	CREATE_TEST,
}


const CommandMapping = {
	ShortCut.RUN_TESTS_OVERALL: GdUnitCommandHandler.CMD_RUN_OVERALL,
	ShortCut.RUN_TESTCASE: GdUnitCommandHandler.CMD_RUN_TESTCASE,
	ShortCut.RUN_TESTCASE_DEBUG: GdUnitCommandHandler.CMD_RUN_TESTCASE_DEBUG,
	ShortCut.RERUN_TESTS: GdUnitCommandHandler.CMD_RERUN_TESTS,
	ShortCut.RERUN_TESTS_DEBUG: GdUnitCommandHandler.CMD_RERUN_TESTS_DEBUG,
	ShortCut.STOP_TEST_RUN: GdUnitCommandHandler.CMD_STOP_TEST_RUN,
	ShortCut.CREATE_TEST: GdUnitCommandHandler.CMD_CREATE_TESTCASE,
}


const DEFAULTS_MACOS := {
	ShortCut.NONE : [],
	ShortCut.RUN_TESTCASE : [Key.KEY_META, Key.KEY_ALT, Key.KEY_F5],
	ShortCut.RUN_TESTCASE_DEBUG : [Key.KEY_META, Key.KEY_ALT, Key.KEY_F6],
	ShortCut.RUN_TESTS_OVERALL : [Key.KEY_META, Key.KEY_F7],
	ShortCut.STOP_TEST_RUN : [Key.KEY_META, Key.KEY_F8],
	ShortCut.RERUN_TESTS : [Key.KEY_META, Key.KEY_F5],
	ShortCut.RERUN_TESTS_DEBUG : [Key.KEY_META, Key.KEY_F6],
	ShortCut.CREATE_TEST : [Key.KEY_META, Key.KEY_ALT, Key.KEY_F10],
}

const DEFAULTS_WINDOWS := {
	ShortCut.NONE : [],
	ShortCut.RUN_TESTCASE : [Key.KEY_CTRL, Key.KEY_ALT, Key.KEY_F5],
	ShortCut.RUN_TESTCASE_DEBUG : [Key.KEY_CTRL,Key.KEY_ALT,  Key.KEY_F6],
	ShortCut.RUN_TESTS_OVERALL : [Key.KEY_CTRL, Key.KEY_F7],
	ShortCut.STOP_TEST_RUN : [Key.KEY_CTRL, Key.KEY_F8],
	ShortCut.RERUN_TESTS : [Key.KEY_CTRL, Key.KEY_F5],
	ShortCut.RERUN_TESTS_DEBUG : [Key.KEY_CTRL, Key.KEY_F6],
	ShortCut.CREATE_TEST : [Key.KEY_CTRL, Key.KEY_ALT, Key.KEY_F10],
}


static func default_keys(shortcut :ShortCut) -> PackedInt32Array:
	match OS.get_name().to_lower():
		'windows':
			return DEFAULTS_WINDOWS[shortcut]
		'macos':
			return DEFAULTS_MACOS[shortcut]
		_:
			return DEFAULTS_WINDOWS[shortcut]
class_name GdUnitShortcutAction
extends RefCounted


func _init(p_type :GdUnitShortcut.ShortCut, p_shortcut :Shortcut, p_command :String) -> void:
	assert(p_type != null, "missing parameter 'type'")
	assert(p_shortcut != null, "missing parameter 'shortcut'")
	assert(p_command != null, "missing parameter 'command'")
	self.type = p_type
	self.shortcut = p_shortcut
	self.command = p_command


var type: GdUnitShortcut.ShortCut:
	set(value):
		type = value
	get:
		return type


var shortcut: Shortcut:
	set(value):
		shortcut = value
	get:
		return shortcut


var command: String:
	set(value):
		command = value
	get:
		return command


func _to_string() -> String:
	return "GdUnitShortcutAction: %s (%s) -> %s" % [GdUnitShortcut.ShortCut.keys()[type], shortcut.get_as_text(), command]
extends RefCounted


# Caches all test indices for parameterized tests
class TestCaseIndicesCache:
	var _cache := {}

	func _key(resource_path: String, test_name: String) -> StringName:
		return &"%s_%s" % [resource_path, test_name]


	func contains_test_case(resource_path: String, test_name: String) -> bool:
		return _cache.has(_key(resource_path, test_name))


	func validate(resource_path: String, test_name: String, indices: PackedStringArray) -> bool:
		var cached_indicies: PackedStringArray = _cache[_key(resource_path, test_name)]
		return GdArrayTools.has_same_content(cached_indicies, indices)


	func sync(resource_path: String, test_name: String, indices: PackedStringArray) -> void:
		if indices.is_empty():
			_cache[_key(resource_path, test_name)] = []
		else:
			_cache[_key(resource_path, test_name)] = indices

# contains all tracked test suites where discovered since editor start
# key : test suite resource_path
# value: the list of discovered test case names
var _discover_cache := {}

var discovered_test_case_indices_cache := TestCaseIndicesCache.new()


func _init() -> void:
	# Register for discovery events to sync the cache
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_add_test_suite.connect(sync_cache)


func sync_cache(dto: GdUnitTestSuiteDto) -> void:
	var resource_path := ProjectSettings.localize_path(dto.path())
	var discovered_test_cases: Array[String] = []
	for test_case in dto.test_cases():
		discovered_test_cases.append(test_case.name())
		discovered_test_case_indices_cache.sync(resource_path, test_case.name(), test_case.test_case_names())
	_discover_cache[resource_path] = discovered_test_cases


func discover(script: Script) -> void:
	# for cs scripts we need to recomplie before discover new tests
	if GdObjects.is_cs_script(script):
		await rebuild_project(script)

	if GdObjects.is_test_suite(script):
		# a new test suite is discovered
		var script_path := ProjectSettings.localize_path(script.resource_path)
		var scanner := GdUnitTestSuiteScanner.new()
		var test_suite := scanner._parse_test_suite(script)
		var suite_name := test_suite.get_name()

		if not _discover_cache.has(script_path):
			var dto :GdUnitTestSuiteDto = GdUnitTestSuiteDto.of(test_suite)
			GdUnitSignals.instance().gdunit_event.emit(GdUnitEventTestDiscoverTestSuiteAdded.new(script_path, suite_name, dto))
			sync_cache(dto)
			test_suite.queue_free()
			return

		var discovered_test_cases :Array[String] = _discover_cache.get(script_path, [] as Array[String])
		var script_test_cases := extract_test_functions(test_suite)

		# first detect removed/renamed tests
		var tests_removed := PackedStringArray()
		for test_case in discovered_test_cases:
			if not script_test_cases.has(test_case):
				@warning_ignore("return_value_discarded")
				tests_removed.append(test_case)
		# second detect new added tests
		var tests_added :Array[String] = []
		for test_case in script_test_cases:
			if not discovered_test_cases.has(test_case):
				tests_added.append(test_case)

		# We need to scan for parameterized test because of possible test data changes
		# For more details look at https://github.com/MikeSchulze/gdUnit4/issues/592
		for test_case_name in script_test_cases:
			if discovered_test_case_indices_cache.contains_test_case(script_path, test_case_name):
				var test_case: _TestCase = test_suite.find_child(test_case_name, false, false)
				var test_indices := test_case.test_case_names()
				if not discovered_test_case_indices_cache.validate(script_path, test_case_name, test_indices):
					if !tests_removed.has(test_case_name):
						tests_removed.append(test_case_name)
					if !tests_added.has(test_case_name):
						tests_added.append(test_case_name)
					discovered_test_case_indices_cache.sync(script_path, test_case_name, test_indices)

		# finally notify changes to the inspector
		if not tests_removed.is_empty() or not tests_added.is_empty():
			# emit deleted tests
			for test_name in tests_removed:
				discovered_test_cases.erase(test_name)
				GdUnitSignals.instance().gdunit_event.emit(GdUnitEventTestDiscoverTestRemoved.new(script_path, suite_name, test_name))

			# emit new discovered tests
			for test_name in tests_added:
				discovered_test_cases.append(test_name)
				var test_case := test_suite.find_child(test_name, false, false)
				var dto := GdUnitTestCaseDto.new()
				dto = dto.deserialize(dto.serialize(test_case))
				GdUnitSignals.instance().gdunit_event.emit(GdUnitEventTestDiscoverTestAdded.new(script_path, suite_name, dto))
				# if the parameterized test fresh added we need to sync the cache
				if not discovered_test_case_indices_cache.contains_test_case(script_path, test_name):
					discovered_test_case_indices_cache.sync(script_path, test_name, dto.test_case_names())

			# update the cache
			_discover_cache[script_path] = discovered_test_cases
			test_suite.queue_free()


func extract_test_functions(test_suite :Node) -> PackedStringArray:
	return test_suite.get_children()\
		.filter(func(child: Node) -> bool: return is_instance_of(child, _TestCase))\
		.map(func (child: Node) -> String: return child.get_name())


func is_paramaterized_test(test_suite :Node, test_case_name: String) -> bool:
	return test_suite.get_children()\
		.filter(func(child: Node) -> bool: return child.name == test_case_name)\
		.any(func (test: _TestCase) -> bool: return test.is_parameterized())


# do rebuild the entire project, there is actual no way to enforce the Godot engine itself to do this
func rebuild_project(script: Script) -> void:
	var class_path := ProjectSettings.globalize_path(script.resource_path)
	print_rich("[color=CORNFLOWER_BLUE]GdUnitTestDiscoverGuard: CSharpScript change detected on: '%s' [/color]" % class_path)
	var scene_tree := Engine.get_main_loop() as SceneTree
	await scene_tree.process_frame

	var output := []
	var exit_code := OS.execute("dotnet", ["--version"], output)
	if exit_code == -1:
		print_rich("[color=CORNFLOWER_BLUE]GdUnitTestDiscoverGuard:[/color] [color=RED]Rebuild the project failed.[/color]")
		print_rich("[color=CORNFLOWER_BLUE]GdUnitTestDiscoverGuard:[/color] [color=RED]Can't find installed `dotnet`! Please check your environment is setup correctly.[/color]")
		return
	print_rich("[color=CORNFLOWER_BLUE]GdUnitTestDiscoverGuard:[/color] [color=DEEP_SKY_BLUE]Found dotnet v%s[/color]" % output[0].strip_edges())
	output.clear()

	exit_code = OS.execute("dotnet", ["build"], output)
	print_rich("[color=CORNFLOWER_BLUE]GdUnitTestDiscoverGuard:[/color] [color=DEEP_SKY_BLUE]Rebuild the project ... [/color]")
	for out:Variant in output:
		print_rich("[color=DEEP_SKY_BLUE] 		%s" % out.strip_edges())
	await scene_tree.process_frame
class_name GdUnitTestDiscoverer
extends RefCounted


static func run() -> void:
	prints("Running test discovery ..")
	GdUnitSignals.instance().gdunit_event.emit(GdUnitEventTestDiscoverStart.new())
	await (Engine.get_main_loop() as SceneTree).create_timer(.5).timeout

	# We run the test discovery in an extra thread so that the main thread is not blocked
	var t:= Thread.new()
	@warning_ignore("return_value_discarded")
	t.start(func () -> void:
		var test_suite_directories :PackedStringArray = GdUnitCommandHandler.scan_all_test_directories(GdUnitSettings.test_root_folder())
		var scanner := GdUnitTestSuiteScanner.new()
		var _test_suites_to_process :Array[Node] = []

		for test_suite_dir in test_suite_directories:
			_test_suites_to_process.append_array(scanner.scan(test_suite_dir))

		# Do sync the main thread before emit the discovered test suites to the inspector
		await (Engine.get_main_loop() as SceneTree).process_frame
		var test_case_count :int = 0
		for test_suite in _test_suites_to_process:
			test_case_count += test_suite.get_child_count()
			var ts_dto := GdUnitTestSuiteDto.of(test_suite)
			GdUnitSignals.instance().gdunit_add_test_suite.emit(ts_dto)
			test_suite.free()

		prints("%d test suites discovered." % _test_suites_to_process.size())
		GdUnitSignals.instance().gdunit_event.emit(GdUnitEventTestDiscoverEnd.new(_test_suites_to_process.size(), test_case_count))
		_test_suites_to_process.clear()
	)
	# wait unblocked to the tread is finished
	while t.is_alive():
		await (Engine.get_main_loop() as SceneTree).process_frame
	# needs finally to wait for finish
	await t.wait_to_finish()
class_name GdUnitEvent
extends Resource

const WARNINGS = "warnings"
const FAILED = "failed"
const FLAKY = "flaky"
const ERRORS = "errors"
const SKIPPED = "skipped"
const ELAPSED_TIME = "elapsed_time"
const ORPHAN_NODES = "orphan_nodes"
const ERROR_COUNT = "error_count"
const FAILED_COUNT = "failed_count"
const SKIPPED_COUNT = "skipped_count"
const RETRY_COUNT = "retry_count"

enum {
	INIT,
	STOP,
	TESTSUITE_BEFORE,
	TESTSUITE_AFTER,
	TESTCASE_BEFORE,
	TESTCASE_AFTER,
	TESTCASE_STATISTICS,
	DISCOVER_START,
	DISCOVER_END,
	DISCOVER_SUITE_ADDED,
	DISCOVER_TEST_ADDED,
	DISCOVER_TEST_REMOVED,
}

var _event_type :int
var _resource_path :String
var _suite_name :String
var _test_name :String
var _total_count :int = 0
var _statistics := Dictionary()
var _reports :Array[GdUnitReport] = []


func suite_before(p_resource_path :String, p_suite_name :String, p_total_count :int) -> GdUnitEvent:
	_event_type = TESTSUITE_BEFORE
	_resource_path = p_resource_path
	_suite_name = p_suite_name
	_test_name = "before"
	_total_count = p_total_count
	return self


func suite_after(p_resource_path :String, p_suite_name :String, p_statistics :Dictionary = {}, p_reports :Array[GdUnitReport] = []) -> GdUnitEvent:
	_event_type = TESTSUITE_AFTER
	_resource_path = p_resource_path
	_suite_name  = p_suite_name
	_test_name = "after"
	_statistics = p_statistics
	_reports = p_reports
	return self


func test_before(p_resource_path :String, p_suite_name :String, p_test_name :String) -> GdUnitEvent:
	_event_type = TESTCASE_BEFORE
	_resource_path = p_resource_path
	_suite_name  = p_suite_name
	_test_name = p_test_name
	return self


func test_after(p_resource_path :String, p_suite_name :String, p_test_name :String, p_statistics :Dictionary = {}, p_reports :Array[GdUnitReport] = []) -> GdUnitEvent:
	_event_type = TESTCASE_AFTER
	_resource_path = p_resource_path
	_suite_name  = p_suite_name
	_test_name = p_test_name
	_statistics = p_statistics
	_reports = p_reports
	return self


func test_statistics(p_resource_path :String, p_suite_name :String, p_test_name :String, p_statistics :Dictionary = {}) -> GdUnitEvent:
	_event_type = TESTCASE_STATISTICS
	_resource_path = p_resource_path
	_suite_name  = p_suite_name
	_test_name = p_test_name
	_statistics = p_statistics
	return self


func type() -> int:
	return _event_type


func suite_name() -> String:
	return _suite_name


func test_name() -> String:
	return _test_name


func elapsed_time() -> int:
	return _statistics.get(ELAPSED_TIME, 0)


func orphan_nodes() -> int:
	return  _statistics.get(ORPHAN_NODES, 0)


func statistic(p_type :String) -> int:
	return _statistics.get(p_type, 0)


func total_count() -> int:
	return _total_count


func success_count() -> int:
	return total_count() - error_count() - failed_count() - skipped_count()


func error_count() -> int:
	return _statistics.get(ERROR_COUNT, 0)


func failed_count() -> int:
	return _statistics.get(FAILED_COUNT, 0)


func skipped_count() -> int:
	return _statistics.get(SKIPPED_COUNT, 0)


func resource_path() -> String:
	return _resource_path


func is_success() -> bool:
	return not is_warning() and not is_failed() and not is_error() and not is_skipped()


func is_warning() -> bool:
	return _statistics.get(WARNINGS, false)


func is_failed() -> bool:
	return _statistics.get(FAILED, false)


func is_error() -> bool:
	return _statistics.get(ERRORS, false)


func is_flaky() -> bool:
	return _statistics.get(FLAKY, false)


func is_skipped() -> bool:
	return _statistics.get(SKIPPED, false)


func reports() -> Array[GdUnitReport]:
	return _reports


func _to_string() -> String:
	return "Event: %s %s:%s, %s, %s" % [_event_type, _suite_name, _test_name, _statistics, _reports]


func serialize() -> Dictionary:
	var serialized := {
		"type"         : _event_type,
		"resource_path": _resource_path,
		"suite_name"   : _suite_name,
		"test_name"    : _test_name,
		"total_count"  : _total_count,
		"statistics"    : _statistics
	}
	serialized["reports"] = _serialize_TestReports()
	return serialized


func deserialize(serialized :Dictionary) -> GdUnitEvent:
	_event_type    = serialized.get("type", null)
	_resource_path = serialized.get("resource_path", null)
	_suite_name    = serialized.get("suite_name", null)
	_test_name     = serialized.get("test_name", "unknown")
	_total_count   = serialized.get("total_count", 0)
	_statistics    = serialized.get("statistics", Dictionary())
	if serialized.has("reports"):
		# needs this workaround to copy typed values in the array
		var reports_to_deserializ :Array[Dictionary] = []
		@warning_ignore("unsafe_cast")
		reports_to_deserializ.append_array(serialized.get("reports") as Array)
		_reports = _deserialize_reports(reports_to_deserializ)
	return self


func _serialize_TestReports() -> Array[Dictionary]:
	var serialized_reports :Array[Dictionary] = []
	for report in _reports:
		serialized_reports.append(report.serialize())
	return serialized_reports


func _deserialize_reports(p_reports :Array[Dictionary]) -> Array[GdUnitReport]:
	var deserialized_reports :Array[GdUnitReport] = []
	for report in p_reports:
		var test_report := GdUnitReport.new().deserialize(report)
		deserialized_reports.append(test_report)
	return deserialized_reports
class_name GdUnitInit
extends GdUnitEvent


var _total_testsuites :int


func _init(p_total_testsuites :int, p_total_count :int) -> void:
	_event_type = INIT
	_total_testsuites = p_total_testsuites
	_total_count = p_total_count


func total_test_suites() -> int:
	return _total_testsuites


func total_tests() -> int:
	return _total_count
class_name GdUnitStop
extends GdUnitEvent


func _init() -> void:
	_event_type = STOP
class_name GdUnitEventTestDiscoverEnd
extends GdUnitEvent


var _total_testsuites: int


func _init(testsuite_count: int, test_count: int) -> void:
	_event_type = DISCOVER_END
	_total_testsuites = testsuite_count
	_total_count = test_count


func total_test_suites() -> int:
	return _total_testsuites


func total_tests() -> int:
	return _total_count
class_name GdUnitEventTestDiscoverStart
extends GdUnitEvent


func _init() -> void:
	_event_type = DISCOVER_START
class_name GdUnitEventTestDiscoverTestAdded
extends GdUnitEvent


var _test_case_dto: GdUnitTestCaseDto


func _init(arg_resource_path: String, arg_suite_name: String, arg_test_case_dto: GdUnitTestCaseDto) -> void:
	_event_type = DISCOVER_TEST_ADDED
	_resource_path = arg_resource_path
	_suite_name  = arg_suite_name
	_test_name = arg_test_case_dto.name()
	_test_case_dto = arg_test_case_dto


func test_case_dto() -> GdUnitTestCaseDto:
	return _test_case_dto
class_name GdUnitEventTestDiscoverTestRemoved
extends GdUnitEvent


func _init(arg_resource_path: String, arg_suite_name: String, arg_test_name: String) -> void:
	_event_type = DISCOVER_TEST_REMOVED
	_resource_path = arg_resource_path
	_suite_name  = arg_suite_name
	_test_name = arg_test_name
class_name GdUnitEventTestDiscoverTestSuiteAdded
extends GdUnitEvent


var _dto: GdUnitTestSuiteDto


func _init(arg_resource_path: String, arg_suite_name: String, arg_dto: GdUnitTestSuiteDto) -> void:
	_event_type = DISCOVER_SUITE_ADDED
	_resource_path = arg_resource_path
	_suite_name  = arg_suite_name
	_dto = arg_dto


func suite_dto() -> GdUnitTestSuiteDto:
	return _dto
## The execution context
## It contains all the necessary information about the executed stage, such as memory observers, reports, orphan monitor
class_name GdUnitExecutionContext

var _parent_context: GdUnitExecutionContext
var _sub_context: Array[GdUnitExecutionContext] = []
var _orphan_monitor: GdUnitOrphanNodesMonitor
var _memory_observer: GdUnitMemoryObserver
var _report_collector: GdUnitTestReportCollector
var _timer: LocalTime
var _test_case_name: StringName
var _test_case_parameter_set: Array
var _name: String
var _test_execution_iteration: int = 0
var _flaky_test_check := GdUnitSettings.is_test_flaky_check_enabled()
var _flaky_test_retries := GdUnitSettings.get_flaky_max_retries()


# execution states
var _is_calculated := false
var _is_success: bool
var _is_flaky: bool
var _is_skipped: bool
var _has_warnings: bool
var _has_failures: bool
var _has_errors: bool
var _failure_count := 0
var _orphan_count := 0
var _error_count := 0
var _skipped_count := 0


var error_monitor: GodotGdErrorMonitor = null:
	get:
		if _parent_context != null:
			return _parent_context.error_monitor
		if error_monitor == null:
			error_monitor = GodotGdErrorMonitor.new()
		return error_monitor


var test_suite: GdUnitTestSuite = null:
	get:
		if _parent_context != null:
			return _parent_context.test_suite
		return test_suite


var test_case: _TestCase = null:
	get:
		if test_case == null and _parent_context != null:
			return _parent_context.test_case
		return test_case


func _init(name: StringName, parent_context: GdUnitExecutionContext = null) -> void:
	_name = name
	_parent_context = parent_context
	_timer = LocalTime.now()
	_orphan_monitor = GdUnitOrphanNodesMonitor.new(name)
	_orphan_monitor.start()
	_memory_observer = GdUnitMemoryObserver.new()
	_report_collector = GdUnitTestReportCollector.new()
	if parent_context != null:
		parent_context._sub_context.append(self)


func dispose() -> void:
	_timer = null
	_orphan_monitor = null
	_report_collector = null
	_memory_observer = null
	_parent_context = null
	test_suite = null
	test_case = null
	dispose_sub_contexts()


func dispose_sub_contexts() -> void:
	for context in _sub_context:
		context.dispose()
	_sub_context.clear()


static func of(pe: GdUnitExecutionContext) -> GdUnitExecutionContext:
	var context := GdUnitExecutionContext.new(pe._test_case_name, pe)
	context._test_case_name = pe._test_case_name
	context._test_execution_iteration = pe._test_execution_iteration
	return context


static func of_test_suite(p_test_suite: GdUnitTestSuite) -> GdUnitExecutionContext:
	assert(p_test_suite, "test_suite is null")
	var context := GdUnitExecutionContext.new(p_test_suite.get_name())
	context.test_suite = p_test_suite
	return context


static func of_test_case(pe: GdUnitExecutionContext, p_test_case: _TestCase) -> GdUnitExecutionContext:
	assert(p_test_case, "test_case is null")
	var context := GdUnitExecutionContext.new(p_test_case.get_name(), pe)
	context.test_case = p_test_case
	return context


static func of_parameterized_test(pe: GdUnitExecutionContext, test_case_name: String, test_case_parameter_set: Array) -> GdUnitExecutionContext:
	var context := GdUnitExecutionContext.new(test_case_name, pe)
	context._test_case_name = test_case_name
	context._test_case_parameter_set = test_case_parameter_set
	return context


func get_test_suite_path() -> String:
	return test_suite.get_script().resource_path


func get_test_suite_name() -> StringName:
	return test_suite.get_name()


func get_test_case_name() -> StringName:
	if _test_case_name.is_empty():
		return test_case.get_name()
	return _test_case_name


func error_monitor_start() -> void:
	error_monitor.start()


func error_monitor_stop() -> void:
	await error_monitor.scan()
	for error_report in error_monitor.to_reports():
		if error_report.is_error():
			_report_collector.push_back(error_report)


func orphan_monitor_start() -> void:
	_orphan_monitor.start()


func orphan_monitor_stop() -> void:
	_orphan_monitor.stop()


func add_report(report: GdUnitReport) -> void:
	_report_collector.push_back(report)


func reports() -> Array[GdUnitReport]:
	return _report_collector.reports()


func collect_reports(recursive: bool) -> Array[GdUnitReport]:
	if not recursive:
		return reports()
	var current_reports := reports()
	# we combine the reports of test_before(), test_after() and test() to be reported by `fire_test_ended`
	for sub_context in _sub_context:
		current_reports.append_array(sub_context.reports())
		# needs finally to clean the test reports to avoid counting twice
		sub_context.reports().clear()
	return current_reports


func collect_orphans(p_reports: Array[GdUnitReport]) -> int:
	var orphans := 0
	if not _sub_context.is_empty():
		orphans += collect_testcase_orphan_reports(_sub_context[0], p_reports)
	orphans += collect_teststage_orphan_reports(p_reports)
	return orphans


func collect_testcase_orphan_reports(context: GdUnitExecutionContext, p_reports: Array[GdUnitReport]) -> int:
	var orphans := context.count_orphans()
	if orphans > 0:
		p_reports.push_front(GdUnitReport.new()\
			.create(GdUnitReport.WARN, context.test_case.line_number(), GdAssertMessages.orphan_detected_on_test(orphans)))
	return orphans


func collect_teststage_orphan_reports(p_reports: Array[GdUnitReport]) -> int:
	var orphans := count_orphans()
	if orphans > 0:
		p_reports.push_front(GdUnitReport.new()\
			.create(GdUnitReport.WARN, test_case.line_number(), GdAssertMessages.orphan_detected_on_test_setup(orphans)))
	return orphans


func build_reports(recursive:= true) -> Array[GdUnitReport]:
	var collected_reports: Array[GdUnitReport] = collect_reports(recursive)
	if recursive:
		_orphan_count = collect_orphans(collected_reports)
	else:
		_orphan_count = count_orphans()
		if _orphan_count > 0:
			collected_reports.push_front(GdUnitReport.new() \
				.create(GdUnitReport.WARN, 1, GdAssertMessages.orphan_detected_on_suite_setup(_orphan_count)))
	_is_skipped = is_skipped()
	_skipped_count = count_skipped(recursive)
	_is_success = is_success()
	_is_flaky = is_flaky()
	_has_warnings = has_warnings()
	_has_errors = has_errors()
	_error_count = count_errors(recursive)
	if !_is_success:
		_has_failures = has_failures()
		_failure_count = count_failures(recursive)
	_is_calculated = true
	return collected_reports


# Evaluates the actual test case status by validate latest execution state (cold be more based on flaky max retry count)
func evaluate_test_retry_status() -> bool:
	# get latest test execution status
	var last_test_status :GdUnitExecutionContext = _sub_context.back()
	_is_skipped = last_test_status.is_skipped()
	_skipped_count = last_test_status.count_skipped(false)
	_is_success = last_test_status.is_success()
	# if success but it have more than one sub contexts the test was rerurn becouse of failures and will be marked as flaky
	_is_flaky = _is_success and _sub_context.size() > 1
	_has_warnings = last_test_status.has_warnings()
	_has_errors = last_test_status.has_errors()
	_error_count = last_test_status.count_errors(false)
	_has_failures = last_test_status.has_failures()
	_failure_count = last_test_status.count_failures(false)
	_orphan_count = last_test_status.collect_orphans(collect_reports(false))
	_is_calculated = true
	# finally cleanup the retry execution contexts
	dispose_sub_contexts()
	return _is_success


func get_execution_statistics() -> Dictionary:
	return {
		GdUnitEvent.RETRY_COUNT: _test_execution_iteration,
		GdUnitEvent.ORPHAN_NODES: _orphan_count,
		GdUnitEvent.ELAPSED_TIME: _timer.elapsed_since_ms(),
		GdUnitEvent.FAILED: !_is_success,
		GdUnitEvent.ERRORS: _has_errors,
		GdUnitEvent.WARNINGS: _has_warnings,
		GdUnitEvent.FLAKY: _is_flaky,
		GdUnitEvent.SKIPPED: _is_skipped,
		GdUnitEvent.FAILED_COUNT: _failure_count,
		GdUnitEvent.ERROR_COUNT: _error_count,
		GdUnitEvent.SKIPPED_COUNT: _skipped_count
	}


func has_failures() -> bool:
	return (
		_sub_context.any(func(c :GdUnitExecutionContext) -> bool:
			return c._has_failures if c._is_calculated else c.has_failures())
		or _report_collector.has_failures()
	)


func has_errors() -> bool:
	return (
		_sub_context.any(func(c :GdUnitExecutionContext) -> bool:
			return c._has_errors if c._is_calculated else c.has_errors())
		or _report_collector.has_errors()
	)


func has_warnings() -> bool:
	return (
		_sub_context.any(func(c :GdUnitExecutionContext) -> bool:
			return c._has_warnings if c._is_calculated else c.has_warnings())
		or _report_collector.has_warnings()
	)


func is_flaky() -> bool:
	return (
		_sub_context.any(func(c :GdUnitExecutionContext) -> bool:
			return c._is_flaky if c._is_calculated else c.is_flaky())
		or _test_execution_iteration > 1
	)


func is_success() -> bool:
	if _sub_context.is_empty():
		return not has_failures()

	var failed_context := _sub_context.filter(func(c :GdUnitExecutionContext) -> bool:
			return !(c._is_success if c._is_calculated else c.is_success()))
	return failed_context.is_empty() and not has_failures()


func is_skipped() -> bool:
	return (
		_sub_context.any(func(c :GdUnitExecutionContext) -> bool:
			return c._is_skipped if c._is_calculated else c.is_skipped())
		or test_case.is_skipped() if test_case != null else false
	)


func is_interupted() -> bool:
	return false if test_case == null else test_case.is_interupted()


func count_failures(recursive: bool) -> int:
	if not recursive:
		return _report_collector.count_failures()
	return _sub_context\
		.map(func(c :GdUnitExecutionContext) -> int:
				return c.count_failures(recursive)).reduce(sum, _report_collector.count_failures())


func count_errors(recursive: bool) -> int:
	if not recursive:
		return _report_collector.count_errors()
	return _sub_context\
		.map(func(c :GdUnitExecutionContext) -> int:
				return c.count_errors(recursive)).reduce(sum, _report_collector.count_errors())


func count_skipped(recursive: bool) -> int:
	if not recursive:
		return _report_collector.count_skipped()
	return _sub_context\
		.map(func(c :GdUnitExecutionContext) -> int:
				return c.count_skipped(recursive)).reduce(sum, _report_collector.count_skipped())


func count_orphans() -> int:
	var orphans := 0
	for c in _sub_context:
		orphans += c._orphan_monitor.orphan_nodes()
	return _orphan_monitor.orphan_nodes() - orphans


func sum(accum: int, number: int) -> int:
	return accum + number


func retry_execution() -> bool:
	var retry :=  _test_execution_iteration < 1 if not _flaky_test_check else _test_execution_iteration < _flaky_test_retries
	if retry:
		_test_execution_iteration += 1
	return retry


func register_auto_free(obj: Variant) -> Variant:
	return _memory_observer.register_auto_free(obj)


## Runs the gdunit garbage collector to free registered object
func gc() -> void:
	# unreference last used assert form the test to prevent memory leaks
	GdUnitThreadManager.get_current_context().clear_assert()
	await _memory_observer.gc()
	orphan_monitor_stop()
## The memory watcher for objects that have been registered and are released when 'gc' is called.
class_name GdUnitMemoryObserver
extends RefCounted

const TAG_OBSERVE_INSTANCE := "GdUnit4_observe_instance_"
const TAG_AUTO_FREE = "GdUnit4_marked_auto_free"
const GdUnitTools = preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")


var _store :Array[Variant] = []
# enable for debugging purposes
var _is_stdout_verbose := false
const _show_debug := false


## Registration of an instance to be released when an execution phase is completed
func register_auto_free(obj :Variant) -> Variant:
	if not is_instance_valid(obj):
		return obj
	# do not register on GDScriptNativeClass
	@warning_ignore("unsafe_cast")
	if typeof(obj) == TYPE_OBJECT and (obj as Object).is_class("GDScriptNativeClass") :
		return obj
	#if obj is GDScript or obj is ScriptExtension:
	#	return obj
	if obj is MainLoop:
		push_error("GdUnit4: Avoid to add mainloop to auto_free queue  %s" % obj)
		return
	if _is_stdout_verbose:
		print_verbose("GdUnit4:gc():register auto_free(%s)" % obj)
	# only register pure objects
	if obj is GdUnitSceneRunner:
		_store.push_back(obj)
	else:
		_store.append(obj)
	_tag_object(obj)
	return obj


# to disable instance guard when run into issues.
static func _is_instance_guard_enabled() -> bool:
	return false


@warning_ignore("unsafe_method_access")
static func debug_observe(name :String, obj :Object, indent :int = 0) -> void:
	if not _show_debug:
		return
	var script :GDScript= obj if obj is GDScript else obj.get_script()
	if script:
		var base_script :GDScript = script.get_base_script()
		prints("".lpad(indent, "	"), name, obj, obj.get_class(), "reference_count:", obj.get_reference_count() if obj is RefCounted else 0, "script:", script, script.resource_path)
		if base_script:
			debug_observe("+", base_script, indent+1)
	else:
		prints(name, obj, obj.get_class(), obj.get_name())


static func guard_instance(obj :Object) -> void:
	if not _is_instance_guard_enabled():
		return
	var tag := TAG_OBSERVE_INSTANCE + str(abs(obj.get_instance_id()))
	if Engine.has_meta(tag):
		return
	debug_observe("Gard on instance", obj)
	Engine.set_meta(tag, obj)


static func unguard_instance(obj :Object, verbose := true) -> void:
	if not _is_instance_guard_enabled():
		return
	var tag := TAG_OBSERVE_INSTANCE + str(abs(obj.get_instance_id()))
	if verbose:
		debug_observe("unguard instance", obj)
	if Engine.has_meta(tag):
		Engine.remove_meta(tag)


static func gc_guarded_instance(name :String, instance :Object) -> void:
	if not _is_instance_guard_enabled():
		return
	await (Engine.get_main_loop() as SceneTree).process_frame
	unguard_instance(instance, false)
	if is_instance_valid(instance) and instance is RefCounted:
		# finally do this very hacky stuff
		# we need to manually unreferece to avoid leaked scripts
		# but still leaked GDScriptFunctionState exists
		#var script :GDScript = instance.get_script()
		#if script:
		#	var base_script :GDScript = script.get_base_script()
		#	if base_script:
		#		base_script.unreference()
		debug_observe(name, instance)
		(instance as RefCounted).unreference()
		await (Engine.get_main_loop() as SceneTree).process_frame


static func gc_on_guarded_instances() -> void:
	if not _is_instance_guard_enabled():
		return
	for tag in Engine.get_meta_list():
		if tag.begins_with(TAG_OBSERVE_INSTANCE):
			var instance :Object = Engine.get_meta(tag)
			await gc_guarded_instance("Leaked instance detected:", instance)
			await GdUnitTools.free_instance(instance, false)


# store the object into global store aswell to be verified by 'is_marked_auto_free'
func _tag_object(obj :Variant) -> void:
	var tagged_object: Array = Engine.get_meta(TAG_AUTO_FREE, [])
	tagged_object.append(obj)
	Engine.set_meta(TAG_AUTO_FREE, tagged_object)


## Runs over all registered objects and releases them
func gc() -> void:
	if _store.is_empty():
		return
	# give engine time to free objects to process objects marked by queue_free()
	await (Engine.get_main_loop() as SceneTree).process_frame
	if _is_stdout_verbose:
		print_verbose("GdUnit4:gc():running", " freeing %d objects .." % _store.size())
	var tagged_objects: Array = Engine.get_meta(TAG_AUTO_FREE, [])
	while not _store.is_empty():
		var value :Variant = _store.pop_front()
		tagged_objects.erase(value)
		await GdUnitTools.free_instance(value, _is_stdout_verbose)
	assert(_store.is_empty(), "The memory observer has still entries in the store!")


## Checks whether the specified object is registered for automatic release
static func is_marked_auto_free(obj: Variant) -> bool:
	var tagged_objects: Array = Engine.get_meta(TAG_AUTO_FREE, [])
	return tagged_objects.has(obj)
# Collects all reports seperated as warnings, failures and errors
class_name GdUnitTestReportCollector
extends RefCounted


var _reports :Array[GdUnitReport] = []


static func __filter_is_error(report :GdUnitReport) -> bool:
	return report.is_error()


static func __filter_is_failure(report :GdUnitReport) -> bool:
	return report.is_failure()


static func __filter_is_warning(report :GdUnitReport) -> bool:
	return report.is_warning()


static func __filter_is_skipped(report :GdUnitReport) -> bool:
	return report.is_skipped()


func count_failures() -> int:
	return _reports.filter(__filter_is_failure).size()


func count_errors() -> int:
	return _reports.filter(__filter_is_error).size()


func count_warnings() -> int:
	return _reports.filter(__filter_is_warning).size()


func count_skipped() -> int:
	return _reports.filter(__filter_is_skipped).size()


func has_failures() -> bool:
	return _reports.any(__filter_is_failure)


func has_errors() -> bool:
	return _reports.any(__filter_is_error)


func has_warnings() -> bool:
	return _reports.any(__filter_is_warning)


func has_skipped() -> bool:
	return _reports.any(__filter_is_skipped)


func reports() -> Array[GdUnitReport]:
	return _reports


func push_back(report :GdUnitReport) -> void:
	_reports.push_back(report)
## The executor to run a test-suite
class_name GdUnitTestSuiteExecutor


# preload all asserts here
@warning_ignore("unused_private_class_variable")
var _assertions := GdUnitAssertions.new()
var _executeStage := GdUnitTestSuiteExecutionStage.new()


func _init(debug_mode :bool = false) -> void:
	_executeStage.set_debug_mode(debug_mode)


func execute(test_suite :GdUnitTestSuite) -> void:
	var orphan_detection_enabled := GdUnitSettings.is_verbose_orphans()
	if not orphan_detection_enabled:
		prints("!!! Reporting orphan nodes is disabled. Please check GdUnit settings.")

	(Engine.get_main_loop() as SceneTree).root.call_deferred("add_child", test_suite)
	await (Engine.get_main_loop() as SceneTree).process_frame
	await _executeStage.execute(GdUnitExecutionContext.of_test_suite(test_suite))


func fail_fast(enabled :bool) -> void:
	_executeStage.fail_fast(enabled)
## The test case shutdown hook implementation.[br]
## It executes the 'test_after()' block from the test-suite.
class_name GdUnitTestCaseAfterStage
extends IGdUnitExecutionStage


var _call_stage: bool


func _init(call_stage := true) -> void:
	_call_stage = call_stage


func _execute(context: GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite

	if _call_stage:
		@warning_ignore("redundant_await")
		await test_suite.after_test()

	await context.gc()
	await context.error_monitor_stop()

	var reports := context.build_reports()

	if context.is_skipped():
		fire_test_skipped(context)
	else:
		fire_event(GdUnitEvent.new() \
			.test_after(context.get_test_suite_path(),
				context.get_test_suite_name(),
				context.get_test_case_name(),
				context.get_execution_statistics(),
				reports))


func fire_test_skipped(context: GdUnitExecutionContext) -> void:
	var test_case := context.test_case
	var statistics := {
		GdUnitEvent.ORPHAN_NODES: 0,
		GdUnitEvent.ELAPSED_TIME: 0,
		GdUnitEvent.WARNINGS: false,
		GdUnitEvent.ERRORS: false,
		GdUnitEvent.ERROR_COUNT: 0,
		GdUnitEvent.FAILED: false,
		GdUnitEvent.FAILED_COUNT: 0,
		GdUnitEvent.SKIPPED: true,
		GdUnitEvent.SKIPPED_COUNT: 1,
	}
	var report := GdUnitReport.new() \
		.create(GdUnitReport.SKIPPED, test_case.line_number(), GdAssertMessages.test_skipped(test_case.skip_info()))
	fire_event(GdUnitEvent.new() \
		.test_after(context.get_test_suite_path(),
			context.get_test_suite_name(),
			context.get_test_case_name(),
			statistics,
			[report]))
## The test case startup hook implementation.[br]
## It executes the 'test_before()' block from the test-suite.
class_name GdUnitTestCaseBeforeStage
extends IGdUnitExecutionStage

var _call_stage :bool


func _init(call_stage := true) -> void:
	_call_stage = call_stage


func _execute(context :GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite

	fire_event(GdUnitEvent.new()\
		.test_before(context.get_test_suite_path(), context.get_test_suite_name(), context.get_test_case_name()))
	if _call_stage:
		@warning_ignore("redundant_await")
		await test_suite.before_test()
	context.error_monitor_start()
## The test case execution stage.[br]
class_name GdUnitTestCaseExecutionStage
extends IGdUnitExecutionStage


var _stage_single_test :IGdUnitExecutionStage = GdUnitTestCaseSingleExecutionStage.new()
var _stage_fuzzer_test :IGdUnitExecutionStage = GdUnitTestCaseFuzzedExecutionStage.new()
var _stage_parameterized_test :IGdUnitExecutionStage= GdUnitTestCaseParameterizedExecutionStage.new()


## Executes the test case 'test_<name>()'.[br]
## It executes synchronized following stages[br]
##  -> test_before() [br]
##  -> test_case() [br]
##  -> test_after() [br]
@warning_ignore("redundant_await")
func _execute(context :GdUnitExecutionContext) -> void:
	var test_case := context.test_case

	context.error_monitor_start()

	if test_case.is_parameterized():
		await _stage_parameterized_test.execute(context)
	elif test_case.is_fuzzed():
		await _stage_fuzzer_test.execute(context)
	else:
		await _stage_single_test.execute(context)

	await context.gc()
	await context.error_monitor_stop()

	# finally fire test statistics report
	fire_event(GdUnitEvent.new()\
		.test_statistics(context.get_test_suite_path(),
			context.get_test_suite_name(),
			context.get_test_case_name(),
			context.get_execution_statistics()))

	# finally free the test instance
	if is_instance_valid(context.test_case):
		context.test_case.dispose()


func set_debug_mode(debug_mode :bool = false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_single_test.set_debug_mode(debug_mode)
	_stage_fuzzer_test.set_debug_mode(debug_mode)
	_stage_parameterized_test.set_debug_mode(debug_mode)
## The test suite shutdown hook implementation.[br]
## It executes the 'after()' block from the test-suite.
class_name GdUnitTestSuiteAfterStage
extends IGdUnitExecutionStage


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")


func _execute(context :GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite

	@warning_ignore("redundant_await")
	await test_suite.after()
	await context.gc()
	var reports := context.build_reports(false)
	fire_event(GdUnitEvent.new()\
		.suite_after(context.get_test_suite_path(),\
			test_suite.get_name(),
			context.get_execution_statistics(),
			reports))

	GdUnitFileAccess.clear_tmp()
	# Guard that checks if all doubled (spy/mock) objects are released
	GdUnitClassDoubler.check_leaked_instances()
	# we hide the scene/main window after runner is finished
	DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_MINIMIZED)
## The test suite startup hook implementation.[br]
## It executes the 'before()' block from the test-suite.
class_name GdUnitTestSuiteBeforeStage
extends IGdUnitExecutionStage


func _execute(context :GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite

	fire_event(GdUnitEvent.new()\
		.suite_before(context.get_test_suite_path(), test_suite.get_name(), test_suite.get_child_count()))

	@warning_ignore("redundant_await")
	await test_suite.before()
## The test suite main execution stage.[br]
class_name GdUnitTestSuiteExecutionStage
extends IGdUnitExecutionStage

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

var _stage_before :IGdUnitExecutionStage = GdUnitTestSuiteBeforeStage.new()
var _stage_after :IGdUnitExecutionStage = GdUnitTestSuiteAfterStage.new()
var _stage_test :IGdUnitExecutionStage = GdUnitTestCaseExecutionStage.new()
var _fail_fast := false


## Executes all tests of an test suite.[br]
## It executes synchronized following stages[br]
##  -> before() [br]
##  -> run all test cases [br]
##  -> after() [br]
func _execute(context :GdUnitExecutionContext) -> void:
	if context.test_suite.__is_skipped:
		await fire_test_suite_skipped(context)
	else:
		@warning_ignore("return_value_discarded")
		GdUnitMemoryObserver.guard_instance(context.test_suite.__awaiter)
		await _stage_before.execute(context)
		for test_case_index in context.test_suite.get_child_count():
			# iterate only over test cases
			var test_case := context.test_suite.get_child(test_case_index) as _TestCase
			if not is_instance_valid(test_case):
				continue
			context.test_suite.set_active_test_case(test_case.get_name())
			await _stage_test.execute(GdUnitExecutionContext.of_test_case(context, test_case))
			# stop on first error or if fail fast is enabled
			if _fail_fast and not context.is_success():
				break
			if test_case.is_interupted():
				# it needs to go this hard way to kill the outstanding awaits of a test case when the test timed out
				# we delete the current test suite where is execute the current test case to kill the function state
				# and replace it by a clone without function state
				context.test_suite = await clone_test_suite(context.test_suite)
		await _stage_after.execute(context)
		GdUnitMemoryObserver.unguard_instance(context.test_suite.__awaiter)
	await (Engine.get_main_loop() as SceneTree).process_frame
	context.test_suite.free()
	context.dispose()


# clones a test suite and moves the test cases to new instance
func clone_test_suite(test_suite :GdUnitTestSuite) -> GdUnitTestSuite:
	await (Engine.get_main_loop() as SceneTree).process_frame
	dispose_timers(test_suite)
	await GdUnitMemoryObserver.gc_guarded_instance("Manually free on awaiter", test_suite.__awaiter)
	var parent := test_suite.get_parent()
	var _test_suite := GdUnitTestSuite.new()
	parent.remove_child(test_suite)
	copy_properties(test_suite, _test_suite)
	for child in test_suite.get_children():
		test_suite.remove_child(child)
		_test_suite.add_child(child)
	parent.add_child(_test_suite)
	@warning_ignore("return_value_discarded")
	GdUnitMemoryObserver.guard_instance(_test_suite.__awaiter)
	# finally free current test suite instance
	test_suite.free()
	await (Engine.get_main_loop() as SceneTree).process_frame
	return _test_suite


func dispose_timers(test_suite :GdUnitTestSuite) -> void:
	GdUnitTools.release_timers()
	for child in test_suite.get_children():
		if child is Timer:
			(child as Timer).stop()
			test_suite.remove_child(child)
			child.free()


func copy_properties(source :Object, target :Object) -> void:
	if not source is _TestCase and not source is GdUnitTestSuite:
		return
	for property in source.get_property_list():
		var property_name :String = property["name"]
		if property_name == "__awaiter":
			continue
		target.set(property_name, source.get(property_name))


func fire_test_suite_skipped(context :GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite
	var skip_count := test_suite.get_child_count()
	fire_event(GdUnitEvent.new()\
		.suite_before(context.get_test_suite_path(), test_suite.get_name(), skip_count))


	for test_case_index in context.test_suite.get_child_count():
			# iterate only over test cases
			var test_case := context.test_suite.get_child(test_case_index) as _TestCase
			if not is_instance_valid(test_case):
				continue
			var test_case_context := GdUnitExecutionContext.of_test_case(context, test_case)
			fire_event(GdUnitEvent.new()\
				.test_before(test_case_context.get_test_suite_path(), test_case_context.get_test_suite_name(), test_case_context.get_test_case_name()))
			fire_test_skipped(test_case_context)


	var statistics := {
		GdUnitEvent.ORPHAN_NODES: 0,
		GdUnitEvent.ELAPSED_TIME: 0,
		GdUnitEvent.WARNINGS: false,
		GdUnitEvent.ERRORS: false,
		GdUnitEvent.ERROR_COUNT: 0,
		GdUnitEvent.FAILED: false,
		GdUnitEvent.FAILED_COUNT: 0,
		GdUnitEvent.SKIPPED_COUNT: skip_count,
		GdUnitEvent.SKIPPED: true
	}
	var report := GdUnitReport.new().create(GdUnitReport.SKIPPED, -1, GdAssertMessages.test_suite_skipped(test_suite.__skip_reason, skip_count))
	fire_event(GdUnitEvent.new().suite_after(context.get_test_suite_path(), test_suite.get_name(), statistics, [report]))
	await (Engine.get_main_loop() as SceneTree).process_frame


func fire_test_skipped(context: GdUnitExecutionContext) -> void:
	var test_case := context.test_case
	var statistics := {
		GdUnitEvent.ORPHAN_NODES: 0,
		GdUnitEvent.ELAPSED_TIME: 0,
		GdUnitEvent.WARNINGS: false,
		GdUnitEvent.ERRORS: false,
		GdUnitEvent.ERROR_COUNT: 0,
		GdUnitEvent.FAILED: false,
		GdUnitEvent.FAILED_COUNT: 0,
		GdUnitEvent.SKIPPED: true,
		GdUnitEvent.SKIPPED_COUNT: 1,
	}
	var report := GdUnitReport.new() \
		.create(GdUnitReport.SKIPPED, test_case.line_number(), GdAssertMessages.test_skipped("Skipped from the entire test suite"))
	fire_event(GdUnitEvent.new() \
		.test_after(context.get_test_suite_path(),
			context.get_test_suite_name(),
			context.get_test_case_name(),
			statistics,
			[report]))
	# finally fire test statistics report
	fire_event(GdUnitEvent.new()\
		.test_statistics(context.get_test_suite_path(),
			context.get_test_suite_name(),
			context.get_test_case_name(),
			statistics))


func set_debug_mode(debug_mode :bool = false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_before.set_debug_mode(debug_mode)
	_stage_after.set_debug_mode(debug_mode)
	_stage_test.set_debug_mode(debug_mode)


func fail_fast(enabled :bool) -> void:
	_fail_fast = enabled
## The interface of execution stage.[br]
## An execution stage is defined as an encapsulated task that can execute 1-n substages covered by its own execution context.[br]
## Execution stage are always called synchronously.
class_name IGdUnitExecutionStage
extends RefCounted

var _debug_mode := false


## Executes synchronized the implemented stage in its own execution context.[br]
## example:[br]
## [codeblock]
##    # waits for 100ms
##    await MyExecutionStage.new().execute(<GdUnitExecutionContext>)
## [/codeblock][br]
func execute(context :GdUnitExecutionContext) -> void:
	GdUnitThreadManager.get_current_context().set_execution_context(context)
	@warning_ignore("redundant_await")
	await _execute(context)


## Sends the event to registered listeners
func fire_event(event :GdUnitEvent) -> void:
	if _debug_mode:
		GdUnitSignals.instance().gdunit_event_debug.emit(event)
	else:
		GdUnitSignals.instance().gdunit_event.emit(event)


## Internal testing stuff.[br]
## Sets the executor into debug mode to emit `GdUnitEvent` via signal `gdunit_event_debug`
func set_debug_mode(debug_mode :bool) -> void:
	_debug_mode = debug_mode


## The execution phase to be carried out.
func _execute(_context :GdUnitExecutionContext) -> void:
	@warning_ignore("assert_always_false")
	assert(false, "The execution stage is not implemented")
## The test case execution stage.[br]
class_name GdUnitTestCaseFuzzedExecutionStage
extends IGdUnitExecutionStage

var _stage_before :IGdUnitExecutionStage = GdUnitTestCaseBeforeStage.new(false)
var _stage_after :IGdUnitExecutionStage = GdUnitTestCaseAfterStage.new(false)
var _stage_test :IGdUnitExecutionStage = GdUnitTestCaseFuzzedTestStage.new()


func _execute(context :GdUnitExecutionContext) -> void:
	while context.retry_execution():
		var test_context := GdUnitExecutionContext.of(context)
		await _stage_before.execute(test_context)
		if not context.test_case.is_skipped():
			await _stage_test.execute(GdUnitExecutionContext.of(test_context))
		await _stage_after.execute(test_context)
		if test_context.is_success() or test_context.is_skipped() or test_context.is_interupted():
			break
	@warning_ignore("return_value_discarded")
	context.evaluate_test_retry_status()


func set_debug_mode(debug_mode :bool = false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_before.set_debug_mode(debug_mode)
	_stage_after.set_debug_mode(debug_mode)
	_stage_test.set_debug_mode(debug_mode)
## The fuzzed test case execution stage.[br]
class_name GdUnitTestCaseFuzzedTestStage
extends IGdUnitExecutionStage

var _expression_runner := GdUnitExpressionRunner.new()


## Executes a test case with given fuzzers 'test_<name>(<fuzzer>)' iterative.[br]
## It executes synchronized following stages[br]
##  -> test_case() [br]
func _execute(context :GdUnitExecutionContext) -> void:
	var test_suite := context.test_suite
	var test_case := context.test_case
	var fuzzers := create_fuzzers(test_suite, test_case)

	# guard on fuzzers
	for fuzzer in fuzzers:
		@warning_ignore("return_value_discarded")
		GdUnitMemoryObserver.guard_instance(fuzzer)

	for iteration in test_case.iterations():
		@warning_ignore("redundant_await")
		await test_suite.before_test()
		await test_case.execute(fuzzers, iteration)
		@warning_ignore("redundant_await")
		await test_suite.after_test()
		if test_case.is_interupted():
			break
		# interrupt at first failure
		var reports := context.reports()
		if not reports.is_empty():
			var report :GdUnitReport = reports.pop_front()
			reports.append(GdUnitReport.new() \
				.create(GdUnitReport.FAILURE, report.line_number(), GdAssertMessages.fuzzer_interuped(iteration, report.message())))
			break
	await context.gc()

	# unguard on fuzzers
	if not test_case.is_interupted():
		for fuzzer in fuzzers:
			GdUnitMemoryObserver.unguard_instance(fuzzer)


func create_fuzzers(test_suite :GdUnitTestSuite, test_case :_TestCase) -> Array[Fuzzer]:
	if not test_case.is_fuzzed():
		return Array()
	test_case.generate_seed()
	var fuzzers :Array[Fuzzer] = []
	for fuzzer_arg in test_case.fuzzer_arguments():
		@warning_ignore("unsafe_cast")
		var fuzzer := _expression_runner.to_fuzzer(test_suite.get_script() as GDScript, fuzzer_arg.plain_value() as String)
		fuzzer._iteration_index = 0
		fuzzer._iteration_limit = test_case.iterations()
		fuzzers.append(fuzzer)
	return fuzzers
class_name GdUnitTestCaseParameterSetTestStage
extends IGdUnitExecutionStage


## Executes a parameterized test case 'test_<name>()' by given parameters.[br]
## It executes synchronized following stages[br]
##  -> test_case() [br]
func _execute(context: GdUnitExecutionContext) -> void:
	await context.test_case.execute_paramaterized(context._test_case_parameter_set)
	await context.gc()
## The test case execution stage.[br]
class_name GdUnitTestCaseParameterizedExecutionStage
extends IGdUnitExecutionStage


var _stage_before :IGdUnitExecutionStage = GdUnitTestCaseBeforeStage.new(false)
var _stage_after :IGdUnitExecutionStage = GdUnitTestCaseAfterStage.new(false)
var _stage_test :IGdUnitExecutionStage = GdUnitTestCaseParamaterizedTestStage.new()


func _execute(context :GdUnitExecutionContext) -> void:
	await _stage_before.execute(context)
	if not context.test_case.is_skipped():
		await _stage_test.execute(GdUnitExecutionContext.of(context))
	await _stage_after.execute(context)


func set_debug_mode(debug_mode :bool = false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_before.set_debug_mode(debug_mode)
	_stage_after.set_debug_mode(debug_mode)
	_stage_test.set_debug_mode(debug_mode)
## The parameterized test case execution stage.[br]
class_name GdUnitTestCaseParamaterizedTestStage
extends IGdUnitExecutionStage

var _stage_before: IGdUnitExecutionStage = GdUnitTestCaseBeforeStage.new()
var _stage_after: IGdUnitExecutionStage = GdUnitTestCaseAfterStage.new()
var _stage_test: IGdUnitExecutionStage = GdUnitTestCaseParameterSetTestStage.new()


## Executes a parameterized test case.[br]
## It executes synchronized following stages[br]
##  -> test_case( <test_parameters> ) [br]
func _execute(context: GdUnitExecutionContext) -> void:
	var test_case := context.test_case
	var test_parameter_index := test_case.test_parameter_index()
	var parameter_set_resolver := test_case.parameter_set_resolver()
	var test_names := parameter_set_resolver.build_test_case_names(test_case)

	# if all parameter sets has static values we can preload and reuse it for better performance
	var parameter_sets :Array = []
	if parameter_set_resolver.is_parameter_sets_static():
		parameter_sets = parameter_set_resolver.load_parameter_sets(test_case, true)

	for parameter_set_index in test_names.size():
		# is test_parameter_index is set, we run this parameterized test only
		if test_parameter_index != -1 and test_parameter_index != parameter_set_index:
			continue
		var current_test_case_name := test_names[parameter_set_index]
		var test_case_parameter_set: Array
		if parameter_set_resolver.is_parameter_set_static(parameter_set_index):
			test_case_parameter_set = parameter_sets[parameter_set_index]

		var test_context := GdUnitExecutionContext.of(context)
		test_context._test_case_name = current_test_case_name
		var has_errors := false
		while test_context.retry_execution():
			var retry_test_context := GdUnitExecutionContext.of(test_context)

			retry_test_context._test_case_name = current_test_case_name
			await _stage_before.execute(retry_test_context)
			if not test_case.is_interupted():
				# we need to load paramater set at execution level after the before stage to get the actual variables from the current test
				if not parameter_set_resolver.is_parameter_set_static(parameter_set_index):
					test_case_parameter_set = _load_parameter_set(context, parameter_set_index)
				await _stage_test.execute(GdUnitExecutionContext.of_parameterized_test(retry_test_context, current_test_case_name, test_case_parameter_set))
			await _stage_after.execute(retry_test_context)
			has_errors = retry_test_context.has_errors()
			if retry_test_context.is_success() or retry_test_context.is_skipped() or retry_test_context.is_interupted():
				break

		var is_success := test_context.evaluate_test_retry_status()
		report_test_failure(context, !is_success, has_errors, parameter_set_index)

		if test_case.is_interupted():
			break
	await context.gc()


func report_test_failure(test_context: GdUnitExecutionContext, is_failed: bool, has_errors: bool, parameter_set_index: int) -> void:
	var test_case := test_context.test_case

	if is_failed:
		test_context.add_report(GdUnitReport.new().create(GdUnitReport.FAILURE, test_case.line_number(), "Test failed at parameterized index %d." % parameter_set_index))
	if has_errors:
		test_context.add_report(GdUnitReport.new().create(GdUnitReport.ABORT, test_case.line_number(), "Test aborted at parameterized index %d." % parameter_set_index))


func _load_parameter_set(context: GdUnitExecutionContext, parameter_set_index: int) -> Array:
	var test_case := context.test_case
	# we need to exchange temporary for parameter resolving the execution context
	# this is necessary because of possible usage of `auto_free` and needs to run in the parent execution context
	var thread_context := GdUnitThreadManager.get_current_context()
	var save_execution_context := thread_context.get_execution_context()
	thread_context.set_execution_context(context)
	var parameters := test_case.load_parameter_sets()
	# restore the original execution context and restart the orphan monitor to get new instances into account
	thread_context.set_execution_context(save_execution_context)
	save_execution_context.orphan_monitor_start()
	return parameters[parameter_set_index]


func set_debug_mode(debug_mode: bool=false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_before.set_debug_mode(debug_mode)
	_stage_after.set_debug_mode(debug_mode)
	_stage_test.set_debug_mode(debug_mode)
## The test case execution stage.[br]
class_name GdUnitTestCaseSingleExecutionStage
extends IGdUnitExecutionStage


var _stage_before :IGdUnitExecutionStage = GdUnitTestCaseBeforeStage.new()
var _stage_after :IGdUnitExecutionStage = GdUnitTestCaseAfterStage.new()
var _stage_test :IGdUnitExecutionStage = GdUnitTestCaseSingleTestStage.new()


func _execute(context :GdUnitExecutionContext) -> void:
	while context.retry_execution():
		var test_context := GdUnitExecutionContext.of(context)
		await _stage_before.execute(test_context)
		if not test_context.is_skipped():
			await _stage_test.execute(GdUnitExecutionContext.of(test_context))
		await _stage_after.execute(test_context)
		if test_context.is_success() or test_context.is_skipped() or test_context.is_interupted():
			break
	@warning_ignore("return_value_discarded")
	context.evaluate_test_retry_status()


func set_debug_mode(debug_mode :bool = false) -> void:
	super.set_debug_mode(debug_mode)
	_stage_before.set_debug_mode(debug_mode)
	_stage_after.set_debug_mode(debug_mode)
	_stage_test.set_debug_mode(debug_mode)
## The single test case execution stage.[br]
class_name GdUnitTestCaseSingleTestStage
extends IGdUnitExecutionStage


## Executes a single test case 'test_<name>()'.[br]
## It executes synchronized following stages[br]
##  -> test_case() [br]
func _execute(context :GdUnitExecutionContext) -> void:
	await context.test_case.execute()
	await context.gc()
class_name GdClassDescriptor
extends RefCounted


var _name :String
var _is_inner_class :bool
var _functions :Array[GdFunctionDescriptor]


func _init(p_name :String, p_is_inner_class :bool, p_functions :Array[GdFunctionDescriptor]) -> void:
	_name = p_name
	_is_inner_class = p_is_inner_class
	_functions = p_functions


func name() -> String:
	return _name


func is_inner_class() -> bool:
	return _is_inner_class


func functions() -> Array[GdFunctionDescriptor]:
	return _functions
# holds all decodings for default values
class_name GdDefaultValueDecoder
extends GdUnitSingleton


@warning_ignore("unused_parameter")
var _decoders := {
	TYPE_NIL: func(value :Variant) -> String: return "null",
	TYPE_STRING: func(value :Variant) -> String: return '"%s"' % value,
	TYPE_STRING_NAME: _on_type_StringName,
	TYPE_BOOL: func(value :Variant) -> String: return str(value).to_lower(),
	TYPE_FLOAT: func(value :Variant) -> String: return '%f' % value,
	TYPE_COLOR: _on_type_Color,
	TYPE_ARRAY: _on_type_Array.bind(TYPE_ARRAY),
	TYPE_PACKED_BYTE_ARRAY: _on_type_Array.bind(TYPE_PACKED_BYTE_ARRAY),
	TYPE_PACKED_STRING_ARRAY: _on_type_Array.bind(TYPE_PACKED_STRING_ARRAY),
	TYPE_PACKED_FLOAT32_ARRAY: _on_type_Array.bind(TYPE_PACKED_FLOAT32_ARRAY),
	TYPE_PACKED_FLOAT64_ARRAY: _on_type_Array.bind(TYPE_PACKED_FLOAT64_ARRAY),
	TYPE_PACKED_INT32_ARRAY: _on_type_Array.bind(TYPE_PACKED_INT32_ARRAY),
	TYPE_PACKED_INT64_ARRAY: _on_type_Array.bind(TYPE_PACKED_INT64_ARRAY),
	TYPE_PACKED_COLOR_ARRAY: _on_type_Array.bind(TYPE_PACKED_COLOR_ARRAY),
	TYPE_PACKED_VECTOR2_ARRAY: _on_type_Array.bind(TYPE_PACKED_VECTOR2_ARRAY),
	TYPE_PACKED_VECTOR3_ARRAY: _on_type_Array.bind(TYPE_PACKED_VECTOR3_ARRAY),
	GdObjects.TYPE_PACKED_VECTOR4_ARRAY: _on_type_Array.bind(GdObjects.TYPE_PACKED_VECTOR4_ARRAY),
	TYPE_DICTIONARY: _on_type_Dictionary,
	TYPE_RID: _on_type_RID,
	TYPE_NODE_PATH: _on_type_NodePath,
	TYPE_VECTOR2: _on_type_Vector.bind(TYPE_VECTOR2),
	TYPE_VECTOR2I: _on_type_Vector.bind(TYPE_VECTOR2I),
	TYPE_VECTOR3: _on_type_Vector.bind(TYPE_VECTOR3),
	TYPE_VECTOR3I: _on_type_Vector.bind(TYPE_VECTOR3I),
	TYPE_VECTOR4: _on_type_Vector.bind(TYPE_VECTOR4),
	TYPE_VECTOR4I: _on_type_Vector.bind(TYPE_VECTOR4I),
	TYPE_RECT2: _on_type_Rect2,
	TYPE_RECT2I: _on_type_Rect2i,
	TYPE_PLANE: _on_type_Plane,
	TYPE_QUATERNION: _on_type_Quaternion,
	TYPE_AABB: _on_type_AABB,
	TYPE_BASIS: _on_type_Basis,
	TYPE_CALLABLE: _on_type_Callable,
	TYPE_SIGNAL: _on_type_Signal,
	TYPE_TRANSFORM2D: _on_type_Transform2D,
	TYPE_TRANSFORM3D: _on_type_Transform3D,
	TYPE_PROJECTION: _on_type_Projection,
	TYPE_OBJECT: _on_type_Object
}

static func _regex(pattern :String) -> RegEx:
	var regex := RegEx.new()
	var err := regex.compile(pattern)
	if err != OK:
		push_error("error '%s' checked pattern '%s'" % [err, pattern])
		return null
	return regex


func get_decoder(type :int) -> Callable:
	return _decoders.get(type, func(value :Variant) -> String: return '%s' % value)


func _on_type_StringName(value :StringName) -> String:
	if value.is_empty():
		return 'StringName()'
	return 'StringName("%s")' % value


func _on_type_Object(value: Variant, _type: int) -> String:
	return str(value)


func _on_type_Color(color: Color) -> String:
	if color == Color.BLACK:
		return "Color()"
	return "Color%s" % color


func _on_type_NodePath(path :NodePath) -> String:
	if path.is_empty():
		return 'NodePath()'
	return 'NodePath("%s")' % path


func _on_type_Callable(_cb :Callable) -> String:
	return 'Callable()'


func _on_type_Signal(_s :Signal) -> String:
	return 'Signal()'


func _on_type_Dictionary(dict :Dictionary) -> String:
	if dict.is_empty():
		return '{}'
	return str(dict)


func _on_type_Array(value :Variant, type :int) -> String:
	match type:
		TYPE_ARRAY:
			return str(value)

		TYPE_PACKED_COLOR_ARRAY:
			var colors := PackedStringArray()
			for color: Color in value:
				@warning_ignore("return_value_discarded")
				colors.append(_on_type_Color(color))
			if colors.is_empty():
				return "PackedColorArray()"
			return "PackedColorArray([%s])" % ", ".join(colors)

		TYPE_PACKED_VECTOR2_ARRAY:
			var vectors := PackedStringArray()
			for vector: Vector2 in value:
				@warning_ignore("return_value_discarded")
				vectors.append(_on_type_Vector(vector, TYPE_VECTOR2))
			if vectors.is_empty():
				return "PackedVector2Array()"
			return "PackedVector2Array([%s])" % ", ".join(vectors)

		TYPE_PACKED_VECTOR3_ARRAY:
			var vectors := PackedStringArray()
			for vector: Vector3 in value:
				@warning_ignore("return_value_discarded")
				vectors.append(_on_type_Vector(vector, TYPE_VECTOR3))
			if vectors.is_empty():
				return "PackedVector3Array()"
			return "PackedVector3Array([%s])" % ", ".join(vectors)

		GdObjects.TYPE_PACKED_VECTOR4_ARRAY:
			var vectors := PackedStringArray()
			for vector: Vector4 in value:
				@warning_ignore("return_value_discarded")
				vectors.append(_on_type_Vector(vector, TYPE_VECTOR4))
			if vectors.is_empty():
				return "PackedVector4Array()"
			return "PackedVector4Array([%s])" % ", ".join(vectors)

		TYPE_PACKED_STRING_ARRAY:
			var values := PackedStringArray()
			for v: String in value:
				@warning_ignore("return_value_discarded")
				values.append('"%s"' % v)
			if values.is_empty():
				return "PackedStringArray()"
			return "PackedStringArray([%s])" % ", ".join(values)

		TYPE_PACKED_BYTE_ARRAY,\
		TYPE_PACKED_FLOAT32_ARRAY,\
		TYPE_PACKED_FLOAT64_ARRAY,\
		TYPE_PACKED_INT32_ARRAY,\
		TYPE_PACKED_INT64_ARRAY:
			var vectors := PackedStringArray()
			for vector :Variant in value:
				@warning_ignore("return_value_discarded")
				vectors.append(str(vector))
			if vectors.is_empty():
				return GdObjects.type_as_string(type) + "()"
			return "%s([%s])" % [GdObjects.type_as_string(type), ", ".join(vectors)]
	return "unknown array type %d" % type


func _on_type_Vector(value :Variant, type :int) -> String:
	match type:
		TYPE_VECTOR2:
			if value == Vector2():
				return "Vector2()"
			return "Vector2%s" % value
		TYPE_VECTOR2I:
			if value == Vector2i():
				return "Vector2i()"
			return "Vector2i%s" % value
		TYPE_VECTOR3:
			if value == Vector3():
				return "Vector3()"
			return "Vector3%s" % value
		TYPE_VECTOR3I:
			if value == Vector3i():
				return "Vector3i()"
			return "Vector3i%s" % value
		TYPE_VECTOR4:
			if value == Vector4():
				return "Vector4()"
			return "Vector4%s" % value
		TYPE_VECTOR4I:
			if value == Vector4i():
				return "Vector4i()"
			return "Vector4i%s" % value
	return "unknown vector type %d" % type


func _on_type_Transform2D(transform :Transform2D) -> String:
	if transform == Transform2D():
		return "Transform2D()"
	return "Transform2D(Vector2%s, Vector2%s, Vector2%s)" % [transform.x, transform.y, transform.origin]


func _on_type_Transform3D(transform :Transform3D) -> String:
	if transform == Transform3D():
		return "Transform3D()"
	return "Transform3D(Vector3%s, Vector3%s, Vector3%s, Vector3%s)" % [transform.basis.x, transform.basis.y, transform.basis.z, transform.origin]


func _on_type_Projection(projection :Projection) -> String:
	return "Projection(Vector4%s, Vector4%s, Vector4%s, Vector4%s)" % [projection.x, projection.y, projection.z, projection.w]


@warning_ignore("unused_parameter")
func _on_type_RID(value :RID) -> String:
	return "RID()"


func _on_type_Rect2(rect :Rect2) -> String:
	if rect == Rect2():
		return "Rect2()"
	return "Rect2(Vector2%s, Vector2%s)" % [rect.position, rect.size]


func _on_type_Rect2i(rect :Variant) -> String:
	if rect == Rect2i():
		return "Rect2i()"
	return "Rect2i(Vector2i%s, Vector2i%s)" % [rect.position, rect.size]


func _on_type_Plane(plane :Plane) -> String:
	if plane == Plane():
		return "Plane()"
	return "Plane(%d, %d, %d, %d)" % [plane.x, plane.y, plane.z, plane.d]


func _on_type_Quaternion(quaternion :Quaternion) -> String:
	if quaternion == Quaternion():
		return "Quaternion()"
	return "Quaternion(%d, %d, %d, %d)" % [quaternion.x, quaternion.y, quaternion.z, quaternion.w]


func _on_type_AABB(aabb :AABB) -> String:
	if aabb == AABB():
		return "AABB()"
	return "AABB(Vector3%s, Vector3%s)" % [aabb.position, aabb.size]


func _on_type_Basis(basis :Basis) -> String:
	if basis == Basis():
		return "Basis()"
	return "Basis(Vector3%s, Vector3%s, Vector3%s)" % [basis.x, basis.y, basis.z]


@warning_ignore("unsafe_cast")
static func decode(value :Variant) -> String:
	var type := typeof(value)
	if GdArrayTools.is_type_array(type) and (value as Array).is_empty():
		return "<empty>"
	var decoder :Callable = (
			instance("GdUnitDefaultValueDecoders",
				func() -> GdDefaultValueDecoder: return GdDefaultValueDecoder.new()
				) as GdDefaultValueDecoder
		).get_decoder(type)
	if decoder == null:
		push_error("No value decoder registered for type '%d'! Please open a Bug issue at 'https://github.com/MikeSchulze/gdUnit4/issues/new/choose'." % type)
		return "null"
	if type == TYPE_OBJECT:
		return decoder.call(value, type)
	return decoder.call(value)


@warning_ignore("unsafe_cast")
static func decode_typed(type :int, value :Variant) -> String:
	if value == null:
		return "null"
	var decoder: Callable = (
			instance("GdUnitDefaultValueDecoders",
				func() -> GdDefaultValueDecoder: return GdDefaultValueDecoder.new()
				) as GdDefaultValueDecoder
			).get_decoder(type)
	if decoder == null:
		push_error("No value decoder registered for type '%d'! Please open a Bug issue at 'https://github.com/MikeSchulze/gdUnit4/issues/new/choose'." % type)
		return "null"
	if type == TYPE_OBJECT:
		return decoder.call(value, type)
	return decoder.call(value)
class_name GdFunctionArgument
extends RefCounted


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const UNDEFINED: String = "<-NO_ARG->"
const ARG_PARAMETERIZED_TEST := "test_parameters"

static var _fuzzer_regex: RegEx
static var _cleanup_leading_spaces: RegEx
static var _fix_comma_space: RegEx

var _name: String
var _type: int
var _type_hint: int
var _default_value: Variant
var _parameter_sets: PackedStringArray = []


func _init(p_name: String, p_type: int, value: Variant = UNDEFINED, p_type_hint: int = TYPE_NIL) -> void:
	_init_static_variables()
	_name = p_name
	_type = p_type
	_type_hint = p_type_hint
	if value != null and p_name == ARG_PARAMETERIZED_TEST:
		_parameter_sets = _parse_parameter_set(str(value))
	_default_value = value
	# is argument a fuzzer?
	if _type == TYPE_OBJECT and _fuzzer_regex.search(_name):
		_type = GdObjects.TYPE_FUZZER


func _init_static_variables() -> void:
	if _fuzzer_regex == null:
		_fuzzer_regex = GdUnitTools.to_regex("((?!(fuzzer_(seed|iterations)))fuzzer?\\w+)( ?+= ?+| ?+:= ?+| ?+:Fuzzer ?+= ?+|)")
		_cleanup_leading_spaces = RegEx.create_from_string("(?m)^[ \t]+")
		_fix_comma_space = RegEx.create_from_string(""", {0,}\t{0,}(?=(?:[^"]*"[^"]*")*[^"]*$)(?!\\s)""")


func name() -> String:
	return _name


func default() -> Variant:
	return GodotVersionFixures.convert(_default_value, _type)


func set_value(value: String) -> void:
	# we onle need to apply default values for Objects, all others are provided by the method descriptor
	if _type == GdObjects.TYPE_FUZZER:
		_default_value = value
		return
	if _name == ARG_PARAMETERIZED_TEST:
		_parameter_sets = _parse_parameter_set(value)
		_default_value = value
		return

	if _type == TYPE_NIL or _type == GdObjects.TYPE_VARIANT:
		_type = _extract_value_type(value)
		_default_value = value
	if _default_value == null:
		_default_value = value


func _extract_value_type(value: String) -> int:
	if value != UNDEFINED:
		if _fuzzer_regex.search(_name):
			return GdObjects.TYPE_FUZZER
		if value.rfind(")") == value.length()-1:
			return GdObjects.TYPE_FUNC
	return _type


func value_as_string() -> String:
	if has_default():
		return GdDefaultValueDecoder.decode_typed(_type, _default_value)
	return ""


func plain_value() -> Variant:
	return _default_value


func type() -> int:
	return _type


func type_hint() -> int:
	return _type_hint


func has_default() -> bool:
	return not is_same(_default_value, UNDEFINED)


func is_typed_array() -> bool:
	return _type == TYPE_ARRAY and _type_hint != TYPE_NIL


func is_parameter_set() -> bool:
	return _name == ARG_PARAMETERIZED_TEST


func parameter_sets() -> PackedStringArray:
	return _parameter_sets


static func get_parameter_set(parameters :Array[GdFunctionArgument]) -> GdFunctionArgument:
	for current in parameters:
		if current != null and current.is_parameter_set():
			return current
	return null


func _to_string() -> String:
	var s := _name
	if _type != TYPE_NIL:
		s += ":" + GdObjects.type_as_string(_type)
	if _type_hint != TYPE_NIL:
		s += "[%s]" % GdObjects.type_as_string(_type_hint)
	if typeof(_default_value) != TYPE_STRING:
		s += "=" + value_as_string()
	return s


func _parse_parameter_set(input :String) -> PackedStringArray:
	if not input.contains("["):
		return []

	input = _cleanup_leading_spaces.sub(input, "", true)
	input = input.replace("\n", "").strip_edges().trim_prefix("[").trim_suffix("]").trim_prefix("]")
	var single_quote := false
	var double_quote := false
	var array_end := 0
	var current_index := 0
	var output :PackedStringArray = []
	var buf := input.to_utf8_buffer()
	var collected_characters: = PackedByteArray()
	var matched :bool = false

	for c in buf:
		current_index += 1
		matched = current_index == buf.size()
		@warning_ignore("return_value_discarded")
		collected_characters.push_back(c)

		match c:
			# ' ': ignore spaces between array elements
			32: if array_end == 0 and (not double_quote and not single_quote):
					collected_characters.remove_at(collected_characters.size()-1)
			# ',': step over array element seperator ','
			44: if array_end == 0:
					matched = true
					collected_characters.remove_at(collected_characters.size()-1)
			# '`':
			39: single_quote = !single_quote
			# '"':
			34: if not single_quote: double_quote = !double_quote
			# '['
			91: if not double_quote and not single_quote: array_end +=1 # counts array open
			# ']'
			93: if not double_quote and not single_quote: array_end -=1 # counts array closed

		# if array closed than collect the element
		if matched:
			var parameters := _fix_comma_space.sub(collected_characters.get_string_from_utf8(), ", ", true)
			if not parameters.is_empty():
				@warning_ignore("return_value_discarded")
				output.append(parameters)
			collected_characters.clear()
			matched = false
	return output
class_name GdFunctionDescriptor
extends RefCounted

var _is_virtual :bool
var _is_static :bool
var _is_engine :bool
var _is_coroutine :bool
var _name :String
var _source_path: String
var _line_number :int
var _return_type :int
var _return_class :String
var _args : Array[GdFunctionArgument]
var _varargs :Array[GdFunctionArgument]



static func create(p_name: String, p_source_path: String, p_source_line: int, p_return_type: int, p_args: Array[GdFunctionArgument] = []) -> GdFunctionDescriptor:
	var fd := GdFunctionDescriptor.new(p_name, p_source_line, false, false, false, p_return_type, "", p_args)
	fd.enrich_file_info(p_source_path, p_source_line)
	return fd

static func create_static(p_name: String, p_source_path: String, p_source_line: int, p_return_type: int, p_args: Array[GdFunctionArgument] = []) -> GdFunctionDescriptor:
	var fd := GdFunctionDescriptor.new(p_name, p_source_line, false, true, false, p_return_type, "", p_args)
	fd.enrich_file_info(p_source_path, p_source_line)
	return fd


func _init(p_name :String,
	p_line_number :int,
	p_is_virtual :bool,
	p_is_static :bool,
	p_is_engine :bool,
	p_return_type :int,
	p_return_class :String,
	p_args : Array[GdFunctionArgument],
	p_varargs :Array[GdFunctionArgument] = []) -> void:
	_name = p_name
	_line_number = p_line_number
	_return_type = p_return_type
	_return_class = p_return_class
	_is_virtual = p_is_virtual
	_is_static = p_is_static
	_is_engine = p_is_engine
	_is_coroutine = false
	_args = p_args
	_varargs = p_varargs


func with_return_class(clazz_name: String) -> GdFunctionDescriptor:
	_return_class = clazz_name
	return self


func name() -> String:
	return _name


func source_path() -> String:
	return _source_path


func line_number() -> int:
	return _line_number


func is_virtual() -> bool:
	return _is_virtual


func is_static() -> bool:
	return _is_static


func is_engine() -> bool:
	return _is_engine


func is_vararg() -> bool:
	return not _varargs.is_empty()


func is_coroutine() -> bool:
	return _is_coroutine


func is_parameterized() -> bool:
	for current in _args:
		var arg :GdFunctionArgument = current
		if arg.name() == GdFunctionArgument.ARG_PARAMETERIZED_TEST:
			return true
	return false


func is_private() -> bool:
	return name().begins_with("_") and not is_virtual()


func return_type() -> int:
	return _return_type


func return_type_as_string() -> String:
	if (return_type() == TYPE_OBJECT or return_type() == GdObjects.TYPE_ENUM) and not _return_class.is_empty():
		return _return_class
	return GdObjects.type_as_string(return_type())


@warning_ignore("unsafe_cast")
func set_argument_value(arg_name: String, value: String) -> void:
	(
		_args.filter(func(arg: GdFunctionArgument) -> bool: return arg.name() == arg_name)\
		.front() as GdFunctionArgument
	).set_value(value)


func enrich_file_info(p_source_path: String, p_line_number: int) -> void:
	_source_path = p_source_path
	_line_number = p_line_number


func args() -> Array[GdFunctionArgument]:
	return _args


func varargs() -> Array[GdFunctionArgument]:
	return _varargs


func typed_args() -> String:
	var collect := PackedStringArray()
	for arg in args():
		@warning_ignore("return_value_discarded")
		collect.push_back(arg._to_string())
	for arg in varargs():
		@warning_ignore("return_value_discarded")
		collect.push_back(arg._to_string())
	return ", ".join(collect)


func _to_string() -> String:
	var fsignature := "virtual " if is_virtual() else ""
	if _return_type == TYPE_NIL:
		return fsignature + "[Line:%s] func %s(%s):" % [line_number(), name(), typed_args()]
	var func_template := fsignature + "[Line:%s] func %s(%s) -> %s:"
	if is_static():
		func_template= "[Line:%s] static func %s(%s) -> %s:"
	return func_template % [line_number(), name(), typed_args(), return_type_as_string()]


# extract function description given by Object.get_method_list()
static func extract_from(descriptor :Dictionary, is_engine_ := true) -> GdFunctionDescriptor:
	var func_name: String = descriptor["name"]
	var function_flags: int = descriptor["flags"]
	var return_descriptor: Dictionary = descriptor["return"]
	var clazz_name: String = return_descriptor["class_name"]
	var is_virtual_: bool = function_flags & METHOD_FLAG_VIRTUAL
	var is_static_: bool = function_flags & METHOD_FLAG_STATIC
	var is_vararg_: bool = function_flags & METHOD_FLAG_VARARG

	return GdFunctionDescriptor.new(
		func_name,
		-1,
		is_virtual_,
		is_static_,
		is_engine_,
		_extract_return_type(return_descriptor),
		clazz_name,
		_extract_args(descriptor),
		_build_varargs(is_vararg_)
	)

# temporary exclude GlobalScope enums
const enum_fix := [
	"Side",
	"Corner",
	"Orientation",
	"ClockDirection",
	"HorizontalAlignment",
	"VerticalAlignment",
	"InlineAlignment",
	"EulerOrder",
	"Error",
	"Key",
	"MIDIMessage",
	"MouseButton",
	"MouseButtonMask",
	"JoyButton",
	"JoyAxis",
	"PropertyHint",
	"PropertyUsageFlags",
	"MethodFlags",
	"Variant.Type",
	"Control.LayoutMode"]


static func _extract_return_type(return_info :Dictionary) -> int:
	var type :int = return_info["type"]
	var usage :int = return_info["usage"]
	if type == TYPE_INT and usage & PROPERTY_USAGE_CLASS_IS_ENUM:
		return GdObjects.TYPE_ENUM
	if type == TYPE_NIL and usage & PROPERTY_USAGE_NIL_IS_VARIANT:
		return GdObjects.TYPE_VARIANT
	if type == TYPE_NIL and usage == 6:
		return GdObjects.TYPE_VOID
	return type


static func _extract_args(descriptor :Dictionary) -> Array[GdFunctionArgument]:
	var args_ :Array[GdFunctionArgument] = []
	var arguments :Array = descriptor["args"]
	var defaults :Array = descriptor["default_args"]
	# iterate backwards because the default values are stored from right to left
	while not arguments.is_empty():
		var arg :Dictionary = arguments.pop_back()
		var arg_name := _argument_name(arg)
		var arg_type := _argument_type(arg)
		var arg_type_hint := _argument_hint(arg)
		#var arg_class: StringName = arg["class_name"]
		var default_value: Variant = GdFunctionArgument.UNDEFINED if defaults.is_empty() else defaults.pop_back()
		args_.push_front(GdFunctionArgument.new(arg_name, arg_type, default_value, arg_type_hint))
	return args_


static func _build_varargs(p_is_vararg :bool) -> Array[GdFunctionArgument]:
	var varargs_ :Array[GdFunctionArgument] = []
	if not p_is_vararg:
		return varargs_
	# if function has vararg we need to handle this manually by adding 10 default arguments
	var type := GdObjects.TYPE_VARARG
	for index in 10:
		varargs_.push_back(GdFunctionArgument.new("vararg%d_" % index, type, '"%s"' % GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE))
	return varargs_


static func _argument_name(arg :Dictionary) -> String:
	return arg["name"]


static func _argument_type(arg :Dictionary) -> int:
	var type :int = arg["type"]
	var usage :int = arg["usage"]

	if type == TYPE_OBJECT:
		if arg["class_name"] == "Node":
			return GdObjects.TYPE_NODE
		if arg["class_name"] == "Fuzzer":
			return GdObjects.TYPE_FUZZER

	# if the argument untyped we need to scan the assignef value type
	if type == TYPE_NIL and usage == PROPERTY_USAGE_NIL_IS_VARIANT:
		return GdObjects.TYPE_VARIANT
	return type


static func _argument_hint(arg :Dictionary) -> int:
	var hint :int = arg["hint"]
	var hint_string :String = arg["hint_string"]

	match hint:
		PROPERTY_HINT_ARRAY_TYPE:
			return GdObjects.string_to_type(hint_string)
		_:
			return 0


static func _argument_type_as_string(arg :Dictionary) -> String:
	var type := _argument_type(arg)
	match type:
		TYPE_NIL:
			return ""
		TYPE_OBJECT:
			var clazz_name :String = arg["class_name"]
			if not clazz_name.is_empty():
				return clazz_name
			return ""
		_:
			return GdObjects.type_as_string(type)
class_name GdScriptParser
extends RefCounted

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const ALLOWED_CHARACTERS := "0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\""

var TOKEN_NOT_MATCH := Token.new("")
var TOKEN_SPACE := SkippableToken.new(" ")
var TOKEN_TABULATOR := SkippableToken.new("\t")
var TOKEN_NEW_LINE := SkippableToken.new("\n")
var TOKEN_COMMENT := SkippableToken.new("#")
var TOKEN_CLASS_NAME := Token.new("class_name")
var TOKEN_INNER_CLASS := Token.new("class")
var TOKEN_EXTENDS := Token.new("extends")
var TOKEN_ENUM := Token.new("enum")
var TOKEN_FUNCTION_STATIC_DECLARATION := Token.new("static func")
var TOKEN_FUNCTION_DECLARATION := Token.new("func")
var TOKEN_FUNCTION := Token.new(".")
var TOKEN_FUNCTION_RETURN_TYPE := Token.new("->")
var TOKEN_FUNCTION_END := Token.new("):")
var TOKEN_ARGUMENT_ASIGNMENT := Token.new("=")
var TOKEN_ARGUMENT_TYPE_ASIGNMENT := Token.new(":=")
var TOKEN_ARGUMENT_FUZZER := FuzzerToken.new(GdUnitTools.to_regex("((?!(fuzzer_(seed|iterations)))fuzzer?\\w+)( ?+= ?+| ?+:= ?+| ?+:Fuzzer ?+= ?+|)"))
var TOKEN_ARGUMENT_TYPE := Token.new(":")
var TOKEN_ARGUMENT_SEPARATOR := Token.new(",")
var TOKEN_BRACKET_OPEN := Token.new("(")
var TOKEN_BRACKET_CLOSE := Token.new(")")
var TOKEN_ARRAY_OPEN := Token.new("[")
var TOKEN_ARRAY_CLOSE := Token.new("]")

var OPERATOR_ADD := Operator.new("+")
var OPERATOR_SUB := Operator.new("-")
var OPERATOR_MUL := Operator.new("*")
var OPERATOR_DIV := Operator.new("/")
var OPERATOR_REMAINDER := Operator.new("%")

var TOKENS :Array[Token] = [
	TOKEN_SPACE,
	TOKEN_TABULATOR,
	TOKEN_NEW_LINE,
	TOKEN_COMMENT,
	TOKEN_BRACKET_OPEN,
	TOKEN_BRACKET_CLOSE,
	TOKEN_ARRAY_OPEN,
	TOKEN_ARRAY_CLOSE,
	TOKEN_CLASS_NAME,
	TOKEN_INNER_CLASS,
	TOKEN_EXTENDS,
	TOKEN_ENUM,
	TOKEN_FUNCTION_STATIC_DECLARATION,
	TOKEN_FUNCTION_DECLARATION,
	TOKEN_ARGUMENT_FUZZER,
	TOKEN_ARGUMENT_TYPE_ASIGNMENT,
	TOKEN_ARGUMENT_ASIGNMENT,
	TOKEN_ARGUMENT_TYPE,
	TOKEN_FUNCTION,
	TOKEN_ARGUMENT_SEPARATOR,
	TOKEN_FUNCTION_RETURN_TYPE,
	OPERATOR_ADD,
	OPERATOR_SUB,
	OPERATOR_MUL,
	OPERATOR_DIV,
	OPERATOR_REMAINDER,
]

var _regex_clazz_name := GdUnitTools.to_regex("(class) ([a-zA-Z0-9_]+) (extends[a-zA-Z]+:)|(class) ([a-zA-Z0-9_]+)")
var _regex_strip_comments := GdUnitTools.to_regex("^([^#\"']|'[^']*'|\"[^\"]*\")*\\K#.*")
var _scanned_inner_classes := PackedStringArray()
var _script_constants := {}


static func to_unix_format(input :String) -> String:
	return input.replace("\r\n", "\n")


class Token extends RefCounted:
	var _token: String
	var _consumed: int
	var _is_operator: bool
	var _regex :RegEx


	func _init(p_token: String, p_is_operator := false, p_regex :RegEx = null) -> void:
		_token = p_token
		_is_operator = p_is_operator
		_consumed = p_token.length()
		_regex = p_regex

	func match(input: String, pos: int) -> bool:
		if _regex:
			var result := _regex.search(input, pos)
			if result == null:
				return false
			_consumed = result.get_end() - result.get_start()
			return pos == result.get_start()
		return input.findn(_token, pos) == pos

	func is_operator() -> bool:
		return _is_operator

	func is_inner_class() -> bool:
		return _token == "class"

	func is_variable() -> bool:
		return false

	func is_token(token_name :String) -> bool:
		return _token == token_name

	func is_skippable() -> bool:
		return false

	func _to_string() -> String:
		return "Token{" + _token + "}"


class Operator extends Token:
	func _init(value: String) -> void:
		super(value, true)

	func _to_string() -> String:
		return "OperatorToken{%s}" % [_token]


# A skippable token, is just a placeholder like space or tabs
class SkippableToken extends Token:

	func _init(p_token: String) -> void:
		super(p_token)

	func is_skippable() -> bool:
		return true


# Token to parse Fuzzers
class FuzzerToken extends Token:
	var _name: String


	func _init(regex: RegEx) -> void:
		super("", false, regex)


	func match(input: String, pos: int) -> bool:
		if _regex:
			var result := _regex.search(input, pos)
			if result == null:
				return false
			_name = result.strings[1]
			_consumed = result.get_end() - result.get_start()
			return pos == result.get_start()
		return input.findn(_token, pos) == pos


	func name() -> String:
		return _name


	func type() -> int:
		return GdObjects.TYPE_FUZZER


	func _to_string() -> String:
		return "FuzzerToken{%s: '%s'}" % [_name, _token]


# Token to parse function arguments
class Variable extends Token:
	var _plain_value :String
	var _typed_value :Variant
	var _type :int = TYPE_NIL


	func _init(p_value: String) -> void:
		super(p_value)
		_type = _scan_type(p_value)
		_plain_value = p_value
		_typed_value = _cast_to_type(p_value, _type)


	func _scan_type(p_value: String) -> int:
		if p_value.begins_with("\"") and p_value.ends_with("\""):
			return TYPE_STRING
		var type_ := GdObjects.string_to_type(p_value)
		if type_ != TYPE_NIL:
			return type_
		if p_value.is_valid_int():
			return TYPE_INT
		if p_value.is_valid_float():
			return TYPE_FLOAT
		if p_value.is_valid_hex_number():
			return TYPE_INT
		return TYPE_OBJECT


	func _cast_to_type(p_value :String, p_type: int) -> Variant:
		match p_type:
			TYPE_STRING:
				return p_value#.substr(1, p_value.length() - 2)
			TYPE_INT:
				return p_value.to_int()
			TYPE_FLOAT:
				return p_value.to_float()
		return p_value


	func is_variable() -> bool:
		return true


	func type() -> int:
		return _type


	func value() -> Variant:
		return _typed_value


	func plain_value() -> String:
		return _plain_value


	func _to_string() -> String:
		return "Variable{%s: %s : '%s'}" % [_plain_value, GdObjects.type_as_string(_type), _token]


class TokenInnerClass extends Token:
	var _clazz_name :String
	var _content := PackedStringArray()


	static func _strip_leading_spaces(input :String) -> String:
		var characters := input.to_utf8_buffer()
		while not characters.is_empty():
			if characters[0] != 0x20:
				break
			characters.remove_at(0)
		return characters.get_string_from_utf8()


	static func _consumed_bytes(row :String) -> int:
		return row.replace(" ", "").replace("	", "").length()


	func _init(clazz_name :String) -> void:
		super("class")
		_clazz_name = clazz_name


	func is_class_name(clazz_name :String) -> bool:
		return _clazz_name == clazz_name


	func content() -> PackedStringArray:
		return _content


	func parse(source_rows :PackedStringArray, offset :int) -> void:
		# add class signature
		@warning_ignore("return_value_discarded")
		_content.append(source_rows[offset])
		# parse class content
		for row_index in range(offset+1, source_rows.size()):
			# scan until next non tab
			var source_row := source_rows[row_index]
			var row := TokenInnerClass._strip_leading_spaces(source_row)
			if row.is_empty() or row.begins_with("\t") or row.begins_with("#"):
				# fold all line to left by removing leading tabs and spaces
				if source_row.begins_with("\t"):
					source_row = source_row.trim_prefix("\t")
				# refomat invalid empty lines
				if source_row.dedent().is_empty():
					@warning_ignore("return_value_discarded")
					_content.append("")
				else:
					@warning_ignore("return_value_discarded")
					_content.append(source_row)
				continue
			break
		_consumed += TokenInnerClass._consumed_bytes("".join(_content))


	func _to_string() -> String:
		return "TokenInnerClass{%s}" % [_clazz_name]



func get_token(input :String, current_index :int) -> Token:
	for t in TOKENS:
		if t.match(input, current_index):
			return t
	return TOKEN_NOT_MATCH


func next_token(input: String, current_index: int, ignore_tokens :Array[Token] = []) -> Token:
	var token := TOKEN_NOT_MATCH
	for t :Token in TOKENS.filter(func(t :Token) -> bool: return not ignore_tokens.has(t)):
		if t.match(input, current_index):
			token = t
			break
	if token == OPERATOR_SUB:
		token = tokenize_value(input, current_index, token)
	if token == TOKEN_INNER_CLASS:
		token = tokenize_inner_class(input, current_index, token)
	if token == TOKEN_NOT_MATCH:
		return tokenize_value(input, current_index, token, ignore_tokens.has(TOKEN_FUNCTION))
	return token


func tokenize_value(input: String, current: int, token: Token, ignore_dots := false) -> Token:
	var next := 0
	var current_token := ""
	# test for '--', '+-', '*-', '/-', '%-', or at least '-x'
	var test_for_sign := (token == null or token.is_operator()) and input[current] == "-"
	while current + next < len(input):
		var character := input[current + next] as String
		# if first charater a sign
		# or allowend charset
		# or is a float value
		if (test_for_sign and next==0) \
			or character in ALLOWED_CHARACTERS \
			or (character == "." and (ignore_dots or current_token.is_valid_int())):
			current_token += character
			next += 1
			continue
		break
	if current_token != "":
		return Variable.new(current_token)
	return TOKEN_NOT_MATCH


func extract_clazz_name(value :String) -> String:
	var result := _regex_clazz_name.search(value)
	if result == null:
		push_error("Can't extract class name from '%s'" % value)
		return ""
	if result.get_string(2).is_empty():
		return result.get_string(5)
	else:
		return result.get_string(2)


@warning_ignore("unused_parameter")
func tokenize_inner_class(source_code: String, current: int, token: Token) -> Token:
	var clazz_name := extract_clazz_name(source_code.substr(current, 64))
	return TokenInnerClass.new(clazz_name)


func parse_return_token(input: String) -> Variable:
	var index := input.rfind(TOKEN_FUNCTION_RETURN_TYPE._token)
	if index == -1:
		return TOKEN_NOT_MATCH
	index += TOKEN_FUNCTION_RETURN_TYPE._consumed
	# We scan for the return value exclusive '.' token because it could be referenced to a
	# external or internal class e.g.  'func foo() -> InnerClass.Bar:'
	var token := next_token(input, index, [TOKEN_FUNCTION])
	while !token.is_variable() and token != TOKEN_NOT_MATCH:
		index += token._consumed
		token = next_token(input, index, [TOKEN_FUNCTION])
	return token


func get_function_descriptors(script: GDScript, included_functions: PackedStringArray = []) -> Array[GdFunctionDescriptor]:
	var fds: Array[GdFunctionDescriptor] = []
	for method_descriptor in script.get_script_method_list():
		var func_name: String = method_descriptor["name"]
		if included_functions.is_empty() or func_name in included_functions:
			# exclude type set/geters
			if is_getter_or_setter(func_name):
				continue
			if not fds.any(func(fd: GdFunctionDescriptor) -> bool: return fd.name() == func_name):
				fds.append(GdFunctionDescriptor.extract_from(method_descriptor, false))

	# we need to enrich it by default arguments and line number by parsing the script
	# the engine core functions has no valid methods to get this info
	_prescan_script(script)
	_enrich_function_descriptor(script, fds)
	return fds


func is_getter_or_setter(func_name: String) -> bool:
	return func_name.begins_with("@") and (func_name.ends_with("getter") or func_name.ends_with("setter"))


func _parse_function_arguments(input: String) -> Dictionary:
	var arguments := {}
	var current_index := 0
	var token :Token = null
	var bracket := 0
	var in_function := false
	while current_index < len(input):
		token = next_token(input, current_index)
		# fallback to not end in a endless loop
		if token == TOKEN_NOT_MATCH:
			var error : = """
				Parsing Error: Invalid token at pos %d found.
				Please report this error!
				source_code:
				--------------------------------------------------------------
				%s
				--------------------------------------------------------------
			""".dedent() % [current_index, input]
			push_error(error)
			current_index += 1
			continue
		current_index += token._consumed
		if token.is_skippable():
			continue
		if token == TOKEN_BRACKET_OPEN:
			in_function = true
			bracket += 1
			continue
		if token == TOKEN_BRACKET_CLOSE:
			bracket -= 1
		# if function end?
		if in_function and bracket == 0:
			return arguments
		# is function
		if token == TOKEN_FUNCTION_DECLARATION:
			token = next_token(input, current_index)
			current_index += token._consumed
			continue
		# is fuzzer argument
		if token is FuzzerToken:
			var arg_value := _parse_end_function(input.substr(current_index), true)
			current_index += arg_value.length()
			var arg_name :String = (token as FuzzerToken).name()
			arguments[arg_name] = arg_value.lstrip(" ")
			continue
		# is value argument
		if in_function and token.is_variable():
			var arg_name: String = (token as Variable).plain_value()
			var arg_value: String = GdFunctionArgument.UNDEFINED
			# parse type and default value
			while current_index < len(input):
				token = next_token(input, current_index)
				current_index += token._consumed
				if token.is_skippable():
					continue
				match token:
					TOKEN_ARGUMENT_TYPE:
						token = next_token(input, current_index)
						if token == TOKEN_SPACE:
							current_index += token._consumed
							token = next_token(input, current_index)
					TOKEN_ARGUMENT_TYPE_ASIGNMENT:
						arg_value = _parse_end_function(input.substr(current_index), true)
						current_index += arg_value.length()
					TOKEN_ARGUMENT_ASIGNMENT:
						token = next_token(input, current_index)
						arg_value = _parse_end_function(input.substr(current_index), true)
						current_index += arg_value.length()
					TOKEN_BRACKET_OPEN:
						bracket += 1
						# if value a function?
						if bracket > 1:
							# complete the argument value
							var func_begin := input.substr(current_index-TOKEN_BRACKET_OPEN._consumed)
							var func_body := _parse_end_function(func_begin)
							arg_value += func_body
							# fix parse index to end of value
							current_index += func_body.length() - TOKEN_BRACKET_OPEN._consumed - TOKEN_BRACKET_CLOSE._consumed
					TOKEN_BRACKET_CLOSE:
						bracket -= 1
						# end of function
						if bracket == 0:
							break
					TOKEN_ARGUMENT_SEPARATOR:
						if bracket <= 1:
							break
			arguments[arg_name] = arg_value.lstrip(" ")
	return arguments


func _parse_end_function(input: String, remove_trailing_char := false) -> String:
	# find end of function
	var current_index := 0
	var bracket_count := 0
	var in_array := 0
	var end_of_func := false

	while current_index < len(input) and not end_of_func:
		var character := input[current_index]
		# step over strings
		if character == "'" :
			current_index = input.find("'", current_index+1) + 1
			if current_index == 0:
				push_error("Parsing error on '%s', can't evaluate end of string." % input)
				return ""
			continue
		if character == '"' :
			# test for string blocks
			if input.find('"""', current_index) == current_index:
				current_index = input.find('"""', current_index+3) + 3
			else:
				current_index = input.find('"', current_index+1) + 1
			if current_index == 0:
				push_error("Parsing error on '%s', can't evaluate end of string." % input)
				return ""
			continue

		match character:
			# count if inside an array
			"[": in_array += 1
			"]": in_array -= 1
			# count if inside a function
			"(": bracket_count += 1
			")":
				bracket_count -= 1
				if bracket_count < 0 and in_array <= 0:
					end_of_func = true
			",":
				if bracket_count == 0 and in_array == 0:
					end_of_func = true
		current_index += 1
	if remove_trailing_char:
		# check if the parsed value ends with comma or end of doubled breaked
		# `<value>,` or `<function>())`
		var trailing_char := input[current_index-1]
		if trailing_char == ',' or (bracket_count < 0 and trailing_char == ')'):
			return input.substr(0, current_index-1)
	return input.substr(0, current_index)


@warning_ignore("unsafe_method_access")
func extract_inner_class(source_rows: PackedStringArray, clazz_name :String) -> PackedStringArray:
	for row_index in source_rows.size():
		var input := source_rows[row_index]
		var token := next_token(input, 0)
		if token.is_inner_class():
			if token.is_class_name(clazz_name):
				token.parse(source_rows, row_index)
				return token.content()
	return PackedStringArray()


func extract_func_signature(rows :PackedStringArray, index :int) -> String:
	var signature := ""

	for rowIndex in range(index, rows.size()):
		var row := rows[rowIndex]
		row = _regex_strip_comments.sub(row, "").strip_edges(false)
		if row.is_empty():
			continue
		signature += row + "\n"
		if is_func_end(row):
			return signature.strip_edges()
	push_error("Can't fully extract function signature of '%s'" % rows[index])
	return ""


func get_class_name(script :GDScript) -> String:
	var source_code := GdScriptParser.to_unix_format(script.source_code)
	var source_rows := source_code.split("\n")

	for index :int in min(10, source_rows.size()):
		var input := source_rows[index]
		var token := next_token(input, 0)
		if token == TOKEN_CLASS_NAME:
			var current_index := token._consumed
			token = next_token(input, current_index)
			current_index += token._consumed
			token = tokenize_value(input, current_index, token)
			return (token as Variable).value()
	# if no class_name found extract from file name
	return GdObjects.to_pascal_case(script.resource_path.get_basename().get_file())


func parse_func_name(input :String) -> String:
	var current_index := 0
	var token := next_token(input, current_index)
	current_index += token._consumed
	if token != TOKEN_FUNCTION_STATIC_DECLARATION and token != TOKEN_FUNCTION_DECLARATION:
		return ""
	while not token is Variable:
		token = next_token(input, current_index)
		current_index += token._consumed
	return token._token


## Enriches the function descriptor by line number and argument default values
## - enrich all function descriptors form current script up to all inherited scrips
func _enrich_function_descriptor(script: GDScript, fds: Array[GdFunctionDescriptor]) -> void:
	var enriched_functions := PackedStringArray()
	var script_to_scan := script
	while script_to_scan != null:
		# do not scan the test suite base class itself
		if script_to_scan.resource_path == "res://addons/gdUnit4/src/GdUnitTestSuite.gd":
			break

		var rows := script_to_scan.source_code.split("\n")
		for rowIndex in rows.size():
			var input := rows[rowIndex]
			# step over inner class functions
			if input.begins_with("\t"):
				continue
			# skip comments and empty lines
			if input.begins_with("#") or input.length() == 0:
				continue
			var token := next_token(input, 0)
			if token == TOKEN_FUNCTION_STATIC_DECLARATION or token == TOKEN_FUNCTION_DECLARATION:
				var function_name := parse_func_name(input)
				var fd: GdFunctionDescriptor = fds.filter(func(element: GdFunctionDescriptor) -> bool:
					# is same function name and not already enriched
					return function_name == element.name() and not enriched_functions.has(element.name())
				).pop_front()
				if fd != null:
					# add as enriched function to exclude from next iteration (could be inherited)
					@warning_ignore("return_value_discarded")
					enriched_functions.append(fd.name())
					var func_signature := extract_func_signature(rows, rowIndex)
					var func_arguments := _parse_function_arguments(func_signature)
					# enrich missing default values
					for arg_name: String in func_arguments.keys():
						var func_argument: String = func_arguments[arg_name]
						fd.set_argument_value(arg_name, func_argument)
					fd.enrich_file_info(script_to_scan.resource_path, rowIndex + 1)
					fd._is_coroutine = is_func_coroutine(rows, rowIndex)
					# enrich return class name if not set
					if fd.return_type() == TYPE_OBJECT and fd._return_class in ["", "Resource", "RefCounted"]:
						var var_token := parse_return_token(func_signature)
						if var_token != TOKEN_NOT_MATCH and var_token.type() == TYPE_OBJECT:
							fd._return_class = _patch_inner_class_names(var_token.plain_value(), "")
		# if the script ihnerits we need to scan this also
		script_to_scan = script_to_scan.get_base_script()


func is_func_coroutine(rows :PackedStringArray, index :int) -> bool:
	var is_coroutine := false
	for rowIndex in range(index+1, rows.size()):
		var input := rows[rowIndex]
		is_coroutine = input.contains("await")
		if is_coroutine:
			return true
		var token := next_token(input, 0)
		# scan until next function
		if token == TOKEN_FUNCTION_STATIC_DECLARATION or token == TOKEN_FUNCTION_DECLARATION:
			break
	return is_coroutine


func is_inner_class(clazz_path :PackedStringArray) -> bool:
	return clazz_path.size() > 1


func is_func_end(row :String) -> bool:
	return row.strip_edges(false, true).ends_with(":")


func _patch_inner_class_names(clazz :String, clazz_name :String = "") -> String:
	var inner_clazz_name := clazz.split(".")[0]
	if _scanned_inner_classes.has(inner_clazz_name):
		return inner_clazz_name
		#var base_clazz := clazz_name.split(".")[0]
		#return base_clazz + "." + clazz
	if _script_constants.has(clazz):
		return clazz_name + "." + clazz
	return clazz


func _prescan_script(script: GDScript) -> void:
	_script_constants = script.get_script_constant_map()
	for key :String in _script_constants.keys():
		var value :Variant = _script_constants.get(key)
		if value is GDScript:
			@warning_ignore("return_value_discarded")
			_scanned_inner_classes.append(key)


func parse(clazz_name :String, clazz_path :PackedStringArray) -> GdUnitResult:
	if clazz_path.is_empty():
		return GdUnitResult.error("Invalid script path '%s'" % clazz_path)
	var is_inner_class_ := is_inner_class(clazz_path)
	var script :GDScript = load(clazz_path[0])
	_prescan_script(script)

	if is_inner_class_:
		var inner_class_name := clazz_path[1]
		if _scanned_inner_classes.has(inner_class_name):
			# do load only on inner class source code and enrich the stored script instance
			var source_code := _load_inner_class(script, inner_class_name)
			script = _script_constants.get(inner_class_name)
			script.source_code = source_code
	var function_descriptors := get_function_descriptors(script)
	var gd_class := GdClassDescriptor.new(clazz_name, is_inner_class_, function_descriptors)
	return GdUnitResult.success(gd_class)


func _load_inner_class(script: GDScript, inner_clazz: String) -> String:
	var source_rows := GdScriptParser.to_unix_format(script.source_code).split("\n")
	# extract all inner class names
	var inner_class_code := extract_inner_class(source_rows, inner_clazz)
	return "\n".join(inner_class_code)
class_name GdUnitExpressionRunner
extends RefCounted

const CLASS_TEMPLATE = """
class_name _ExpressionRunner extends '${clazz_path}'

func __run_expression() -> Variant:
	return $expression

"""

var constructor_args_regex := RegEx.create_from_string("new\\((?<args>.*)\\)")


func execute(src_script: GDScript, value: Variant) -> Variant:
	if typeof(value) != TYPE_STRING:
		return value

	var expression: String = value
	var parameter_map := src_script.get_script_constant_map()
	for key: String in parameter_map.keys():
		var parameter_value: Variant = parameter_map[key]
		# check we need to construct from inner class
		# we need to use the original class instance from the script_constant_map otherwise we run into a runtime error
		if expression.begins_with(key + ".new") and parameter_value is GDScript:
			var object: GDScript = parameter_value
			var args := build_constructor_arguments(parameter_map, expression.substr(expression.find("new")))
			if args.is_empty():
				return object.new()
			return object.callv("new", args)

	var script := GDScript.new()
	var resource_path := "res://addons/gdUnit4/src/Fuzzers.gd" if src_script.resource_path.is_empty() else src_script.resource_path
	script.source_code = CLASS_TEMPLATE.dedent()\
		.replace("${clazz_path}", resource_path)\
		.replace("$expression", expression)
	#script.take_over_path(resource_path)
	@warning_ignore("return_value_discarded")
	script.reload(true)
	var runner: Object = script.new()
	if runner.has_method("queue_free"):
		(runner as Node).queue_free()
	@warning_ignore("unsafe_method_access")
	return runner.__run_expression()


func build_constructor_arguments(parameter_map: Dictionary, expression: String) -> Array[Variant]:
	var result := constructor_args_regex.search(expression)
	var extracted_arguments := result.get_string("args").strip_edges()
	if extracted_arguments.is_empty():
		return []
	var arguments :Array = extracted_arguments.split(",")
	return arguments.map(func(argument: String) -> Variant:
		var value := argument.strip_edges()

		# is argument an constant value
		if parameter_map.has(value):
			return parameter_map[value]
		# is typed named value like Vector3.ONE
		for type:int in GdObjects.TYPE_AS_STRING_MAPPINGS:
			var type_as_string:String = GdObjects.TYPE_AS_STRING_MAPPINGS[type]
			if value.begins_with(type_as_string):
				return type_convert(value, type)
		# is value a string
		if value.begins_with("'") or value.begins_with('"'):
			return value.trim_prefix("'").trim_suffix("'").trim_prefix('"').trim_suffix('"')
		# fallback to default value converting
		return str_to_var(value)
	)


func to_fuzzer(src_script: GDScript, expression: String) -> Fuzzer:
	@warning_ignore("unsafe_cast")
	return execute(src_script, expression) as Fuzzer
class_name GdUnitTestParameterSetResolver
extends RefCounted

const CLASS_TEMPLATE = """
class_name _ParameterExtractor extends '${clazz_path}'

func __extract_test_parameters() -> Array:
	return ${test_params}

"""

const EXCLUDE_PROPERTIES_TO_COPY = [
	"script",
	"type",
	"Node",
	"_import_path"]


var _fd: GdFunctionDescriptor
var _test_case_names_cache := PackedStringArray()
var _static_sets_by_index := {}
var _is_static := true

func _init(fd: GdFunctionDescriptor) -> void:
	_fd = fd


func is_parameterized() -> bool:
	return _fd.is_parameterized()


func is_parameter_sets_static() -> bool:
	return _is_static


func is_parameter_set_static(index: int) -> bool:
	return _is_static and _static_sets_by_index.get(index, false)


# validates the given arguments are complete and matches to required input fields of the test function
func validate(input_value_set: Array) -> String:
	var input_arguments := _fd.args()
	# check given parameter set with test case arguments
	var expected_arg_count := input_arguments.size() - 1
	for input_values :Variant in input_value_set:
		var parameter_set_index := input_value_set.find(input_values)
		if input_values is Array:
			var arr_values: Array = input_values
			var current_arg_count := arr_values.size()
			if current_arg_count != expected_arg_count:
				return "\n	The parameter set at index [%d] does not match the expected input parameters!\n	The test case requires [%d] input parameters, but the set contains [%d]" % [parameter_set_index, expected_arg_count, current_arg_count]
			var error := GdUnitTestParameterSetResolver.validate_parameter_types(input_arguments, arr_values, parameter_set_index)
			if not error.is_empty():
				return error
		else:
			return "\n	The parameter set at index [%d] does not match the expected input parameters!\n	Expecting an array of input values." % parameter_set_index
	return ""


static func validate_parameter_types(input_arguments: Array, input_values: Array, parameter_set_index: int) -> String:
	for i in input_arguments.size():
		var input_param: GdFunctionArgument = input_arguments[i]
		# only check the test input arguments
		if input_param.is_parameter_set():
			continue
		var input_param_type := input_param.type()
		var input_value :Variant = input_values[i]
		var input_value_type := typeof(input_value)
		# input parameter is not typed or is Variant we skip the type test
		if input_param_type == TYPE_NIL or input_param_type == GdObjects.TYPE_VARIANT:
			continue
		# is input type enum allow int values
		if input_param_type == GdObjects.TYPE_VARIANT and input_value_type == TYPE_INT:
			continue
		# allow only equal types and object == null
		if input_param_type == TYPE_OBJECT and input_value_type == TYPE_NIL:
			continue
		if input_param_type != input_value_type:
			return "\n	The parameter set at index [%d] does not match the expected input parameters!\n	The value '%s' does not match the required input parameter <%s>." % [parameter_set_index, input_value, input_param]
	return ""


func build_test_case_names(test_case: _TestCase) -> PackedStringArray:
	if not is_parameterized():
		return []
	# if test names already resolved?
	if not _test_case_names_cache.is_empty():
		return _test_case_names_cache

	var fa := GdFunctionArgument.get_parameter_set(_fd.args())
	var parameter_sets := fa.parameter_sets()
	# if no parameter set detected we need to resolve it by using reflection
	if parameter_sets.size() == 0:
		_test_case_names_cache = _extract_test_names_by_reflection(test_case)
		_is_static = false
	else:
		var property_names := _extract_property_names(test_case.get_parent())
		for parameter_set_index in parameter_sets.size():
			var parameter_set := parameter_sets[parameter_set_index]
			_static_sets_by_index[parameter_set_index] = _is_static_parameter_set(parameter_set, property_names)
			@warning_ignore("return_value_discarded")
			_test_case_names_cache.append(GdUnitTestParameterSetResolver._build_test_case_name(test_case, parameter_set, parameter_set_index))
			parameter_set_index += 1
	return _test_case_names_cache


func _extract_property_names(node :Node) -> PackedStringArray:
	return node.get_property_list()\
		.map(func(property :Dictionary) -> String: return property["name"])\
		.filter(func(property :String) -> bool: return !EXCLUDE_PROPERTIES_TO_COPY.has(property))


# tests if the test property set contains an property reference by name, if not the parameter set holds only static values
func _is_static_parameter_set(parameters :String, property_names :PackedStringArray) -> bool:
	for property_name in property_names:
		if parameters.contains(property_name):
			_is_static = false
			return false
	return true


func _extract_test_names_by_reflection(test_case: _TestCase) -> PackedStringArray:
	var parameter_sets := load_parameter_sets(test_case)
	var test_case_names: PackedStringArray = []
	for index in parameter_sets.size():
		@warning_ignore("return_value_discarded")
		test_case_names.append(GdUnitTestParameterSetResolver._build_test_case_name(test_case, str(parameter_sets[index]), index))
	return test_case_names


static func _build_test_case_name(test_case: _TestCase, test_parameter: String, parameter_set_index: int) -> String:
	if not test_parameter.begins_with("["):
		test_parameter = "[" + test_parameter
	return "%s:%d %s" % [test_case.get_name(), parameter_set_index, test_parameter.replace("\t", "").replace('"', "'").replace("&'", "'")]


# extracts the arguments from the given test case, using kind of reflection solution
# to restore the parameters from a string representation to real instance type
func load_parameter_sets(test_case: _TestCase, do_validate := false) -> Array:
	var source_script :Script = test_case.get_parent().get_script()
	var parameter_arg := GdFunctionArgument.get_parameter_set(_fd.args())
	var source_code := CLASS_TEMPLATE \
		.replace("${clazz_path}", source_script.resource_path) \
		.replace("${test_params}", parameter_arg.value_as_string())
	var script := GDScript.new()
	script.source_code = source_code
	# enable this lines only for debuging
	#script.resource_path = GdUnitFileAccess.create_temp_dir("parameter_extract") + "/%s__.gd" % test_case.get_name()
	#DirAccess.remove_absolute(script.resource_path)
	#ResourceSaver.save(script, script.resource_path)
	var result := script.reload()
	if result != OK:
		push_error("Extracting test parameters failed! Script loading error: %s" % result)
		return []
	var instance :Object = script.new()
	GdUnitTestParameterSetResolver.copy_properties(test_case.get_parent(), instance)
	(instance as Node).queue_free()
	var parameter_sets: Array = instance.call("__extract_test_parameters")
	if not do_validate:
		return parameter_sets
	# validate the parameter set
	var error := validate(parameter_sets)
	if not error.is_empty():
		test_case.skip(true, error)
		test_case._interupted = true
	if parameter_sets.size() != _test_case_names_cache.size():
		push_error("Internal Error: The resolved test_case names has invalid size!")
		error = """
		%s:
			The resolved test_case names has invalid size!
			%s
		""".dedent().trim_prefix("\n") % [
			GdAssertMessages._error("Internal Error"),
			GdAssertMessages._error("Please report this issue as a bug!")]
		GdUnitThreadManager.get_current_context()\
			.get_execution_context()\
			.add_report(GdUnitReport.new().create(GdUnitReport.INTERUPTED, test_case.line_number(), error))
		test_case.skip(true, error)
		test_case._interupted = true
	@warning_ignore("return_value_discarded")
	fixure_typed_parameters(parameter_sets, _fd.args())
	return parameter_sets


func fixure_typed_parameters(parameter_sets: Array, arg_descriptors: Array[GdFunctionArgument]) -> Array:
	for parameter_set_index in parameter_sets.size():
		var parameter_set: Array = parameter_sets[parameter_set_index]
		# run over all function arguments
		for parameter_index in parameter_set.size():
			var parameter :Variant = parameter_set[parameter_index]
			var arg_descriptor: GdFunctionArgument = arg_descriptors[parameter_index]
			if parameter is Array:
				var as_array: Array = parameter
				# we need to convert the untyped array to the expected typed version
				if arg_descriptor.is_typed_array():
					parameter_set[parameter_index] = Array(as_array, arg_descriptor.type_hint(), "", null)
	return parameter_sets



static func copy_properties(source: Object, dest: Object) -> void:
	for property in source.get_property_list():
		var property_name :String = property["name"]
		var property_value :Variant = source.get(property_name)
		if EXCLUDE_PROPERTIES_TO_COPY.has(property_name):
			continue
		#if dest.get(property_name) == null:
		#	prints("|%s|" % property_name, source.get(property_name))

		# check for invalid name property
		if property_name == "name" and property_value == "":
			dest.set(property_name, "<empty>");
			continue
		dest.set(property_name, property_value)
class_name GdUnitReport
extends Resource

# report type
enum {
	SUCCESS,
	WARN,
	FAILURE,
	ORPHAN,
	TERMINATED,
	INTERUPTED,
	ABORT,
	SKIPPED,
}

var _type :int
var _line_number :int
var _message :String


func create(p_type :int, p_line_number :int, p_message :String) -> GdUnitReport:
	_type = p_type
	_line_number = p_line_number
	_message = p_message
	return self


func type() -> int:
	return _type


func line_number() -> int:
	return _line_number


func message() -> String:
	return _message


func is_skipped() -> bool:
	return _type == SKIPPED


func is_warning() -> bool:
	return _type == WARN


func is_failure() -> bool:
	return _type == FAILURE


func is_error() -> bool:
	return _type == TERMINATED or _type == INTERUPTED or _type == ABORT


func _to_string() -> String:
	if _line_number == -1:
		return "[color=green]line [/color][color=aqua]<n/a>:[/color] %s" % [_message]
	return "[color=green]line [/color][color=aqua]%d:[/color] %s" % [_line_number, _message]


func serialize() -> Dictionary:
	return {
		"type"        :_type,
		"line_number" :_line_number,
		"message"     :_message
	}


func deserialize(serialized :Dictionary) -> GdUnitReport:
	_type        = serialized["type"]
	_line_number = serialized["line_number"]
	_message     = serialized["message"]
	return self
class_name GdUnitTestSuiteDefaultTemplate
extends RefCounted


const DEFAULT_TEMP_TS_GD ="""
	# GdUnit generated TestSuite
	class_name ${suite_class_name}
	extends GdUnitTestSuite
	@warning_ignore('unused_parameter')
	@warning_ignore('return_value_discarded')

	# TestSuite generated from
	const __source = '${source_resource_path}'
"""


const DEFAULT_TEMP_TS_CS = """
	// GdUnit generated TestSuite

	using Godot;
	using GdUnit4;

	namespace ${name_space}
	{
		using static Assertions;
		using static Utils;

		[TestSuite]
		public class ${suite_class_name}
		{
			// TestSuite generated from
			private const string sourceClazzPath = "${source_resource_path}";

		}
	}
"""
class_name GdUnitTestSuiteTemplate
extends RefCounted

const TEMPLATE_ID_GD = 1000
const TEMPLATE_ID_CS = 2000

const SUPPORTED_TAGS_GD = """
	GdScript Tags are replaced when the test-suite is created.

	# The class name of the test-suite, formed from the source script.
	${suite_class_name}
	# is used to build the test suite class name
		class_name ${suite_class_name}
		extends GdUnitTestSuite


	# The class name in pascal case, formed from the source script.
	${source_class}
		# can be used to create the class e.g. for source 'MyClass'
		var my_test_class := ${source_class}.new()
		# will be result in
		var my_test_class := MyClass.new()

	# The class as variable name in snake case, formed from the source script.
	${source_var}
		# Can be used to build the variable name e.g. for source 'MyClass'
		var ${source_var} := ${source_class}.new()
		# will be result in
		var my_class := MyClass.new()

	# The full resource path from which the file was created.
	${source_resource_path}
		# Can be used to load the script in your test
		var my_script := load(${source_resource_path})
		# will be result in
		var my_script := load("res://folder/my_class.gd")
"""

const SUPPORTED_TAGS_CS = """
	C# Tags are replaced when the test-suite is created.

	// The namespace name of the test-suite
	${name_space}
		namespace ${name_space}

	// The class name of the test-suite, formed from the source class.
	${suite_class_name}
		// is used to build the test suite class name
		[TestSuite]
		public class ${suite_class_name}

	// The class name formed from the source class.
	${source_class}
		// can be used to create the class e.g. for source 'MyClass'
		private string myTestClass = new ${source_class}();
		// will be result in
		private string myTestClass = new MyClass();

	// The class as variable name in camelCase, formed from the source class.
	${source_var}
		// Can be used to build the variable name e.g. for source 'MyClass'
		private object ${source_var} = new ${source_class}();
		// will be result in
		private object myClass = new MyClass();

	// The full resource path from which the file was created.
	${source_resource_path}
		// Can be used to load the script in your test
		private object myScript = GD.Load(${source_resource_path});
		// will be result in
		private object myScript = GD.Load("res://folder/MyClass.cs");
"""

const TAG_TEST_SUITE_CLASS = "${suite_class_name}"
const TAG_SOURCE_CLASS_NAME = "${source_class}"
const TAG_SOURCE_CLASS_VARNAME = "${source_var}"
const TAG_SOURCE_RESOURCE_PATH = "${source_resource_path}"


static func default_GD_template() -> String:
	return GdUnitTestSuiteDefaultTemplate.DEFAULT_TEMP_TS_GD.dedent().trim_prefix("\n")


static func default_CS_template() -> String:
	return GdUnitTestSuiteDefaultTemplate.DEFAULT_TEMP_TS_CS.dedent().trim_prefix("\n")


static func build_template(source_path: String) -> String:
	var clazz_name :String = GdObjects.to_pascal_case(GdObjects.extract_class_name(source_path).value_as_string())
	var template: String = GdUnitSettings.get_setting(GdUnitSettings.TEMPLATE_TS_GD, default_GD_template())

	return template\
		.replace(TAG_TEST_SUITE_CLASS, clazz_name+"Test")\
		.replace(TAG_SOURCE_RESOURCE_PATH, source_path)\
		.replace(TAG_SOURCE_CLASS_NAME, clazz_name)\
		.replace(TAG_SOURCE_CLASS_VARNAME, GdObjects.to_snake_case(clazz_name))


static func default_template(template_id :int) -> String:
	if template_id != TEMPLATE_ID_GD and template_id != TEMPLATE_ID_CS:
		push_error("Invalid template '%d' id! Cant load testsuite template" % template_id)
		return ""
	if template_id == TEMPLATE_ID_GD:
		return default_GD_template()
	return default_CS_template()


static func load_template(template_id :int) -> String:
	if template_id != TEMPLATE_ID_GD and template_id != TEMPLATE_ID_CS:
		push_error("Invalid template '%d' id! Cant load testsuite template" % template_id)
		return ""
	if template_id == TEMPLATE_ID_GD:
		return GdUnitSettings.get_setting(GdUnitSettings.TEMPLATE_TS_GD, default_GD_template())
	return GdUnitSettings.get_setting(GdUnitSettings.TEMPLATE_TS_CS, default_CS_template())


static func save_template(template_id :int, template :String) -> void:
	if template_id != TEMPLATE_ID_GD and template_id != TEMPLATE_ID_CS:
		push_error("Invalid template '%d' id! Cant load testsuite template" % template_id)
		return
	if template_id == TEMPLATE_ID_GD:
		GdUnitSettings.save_property(GdUnitSettings.TEMPLATE_TS_GD, template.dedent().trim_prefix("\n"))
	elif template_id == TEMPLATE_ID_CS:
		GdUnitSettings.save_property(GdUnitSettings.TEMPLATE_TS_CS, template.dedent().trim_prefix("\n"))


static func reset_to_default(template_id :int) -> void:
	if template_id != TEMPLATE_ID_GD and template_id != TEMPLATE_ID_CS:
		push_error("Invalid template '%d' id! Cant load testsuite template" % template_id)
		return
	if template_id == TEMPLATE_ID_GD:
		GdUnitSettings.save_property(GdUnitSettings.TEMPLATE_TS_GD, default_GD_template())
	else:
		GdUnitSettings.save_property(GdUnitSettings.TEMPLATE_TS_CS, default_CS_template())


static func load_tags(template_id :int) -> String:
	if template_id != TEMPLATE_ID_GD and template_id != TEMPLATE_ID_CS:
		push_error("Invalid template '%d' id! Cant load testsuite template" % template_id)
		return "Error checked loading tags"
	if template_id == TEMPLATE_ID_GD:
		return SUPPORTED_TAGS_GD
	else:
		return SUPPORTED_TAGS_CS
class_name GdUnitThreadContext
extends RefCounted

var _thread :Thread
var _thread_name :String
var _thread_id :int
var _signal_collector :GdUnitSignalCollector
var _execution_context :GdUnitExecutionContext
var _asserts := []


func _init(thread :Thread = null) -> void:
	if thread != null:
		_thread = thread
		_thread_name = thread.get_meta("name")
		_thread_id = thread.get_id() as int
	else:
		_thread_name = "main"
		_thread_id = OS.get_main_thread_id()
	_signal_collector = GdUnitSignalCollector.new()


func dispose() -> void:
	clear_assert()
	if is_instance_valid(_signal_collector):
		_signal_collector.clear()
	_signal_collector = null
	_execution_context = null
	_thread = null


func clear_assert() -> void:
	_asserts.clear()


func set_assert(value :GdUnitAssert) -> void:
	if value != null:
		_asserts.append(value)


func get_assert() -> GdUnitAssert:
	return null if _asserts.is_empty() else _asserts[-1]


func set_execution_context(context :GdUnitExecutionContext) -> void:
	_execution_context = context


func get_execution_context() -> GdUnitExecutionContext:
	return _execution_context


func get_execution_context_id() -> int:
	return _execution_context.get_instance_id()


func get_signal_collector() -> GdUnitSignalCollector:
	return _signal_collector


func thread_id() -> int:
	return _thread_id


func _to_string() -> String:
	return "ThreadContext <%s>: %s " % [_thread_name, _thread_id]
## A manager to run new thread and crate a ThreadContext shared over the actual test run
class_name GdUnitThreadManager
extends Object

## { <thread_id> = <GdUnitThreadContext> }
var _thread_context_by_id := {}
## holds the current thread id
var _current_thread_id :int = -1

func _init() -> void:
	# add initail the main thread
	_current_thread_id = OS.get_thread_caller_id()
	_thread_context_by_id[OS.get_main_thread_id()] = GdUnitThreadContext.new()


static func instance() -> GdUnitThreadManager:
	return GdUnitSingleton.instance("GdUnitThreadManager", func() -> GdUnitThreadManager: return GdUnitThreadManager.new())


## Runs a new thread by given name and Callable.[br]
## A new GdUnitThreadContext is created, which is used for the actual test execution.[br]
## We need this custom implementation while this bug is not solved
## Godot issue https://github.com/godotengine/godot/issues/79637
static func run(name :String, cb :Callable) -> Variant:
	return await instance()._run(name, cb)


## Returns the current valid thread context
static func get_current_context() -> GdUnitThreadContext:
	return instance()._get_current_context()


func _run(name :String, cb :Callable) -> Variant:
	# we do this hack because of `OS.get_thread_caller_id()` not returns the current id
	# when await process_frame is called inside the fread
	var save_current_thread_id := _current_thread_id
	var thread := Thread.new()
	thread.set_meta("name", name)
	@warning_ignore("return_value_discarded")
	thread.start(cb)
	_current_thread_id = thread.get_id() as int
	_register_thread(thread, _current_thread_id)
	var result :Variant = await thread.wait_to_finish()
	_unregister_thread(_current_thread_id)
	# restore original thread id
	_current_thread_id = save_current_thread_id
	return result


func _register_thread(thread :Thread, thread_id :int) -> void:
	var context := GdUnitThreadContext.new(thread)
	_thread_context_by_id[thread_id] = context


func _unregister_thread(thread_id :int) -> void:
	var context: GdUnitThreadContext = _thread_context_by_id.get(thread_id)
	if context:
		@warning_ignore("return_value_discarded")
		_thread_context_by_id.erase(thread_id)
		context.dispose()


func _get_current_context() -> GdUnitThreadContext:
	return _thread_context_by_id.get(_current_thread_id)
## The helper class to allow to double Callable
## Is just a wrapper to the original callable with the same function signature.
##
## Due to interface conflicts between 'Callable' and 'Object',
## it is not possible to stub the 'call' and 'call_deferred' methods.
##
## The Callable interface and the Object class have overlapping method signatures,
## which causes conflicts when attempting to stub these methods.
## As a result, you cannot create stubs for 'call' and 'call_deferred' methods.

class_name CallableDoubler


const doubler_script :Script =  preload("res://addons/gdUnit4/src/doubler/CallableDoubler.gd")

var _cb: Callable


func _init(cb: Callable) -> void:
	assert(cb!=null, "Invalid argument <cb> must not be null")
	_cb = cb

## --- helpers -----------------------------------------------------------------------------------------------------------------------------
static func map_func_name(method_info: Dictionary) -> String:
	return method_info["name"]


## We do not want to double all functions based on Object for this class
## Is used on SpyBuilder to excluding functions to be doubled for Callable
static func excluded_functions() -> PackedStringArray:
	return ClassDB.class_get_method_list("Object")\
		.map(CallableDoubler.map_func_name)\
		.filter(func (name: String) -> bool:
			return !CallableDoubler.callable_functions().has(name))


static func non_callable_functions(name: String) -> bool:
	return ![
		# we allow "_init", is need to construct it,
		"excluded_functions",
		"non_callable_functions",
		"callable_functions",
		"map_func_name"
		].has(name)


## Returns the list of supported Callable functions
static func callable_functions() -> PackedStringArray:
	var supported_functions :Array = doubler_script.get_script_method_list()\
		.map(CallableDoubler.map_func_name)\
		.filter(CallableDoubler.non_callable_functions)
	# We manually add these functions that we cannot/may not overwrite in this class
	supported_functions.append_array(["call_deferred", "callv"])
	return supported_functions


## -----------------------------------------------------------------------------------------------------------------------------------------
## Callable functions stubing
## -----------------------------------------------------------------------------------------------------------------------------------------

@warning_ignore("untyped_declaration")
func bind(arg0=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg1=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg2=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg3=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg4=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg5=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg6=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg7=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg8=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg9=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE) -> Callable:
	# save
	var bind_values: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE)
	_cb = _cb.bindv(bind_values)
	return _cb


func bindv(caller_args: Array) -> Callable:
	_cb = _cb.bindv(caller_args)
	return _cb


@warning_ignore("untyped_declaration", "native_method_override", "unused_parameter")
func call(arg0=null,
	arg1=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg2=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg3=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg4=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg5=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg6=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg7=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg8=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg9=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE) -> Variant:

	# This is a placeholder function signanture without any functionallity!
	# It is used by the function doubler to double function signature of Callable:call()
	# The doubled function calls direct _cb.callv(<arguments>) see GdUnitSpyFunctionDoubler:TEMPLATE_CALLABLE_CALL template
	assert(false)
	return null


# Is not supported, see class description
#func call_deferred(a) -> void:
#	pass


# Is not supported, see class description
#func callv(a) -> void:
#	pass



func get_bound_arguments() -> Array:
	return _cb.get_bound_arguments()


func get_bound_arguments_count() -> int:
	return _cb.get_bound_arguments_count()


func get_method() -> StringName:
	return _cb.get_method()


func get_object() -> Object:
	return _cb.get_object()


func get_object_id() -> int:
	return _cb.get_object_id()


func hash() -> int:
	return _cb.hash()


func is_custom() -> bool:
	return _cb.is_custom()


func is_null() -> bool:
	return _cb.is_null()


func is_standard() -> bool:
	return _cb.is_standard()


func is_valid() -> bool:
	return _cb.is_valid()


@warning_ignore("untyped_declaration")
func rpc(arg0=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg1=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg2=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg3=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg4=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg5=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg6=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg7=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg8=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg9=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE) -> void:

	var args: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE)
	match args.size():
		0: _cb.rpc(0)
		1: _cb.rpc(args[0])
		2: _cb.rpc(args[0], args[1])
		3: _cb.rpc(args[0], args[1], args[2])
		4: _cb.rpc(args[0], args[1], args[2], args[3])
		5: _cb.rpc(args[0], args[1], args[2], args[3], args[4])
		6: _cb.rpc(args[0], args[1], args[2], args[3], args[4], args[5])
		7: _cb.rpc(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
		8: _cb.rpc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])
		9: _cb.rpc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])
		10: _cb.rpc(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9])


@warning_ignore("untyped_declaration")
func rpc_id(peer_id: int,
	arg0=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg1=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg2=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg3=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg4=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg5=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg6=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg7=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg8=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE,
	arg9=GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE) -> void:

	var args: Array = GdArrayTools.filter_value([arg0,arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9], GdObjects.TYPE_VARARG_PLACEHOLDER_VALUE)
	match args.size():
		0: _cb.rpc_id(peer_id)
		1: _cb.rpc_id(peer_id, args[0])
		2: _cb.rpc_id(peer_id, args[0], args[1])
		3: _cb.rpc_id(peer_id, args[0], args[1], args[2])
		4: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3])
		5: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4])
		6: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4], args[5])
		7: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4], args[5], args[6])
		8: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])
		9: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])
		10: _cb.rpc_id(peer_id, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9])


func unbind(argcount: int) -> Callable:
	_cb = _cb.unbind(argcount)
	return _cb
# This class defines a value extractor by given function name and args
class_name GdUnitFuncValueExtractor
extends GdUnitValueExtractor

var _func_names :PackedStringArray
var _args :Array

func _init(func_name :String, p_args :Array) -> void:
	_func_names = func_name.split(".")
	_args = p_args


func func_names() -> PackedStringArray:
	return _func_names


func args() -> Array:
	return _args


# Extracts a value by given `func_name` and `args`,
# Allows to use a chained list of functions setarated ba a dot.
#  e.g. "func_a.func_b.name"
#  do calls instance.func_a().func_b().name() and returns finally the name
# If a function returns an array, all elements will by collected in a array
#  e.g. "get_children.get_name" checked a node
#  do calls node.get_children() for all childs get_name() and returns all names in an array
#
# if the value not a Object or not accesible be `func_name` the value is converted to `"n.a."`
# expecing null values
func extract_value(value: Variant) -> Variant:
	if value == null:
		return null
	for func_name in func_names():
		if GdArrayTools.is_array_type(value):
			var values := Array()
			@warning_ignore("unsafe_cast")
			for element: Variant in (value as Array):
				values.append(_call_func(element, func_name))
			value = values
		else:
			value = _call_func(value, func_name)
		var type := typeof(value)
		if type == TYPE_STRING_NAME:
			return str(value)
		if type == TYPE_STRING and value == "n.a.":
			return value
	return value


func _call_func(value :Variant, func_name :String) -> Variant:
	# for array types we need to call explicit by function name, using funcref is only supported for Objects
	# TODO extend to all array functions
	if GdArrayTools.is_array_type(value) and func_name == "empty":
		@warning_ignore("unsafe_cast")
		return (value as Array).is_empty()

	if is_instance_valid(value):
		# extract from function
		var obj_value: Object = value
		if obj_value.has_method(func_name):
			var extract := Callable(obj_value, func_name)
			if extract.is_valid():
				return obj_value.call(func_name) if args().is_empty() else obj_value.callv(func_name, args())
		else:
			# if no function exists than try to extract form parmeters
			var parameter: Variant = obj_value.get(func_name)
			if parameter != null:
				return parameter
	# nothing found than return 'n.a.'
	if GdUnitSettings.is_verbose_assert_warnings():
		push_warning("Extracting value from element '%s' by func '%s' failed! Converting to \"n.a.\"" % [value, func_name])
	return "n.a."
class_name FloatFuzzer
extends Fuzzer

var _from: float = 0
var _to: float = 0

func _init(from: float, to: float) -> void:
	assert(from <= to, "Invalid range!")
	_from = from
	_to = to

func next_value() -> float:
	return randf_range(_from, _to)
# Base interface for fuzz testing
# https://en.wikipedia.org/wiki/Fuzzing
class_name Fuzzer
extends RefCounted
# To run a test with a specific fuzzer you have to add defailt argument checked your test case
# all arguments are optional []
# syntax:
# 	func test_foo([fuzzer = <Fuzzer>], [fuzzer_iterations=<amount>], [fuzzer_seed=<number>])
# example:
#   # runs the test 'test_foo' 10 times with a random int value generated by the IntFuzzer
# 	func test_foo(fuzzer = Fuzzers.randomInt(), fuzzer_iterations=10)
#
#   # runs the test 'test_foo2' 1000 times as default with a random seed='101010101'
# 	func test_foo2(fuzzer = Fuzzers.randomInt(), fuzzer_seed=101010101)

const ITERATION_DEFAULT_COUNT = 1000
const ARGUMENT_FUZZER_INSTANCE := "fuzzer"
const ARGUMENT_ITERATIONS := "fuzzer_iterations"
const ARGUMENT_SEED := "fuzzer_seed"

var _iteration_index :int = 0
var _iteration_limit :int = ITERATION_DEFAULT_COUNT


# generates the next fuzz value
# needs to be implement
func next_value() -> Variant:
	push_error("Invalid vall. Fuzzer not implemented 'next_value()'")
	return null


# returns the current iteration index
func iteration_index() -> int:
	return _iteration_index


# returns the amount of iterations where the fuzzer will be run
func iteration_limit() -> int:
	return _iteration_limit
class_name IntFuzzer
extends Fuzzer

enum {
	NORMAL,
	EVEN,
	ODD
}

var _from :int = 0
var _to : int = 0
var _mode : int = NORMAL


func _init(from: int, to: int, mode :int = NORMAL) -> void:
	assert(from <= to, "Invalid range!")
	_from = from
	_to = to
	_mode = mode


func next_value() -> int:
	var value := randi_range(_from, _to)
	match _mode:
		NORMAL:
			return value
		EVEN:
			return int((value / 2.0) * 2)
		ODD:
			return int((value / 2.0) * 2 + 1)
		_:
			return value
class_name StringFuzzer
extends Fuzzer


const DEFAULT_CHARSET = "a-zA-Z0-9+-_"

var _min_length :int
var _max_length :int
var _charset :PackedByteArray


func _init(min_length :int, max_length :int, pattern :String = DEFAULT_CHARSET) -> void:
	assert(min_length>0 and min_length < max_length)
	assert(not null or not pattern.is_empty())
	_min_length = min_length
	_max_length = max_length
	_charset = StringFuzzer.extract_charset(pattern)


static func extract_charset(pattern :String) -> PackedByteArray:
	var reg := RegEx.new()
	if reg.compile(pattern) != OK:
		push_error("Invalid pattern to generate Strings! Use e.g  'a-zA-Z0-9+-_'")
		return PackedByteArray()

	var charset := Array()
	var char_before := -1
	var index := 0
	while index < pattern.length():
		var char_current := pattern.unicode_at(index)
		# - range token at first or last pos?
		if char_current == 45 and (index == 0 or index == pattern.length()-1):
			charset.append(char_current)
			index += 1
			continue
		index += 1
		# range starts
		if char_current == 45 and char_before != -1:
			var char_next := pattern.unicode_at(index)
			var characters := build_chars(char_before, char_next)
			for character in characters:
				charset.append(character)
			char_before = -1
			index += 1
			continue
		char_before = char_current
		charset.append(char_current)
	return PackedByteArray(charset)


static func build_chars(from :int, to :int) -> Array[int]:
	var characters :Array[int] = []
	for character in range(from+1, to+1):
		characters.append(character)
	return characters


func next_value() -> String:
	var value := PackedByteArray()
	var max_char := len(_charset)
	var length :int = max(_min_length, randi() % _max_length)
	for i in length:
		@warning_ignore("return_value_discarded")
		value.append(_charset[randi() % max_char])
	return value.get_string_from_utf8()
class_name Vector2Fuzzer
extends Fuzzer


var _from :Vector2
var _to : Vector2


func _init(from: Vector2, to: Vector2) -> void:
	assert(from <= to, "Invalid range!")
	_from = from
	_to = to


func next_value() -> Vector2:
	var x := randf_range(_from.x, _to.x)
	var y := randf_range(_from.y, _to.y)
	return Vector2(x, y)
class_name Vector3Fuzzer
extends Fuzzer


var _from :Vector3
var _to : Vector3


func _init(from: Vector3, to: Vector3) -> void:
	assert(from <= to, "Invalid range!")
	_from = from
	_to = to


func next_value() -> Vector3:
	var x := randf_range(_from.x, _to.x)
	var y := randf_range(_from.y, _to.y)
	var z := randf_range(_from.z, _to.z)
	return Vector3(x, y, z)
class_name AnyArgumentMatcher
extends GdUnitArgumentMatcher


@warning_ignore("unused_parameter")
func is_match(value :Variant) -> bool:
	return true


func _to_string() -> String:
	return "any()"
class_name AnyBuildInTypeArgumentMatcher
extends GdUnitArgumentMatcher

var _type : PackedInt32Array = []


func _init(type :PackedInt32Array) -> void:
	_type = type


func is_match(value :Variant) -> bool:
	return _type.has(typeof(value))


func _to_string() -> String:
	match _type[0]:
		TYPE_BOOL: return "any_bool()"
		TYPE_STRING, TYPE_STRING_NAME: return "any_string()"
		TYPE_INT: return "any_int()"
		TYPE_FLOAT: return "any_float()"
		TYPE_COLOR: return "any_color()"
		TYPE_VECTOR2: return "any_vector2()" if _type.size() == 1 else "any_vector()"
		TYPE_VECTOR2I: return "any_vector2i()"
		TYPE_VECTOR3: return "any_vector3()"
		TYPE_VECTOR3I: return "any_vector3i()"
		TYPE_VECTOR4: return "any_vector4()"
		TYPE_VECTOR4I: return "any_vector4i()"
		TYPE_RECT2: return "any_rect2()"
		TYPE_RECT2I: return "any_rect2i()"
		TYPE_PLANE: return "any_plane()"
		TYPE_QUATERNION: return "any_quat()"
		TYPE_AABB: return "any_aabb()"
		TYPE_BASIS: return "any_basis()"
		TYPE_TRANSFORM2D: return "any_transform_2d()"
		TYPE_TRANSFORM3D: return "any_transform_3d()"
		TYPE_NODE_PATH: return "any_node_path()"
		TYPE_RID: return "any_rid()"
		TYPE_OBJECT: return "any_object()"
		TYPE_DICTIONARY: return "any_dictionary()"
		TYPE_ARRAY: return "any_array()"
		TYPE_PACKED_BYTE_ARRAY: return "any_packed_byte_array()"
		TYPE_PACKED_INT32_ARRAY: return "any_packed_int32_array()"
		TYPE_PACKED_INT64_ARRAY: return "any_packed_int64_array()"
		TYPE_PACKED_FLOAT32_ARRAY: return "any_packed_float32_array()"
		TYPE_PACKED_FLOAT64_ARRAY: return "any_packed_float64_array()"
		TYPE_PACKED_STRING_ARRAY: return "any_packed_string_array()"
		TYPE_PACKED_VECTOR2_ARRAY: return "any_packed_vector2_array()"
		TYPE_PACKED_VECTOR3_ARRAY: return "any_packed_vector3_array()"
		TYPE_PACKED_COLOR_ARRAY: return "any_packed_color_array()"
		_: return "any()"
class_name AnyClazzArgumentMatcher
extends GdUnitArgumentMatcher

var _clazz :Object


func _init(clazz :Object) -> void:
	_clazz = clazz


func is_match(value :Variant) -> bool:
	if typeof(value) != TYPE_OBJECT:
		return false
	if is_instance_valid(value) and GdObjects.is_script(_clazz):
		@warning_ignore("unsafe_cast")
		return (value as Object).get_script() == _clazz
	return is_instance_of(value, _clazz)


func _to_string() -> String:
	if (_clazz as Object).is_class("GDScriptNativeClass"):
		@warning_ignore("unsafe_method_access")
		var instance :Object = _clazz.new()
		var clazz_name := instance.get_class()
		if not instance is RefCounted:
			instance.free()
		return "any_class(<"+clazz_name+">)";
	if _clazz is GDScript:
		var result := GdObjects.extract_class_name(_clazz)
		if result.is_success():
			return "any_class(<"+ result.value() + ">)"
	return "any_class()"
class_name ChainedArgumentMatcher
extends GdUnitArgumentMatcher

var _matchers :Array


func _init(matchers :Array) -> void:
	_matchers = matchers


func is_match(arguments :Variant) -> bool:
	var arg_array: Array = arguments
	if arg_array == null or arg_array.size() != _matchers.size():
		return false

	for index in arg_array.size():
		var arg: Variant = arg_array[index]
		var matcher: GdUnitArgumentMatcher = _matchers[index]

		if not matcher.is_match(arg):
			return false
	return true
class_name EqualsArgumentMatcher
extends GdUnitArgumentMatcher

var _current :Variant
var _auto_deep_check_mode :bool


func _init(current :Variant, auto_deep_check_mode := false) -> void:
	_current = current
	_auto_deep_check_mode = auto_deep_check_mode


func is_match(value :Variant) -> bool:
	var case_sensitive_check := true
	return GdObjects.equals(_current, value, case_sensitive_check, compare_mode(value))


func compare_mode(value :Variant) -> GdObjects.COMPARE_MODE:
	if _auto_deep_check_mode and is_instance_valid(value):
		# we do deep check on all InputEvent's
		return GdObjects.COMPARE_MODE.PARAMETER_DEEP_TEST if value is InputEvent else GdObjects.COMPARE_MODE.OBJECT_REFERENCE
	return GdObjects.COMPARE_MODE.OBJECT_REFERENCE
## The base class of all argument matchers
class_name GdUnitArgumentMatcher
extends RefCounted


@warning_ignore("unused_parameter")
func is_match(value :Variant) -> bool:
	return true
class_name GdUnitArgumentMatchers
extends RefCounted

const TYPE_ANY = TYPE_MAX + 100


static func to_matcher(arguments :Array[Variant], auto_deep_check_mode := false) -> ChainedArgumentMatcher:
	var matchers :Array[Variant] = []
	for arg :Variant in arguments:
		# argument is already a matcher
		if arg is GdUnitArgumentMatcher:
			matchers.append(arg)
		else:
			# pass argument into equals matcher
			matchers.append(EqualsArgumentMatcher.new(arg, auto_deep_check_mode))
	return ChainedArgumentMatcher.new(matchers)


static func any() -> GdUnitArgumentMatcher:
	return  AnyArgumentMatcher.new()


static func by_type(type :int) -> GdUnitArgumentMatcher:
	return AnyBuildInTypeArgumentMatcher.new([type])


static func by_types(types :PackedInt32Array) -> GdUnitArgumentMatcher:
	return AnyBuildInTypeArgumentMatcher.new(types)


static func any_class(clazz :Object) -> GdUnitArgumentMatcher:
	return AnyClazzArgumentMatcher.new(clazz)
class_name GdUnitMock
extends RefCounted

## do call the real implementation
const CALL_REAL_FUNC = "CALL_REAL_FUNC"
## do return a default value for primitive types or null
const RETURN_DEFAULTS = "RETURN_DEFAULTS"
## do return a default value for primitive types and a fully mocked value for Object types
## builds full deep mocked object
const RETURN_DEEP_STUB = "RETURN_DEEP_STUB"

var _value: Variant


func _init(value: Variant) -> void:
	_value = value


## Selects the mock to work on, used in combination with [method GdUnitTestSuite.do_return][br]
## Example:
## 	[codeblock]
## 		do_return(false).on(myMock).is_selected()
## 	[/codeblock]
func on(obj: Variant) -> Variant:
	if not GdUnitMock._is_mock_or_spy(obj, "__do_return"):
		return obj
	@warning_ignore("unsafe_method_access")
	return obj.__do_return(_value)


## [color=yellow]`checked` is obsolete, use `on` instead [/color]
func checked(obj :Object) -> Object:
	push_warning("Using a deprecated function 'checked' use `on` instead")
	return on(obj)


static func _is_mock_or_spy(obj: Variant, func_sig: String) -> bool:
	if obj is Object and not as_object(obj).has_method(func_sig):
		push_error("Error: You try to use a non mock or spy!")
		return false
	return true


static func as_object(value: Variant) -> Object:
	return value
class_name GdUnitMockBuilder
extends GdUnitClassDoubler

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const MOCK_TEMPLATE :GDScript = preload("res://addons/gdUnit4/src/mocking/GdUnitMockImpl.gd")


static func is_push_errors() -> bool:
	return GdUnitSettings.is_report_push_errors()


@warning_ignore("unsafe_method_access", "unsafe_cast")
static func build(clazz :Variant, mock_mode :String, debug_write := false) -> Variant:
	var push_errors := is_push_errors()
	if not is_mockable(clazz, push_errors):
		return null
	# mocking a scene?
	if GdObjects.is_scene(clazz):
		return mock_on_scene(clazz as PackedScene, debug_write)
	elif typeof(clazz) == TYPE_STRING and clazz.ends_with(".tscn"):
		return mock_on_scene(load(clazz as String) as PackedScene, debug_write)
	# mocking a script
	var instance := create_instance(clazz)
	var mock := mock_on_script(instance, clazz, [ "get_script"], debug_write)
	if not instance is RefCounted:
		instance.free()
	if mock == null:
		return null
	var mock_instance: Variant = mock.new()
	mock_instance.__set_script(mock)
	mock_instance.__set_singleton()
	mock_instance.__set_mode(mock_mode)
	return register_auto_free(mock_instance)


@warning_ignore("unsafe_method_access", "unsafe_cast")
static func create_instance(clazz: Variant) -> Object:
	if typeof(clazz) == TYPE_OBJECT and  (clazz as Object).is_class("GDScriptNativeClass"):
		return clazz.new()
	elif (clazz is GDScript) || (typeof(clazz) == TYPE_STRING and clazz.ends_with(".gd")):
		var script: GDScript = null
		if clazz is GDScript:
			script = clazz
		else:
			script = load(clazz as String)

		var args := GdObjects.build_function_default_arguments(script, "_init")
		return script.callv("new", args)
	elif typeof(clazz) == TYPE_STRING and ClassDB.can_instantiate(clazz as String):
		return ClassDB.instantiate(clazz as String)
	push_error("Can't create a mock validation instance from class: `%s`" % clazz)
	return null


@warning_ignore("unsafe_method_access")
static func mock_on_scene(scene :PackedScene, debug_write :bool) -> Variant:
	var push_errors := is_push_errors()
	if not scene.can_instantiate():
		if push_errors:
			push_error("Can't instanciate scene '%s'" % scene.resource_path)
		return null
	var scene_instance := scene.instantiate()
	# we can only mock checked a scene with attached script
	if scene_instance.get_script() == null:
		if push_errors:
			push_error("Can't create a mockable instance for a scene without script '%s'" % scene.resource_path)
		@warning_ignore("return_value_discarded")
		GdUnitTools.free_instance(scene_instance)
		return null

	var script_path :String = scene_instance.get_script().get_path()
	var mock := mock_on_script(scene_instance, script_path, GdUnitClassDoubler.EXLCUDE_SCENE_FUNCTIONS, debug_write)
	if mock == null:
		return null
	scene_instance.set_script(mock)
	scene_instance.__set_singleton()
	scene_instance.__set_mode(GdUnitMock.CALL_REAL_FUNC)
	return register_auto_free(scene_instance)


static func get_class_info(clazz :Variant) -> Dictionary:
	var clazz_name :String = GdObjects.extract_class_name(clazz).value()
	var clazz_path := GdObjects.extract_class_path(clazz)
	return {
		"class_name" : clazz_name,
		"class_path" : clazz_path
	}


static func mock_on_script(instance :Object, clazz :Variant, function_excludes :PackedStringArray, debug_write :bool) -> GDScript:
	var push_errors := is_push_errors()
	var function_doubler := GdUnitMockFunctionDoubler.new(push_errors)
	var class_info := get_class_info(clazz)
	var lines := load_template(MOCK_TEMPLATE.source_code, class_info, instance)

	var clazz_name :String = class_info.get("class_name")
	var clazz_path :PackedStringArray = class_info.get("class_path", [clazz_name])
	lines += double_functions(instance, clazz_name, clazz_path, function_doubler, function_excludes)

	var mock := GDScript.new()
	mock.source_code = "\n".join(lines)
	mock.resource_name =  "Mock%s_%d.gd" % [clazz_name, Time.get_ticks_msec()]
	mock.resource_path = "%s/%s"  % [GdUnitFileAccess.create_temp_dir("mock"), mock.resource_name]

	if debug_write:
		@warning_ignore("return_value_discarded")
		DirAccess.remove_absolute(mock.resource_path)
		@warning_ignore("return_value_discarded")
		ResourceSaver.save(mock, mock.resource_path)
	var error := mock.reload(true)
	if error != OK:
		push_error("Critical!!!, MockBuilder error, please contact the developer.")
		return null
	return mock


static func is_mockable(clazz :Variant, push_errors :bool=false) -> bool:
	var clazz_type := typeof(clazz)
	if clazz_type != TYPE_OBJECT and clazz_type != TYPE_STRING:
		push_error("Invalid clazz type is used")
		return false
	# is PackedScene
	if GdObjects.is_scene(clazz):
		return true
	if GdObjects.is_native_class(clazz):
		return true
	# verify class type
	if GdObjects.is_object(clazz):
		if GdObjects.is_instance(clazz):
			if push_errors:
				push_error("It is not allowed to mock an instance '%s', use class name instead, Read 'Mocker' documentation for details" % clazz)
			return false

		if not GdObjects.can_be_instantiate(clazz):
			if push_errors:
				push_error("Can't create a mockable instance for class '%s'" % clazz)
			return false
		return true
	# verify by class name checked registered classes
	var clazz_name: String = clazz
	if ClassDB.class_exists(clazz_name):
		if Engine.has_singleton(clazz_name):
			if push_errors:
				push_error("Mocking a singelton class '%s' is not allowed!  Read 'Mocker' documentation for details" % clazz_name)
			return false
		if not ClassDB.can_instantiate(clazz_name):
			if push_errors:
				push_error("Mocking class '%s' is not allowed it cannot be instantiated!" % clazz_name)
			return false
		# exclude classes where name starts with a underscore
		if clazz_name.find("_") == 0:
			if push_errors:
				push_error("Can't create a mockable instance for protected class '%s'" % clazz_name)
			return false
		return true
	# at least try to load as a script
	var clazz_path := clazz_name
	if not FileAccess.file_exists(clazz_path):
		if push_errors:
			push_error("'%s' cannot be mocked for the specified resource path, the resource does not exist" % clazz_name)
		return false
	# finally verify is a script resource
	var resource := load(clazz_path)
	if resource == null:
		if push_errors:
			push_error("'%s' cannot be mocked the script cannot be loaded." % clazz_name)
			return false
	# finally check is extending from script
	return GdObjects.is_script(resource) or GdObjects.is_scene(resource)


static func register_auto_free(obj :Variant) -> Variant:
	return GdUnitThreadManager.get_current_context().get_execution_context().register_auto_free(obj)
class_name GdUnitMockFunctionDoubler
extends GdFunctionDoubler


const TEMPLATE_FUNC_WITH_RETURN_VALUE = """
	var args__: Array = ["$(func_name)", $(arguments)]

	if $(instance)__is_prepare_return_value():
		$(instance)__save_function_return_value(args__)
		return ${default_return_value}
	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return ${default_return_value}
	else:
		$(instance)__save_function_interaction(args__)

	if $(instance)__do_call_real_func("$(func_name)", args__):
		return $(await)super($(arguments))
	return $(instance)__get_mocked_return_value_or_default(args__, ${default_return_value})

"""


const TEMPLATE_FUNC_WITH_RETURN_VOID = """
	var args__: Array = ["$(func_name)", $(arguments)]

	if $(instance)__is_prepare_return_value():
		if $(push_errors):
			push_error(\"Mocking a void function '$(func_name)(<args>) -> void:' is not allowed.\")
		return
	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return
	else:
		$(instance)__save_function_interaction(args__)

	if $(instance)__do_call_real_func("$(func_name)"):
		$(await)super($(arguments))

"""


const TEMPLATE_FUNC_VARARG_RETURN_VALUE = """
	var varargs__: Array = __filter_vargs([$(varargs)])
	var args__: Array = ["$(func_name)", $(arguments)] + varargs__

	if $(instance)__is_prepare_return_value():
		if $(push_errors):
			push_error(\"Mocking a void function '$(func_name)(<args>) -> void:' is not allowed.\")
		$(instance)__save_function_return_value(args__)
		return ${default_return_value}
	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return ${default_return_value}
	else:
		$(instance)__save_function_interaction(args__)

	if $(instance)__do_call_real_func("$(func_name)", args__):
		match varargs__.size():
			0: return $(await)super($(arguments))
			1: return $(await)super($(arguments), varargs__[0])
			2: return $(await)super($(arguments), varargs__[0], varargs__[1])
			3: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2])
			4: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3])
			5: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4])
			6: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4], varargs__[5])
			7: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4], varargs__[5], varargs__[6])
			8: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4], varargs__[5], varargs__[6], varargs__[7])
			9: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4], varargs__[5], varargs__[6], varargs__[7], varargs__[8])
			10: return $(await)super($(arguments), varargs__[0], varargs__[1], varargs__[2], varargs__[3], varargs__[4], varargs__[5], varargs__[6], varargs__[7], varargs__[8], varargs__[9])
	return __get_mocked_return_value_or_default(args__, ${default_return_value})

"""


func _init(push_errors :bool = false) -> void:
	super._init(push_errors)


func get_template(fd: GdFunctionDescriptor, _is_callable: bool) -> String:
	if fd.is_vararg():
		return TEMPLATE_FUNC_VARARG_RETURN_VALUE
	var return_type :Variant = fd.return_type()
	if return_type is StringName:
		return TEMPLATE_FUNC_WITH_RETURN_VALUE
	return TEMPLATE_FUNC_WITH_RETURN_VOID if (return_type == TYPE_NIL or return_type == GdObjects.TYPE_VOID) else TEMPLATE_FUNC_WITH_RETURN_VALUE

################################################################################
# internal mocking stuff
################################################################################
const __INSTANCE_ID = "${instance_id}"
const __SOURCE_CLASS = "${source_class}"

var __mock_working_mode := GdUnitMock.RETURN_DEFAULTS
var __excluded_methods :PackedStringArray = []
var __do_return_value :Variant = null
var __prepare_return_value := false

#{ <func_name> = {
#		<func_args> = <return_value>
#	}
#}
var __mocked_return_values := Dictionary()


static func __instance() -> Object:
	return Engine.get_meta(__INSTANCE_ID)


func _notification(what :int) -> void:
	if what == NOTIFICATION_PREDELETE:
		if Engine.has_meta(__INSTANCE_ID):
			Engine.remove_meta(__INSTANCE_ID)


func __instance_id() -> String:
	return __INSTANCE_ID


func __set_singleton() -> void:
	# store self need to mock static functions
	Engine.set_meta(__INSTANCE_ID, self)


func __release_double() -> void:
	# we need to release the self reference manually to prevent orphan nodes
	Engine.remove_meta(__INSTANCE_ID)


func __is_prepare_return_value() -> bool:
	return __prepare_return_value


func __sort_by_argument_matcher(__left_args :Array, __right_args :Array) -> bool:
	for __index in __left_args.size():
		var __larg :Variant = __left_args[__index]
		if __larg is GdUnitArgumentMatcher:
			return false
	return true


# we need to sort by matcher arguments so that they are all at the end of the list
func __sort_dictionary(__unsorted_args :Dictionary) -> Dictionary:
	# only need to sort if contains more than one entry
	if __unsorted_args.size() <= 1:
		return __unsorted_args
	var __sorted_args := __unsorted_args.keys()
	__sorted_args.sort_custom(__sort_by_argument_matcher)
	var __sorted_result := {}
	for __index in __sorted_args.size():
		var key :Variant = __sorted_args[__index]
		__sorted_result[key] = __unsorted_args[key]
	return __sorted_result


func __save_function_return_value(__fuction_args :Array) -> void:
	var __func_name :String = __fuction_args[0]
	var __func_args :Array = __fuction_args.slice(1)
	var __mocked_return_value_by_args :Dictionary = __mocked_return_values.get(__func_name, {})
	__mocked_return_value_by_args[__func_args] = __do_return_value
	__mocked_return_values[__func_name] = __sort_dictionary(__mocked_return_value_by_args)
	__do_return_value = null
	__prepare_return_value = false


@warning_ignore("unsafe_method_access")
func __is_mocked_args_match(__func_args :Array, __mocked_args :Array) -> bool:
	var __is_matching := false
	for __index in __mocked_args.size():
		var __fuction_args :Variant = __mocked_args[__index]
		if __func_args.size() != __fuction_args.size():
			continue
		__is_matching = true
		for __arg_index in __func_args.size():
			var __func_arg :Variant = __func_args[__arg_index]
			var __mock_arg :Variant = __fuction_args[__arg_index]
			if __mock_arg is GdUnitArgumentMatcher:
				__is_matching = __is_matching and __mock_arg.is_match(__func_arg)
			else:
				__is_matching = __is_matching and typeof(__func_arg) == typeof(__mock_arg) and __func_arg == __mock_arg
			if not __is_matching:
				break
		if __is_matching:
			break
	return __is_matching


@warning_ignore("unsafe_method_access")
func __get_mocked_return_value_or_default(__fuction_args :Array, __default_return_value :Variant) -> Variant:
	var __func_name :String = __fuction_args[0]
	if not __mocked_return_values.has(__func_name):
		return __default_return_value
	var __func_args :Array = __fuction_args.slice(1)
	var __mocked_args :Array = __mocked_return_values.get(__func_name).keys()
	for __index in __mocked_args.size():
		var __margs :Variant = __mocked_args[__index]
		if __is_mocked_args_match(__func_args, [__margs]):
			return __mocked_return_values[__func_name][__margs]
	return __default_return_value


func __set_script(__script :GDScript) -> void:
	super.set_script(__script)


func __set_mode(mock_working_mode :String) -> Object:
	__mock_working_mode = mock_working_mode
	return self


@warning_ignore("unsafe_method_access")
func __do_call_real_func(__func_name :String, __func_args := []) -> bool:
	var __is_call_real_func := __mock_working_mode == GdUnitMock.CALL_REAL_FUNC  and not __excluded_methods.has(__func_name)
	# do not call real funcions for mocked functions
	if __is_call_real_func and __mocked_return_values.has(__func_name):
		var __fuction_args :Array = __func_args.slice(1)
		var __mocked_args :Array = __mocked_return_values.get(__func_name).keys()
		return not __is_mocked_args_match(__fuction_args, __mocked_args)
	return __is_call_real_func


func __exclude_method_call(exluded_methods :PackedStringArray) -> void:
	__excluded_methods.append_array(exluded_methods)


func __do_return(mock_do_return_value :Variant) -> Object:
	__do_return_value = mock_do_return_value
	__prepare_return_value = true
	return self
extends RefCounted
class_name ErrorLogEntry


enum TYPE {
	SCRIPT_ERROR,
	PUSH_ERROR,
	PUSH_WARNING
}


const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const PATTERN_SCRIPT_ERROR := "USER SCRIPT ERROR:"
const PATTERN_PUSH_ERROR := "USER ERROR:"
const PATTERN_PUSH_WARNING := "USER WARNING:"
# With Godot 4.4 the pattern has changed
const PATTERN_4x4_SCRIPT_ERROR := "SCRIPT ERROR:"
const PATTERN_4x4_PUSH_ERROR := "ERROR:"
const PATTERN_4x4_PUSH_WARNING := "WARNING:"

static var _regex_parse_error_line_number: RegEx

var _type: TYPE
var _line: int
var _message: String
var _details: String


func _init(type: TYPE, line: int, message: String, details: String) -> void:
	_type = type
	_line = line
	_message = message
	_details = details


static func is_godot4x4() -> bool:
	return Engine.get_version_info().hex >= 0x40400


static func extract_push_warning(records: PackedStringArray, index: int) -> ErrorLogEntry:
	var pattern := PATTERN_4x4_PUSH_WARNING if is_godot4x4() else PATTERN_PUSH_WARNING
	return _extract(records, index, TYPE.PUSH_WARNING, pattern)


static func extract_push_error(records: PackedStringArray, index: int) -> ErrorLogEntry:
	var pattern := PATTERN_4x4_PUSH_ERROR if is_godot4x4() else PATTERN_PUSH_ERROR
	return _extract(records, index, TYPE.PUSH_ERROR, pattern)


static func extract_error(records: PackedStringArray, index: int) -> ErrorLogEntry:
	var pattern := PATTERN_4x4_SCRIPT_ERROR if is_godot4x4() else PATTERN_SCRIPT_ERROR
	return _extract(records, index, TYPE.SCRIPT_ERROR, pattern)


static func _extract(records: PackedStringArray, index: int, type: TYPE, pattern: String) -> ErrorLogEntry:
	var message := records[index]
	if message.begins_with(pattern):
		var error := message.replace(pattern, "").strip_edges()
		var details := records[index+1].strip_edges()
		var line := _parse_error_line_number(details)
		return ErrorLogEntry.new(type, line, error, details)
	return null


static func _parse_error_line_number(record: String) -> int:
	if _regex_parse_error_line_number == null:
		_regex_parse_error_line_number = GdUnitTools.to_regex("at: .*res://.*:(\\d+)")
	var matches := _regex_parse_error_line_number.search(record)
	if matches != null:
		return matches.get_string(1).to_int()
	return -1
# GdUnit Monitoring Base Class
class_name GdUnitMonitor
extends RefCounted

var _id :String

# constructs new Monitor with given id
func _init(p_id :String) -> void:
	_id = p_id


# Returns the id of the monitor to uniqe identify
func id() -> String:
	return _id


# starts monitoring
func start() -> void:
	pass


# stops monitoring
func stop() -> void:
	pass
class_name GdUnitOrphanNodesMonitor
extends GdUnitMonitor

var _initial_count := 0
var _orphan_count := 0
var _orphan_detection_enabled :bool


func _init(name :String = "") -> void:
	super("OrphanNodesMonitor:" + name)
	_orphan_detection_enabled = GdUnitSettings.is_verbose_orphans()


func start() -> void:
	_initial_count = _orphans()


func stop() -> void:
	_orphan_count = max(0, _orphans() - _initial_count)


func _orphans() -> int:
	return Performance.get_monitor(Performance.OBJECT_ORPHAN_NODE_COUNT) as int


func orphan_nodes() -> int:
	return _orphan_count if _orphan_detection_enabled else 0
class_name GodotGdErrorMonitor
extends GdUnitMonitor

var _godot_log_file: String
var _eof: int
var _report_enabled := false
var _entries: Array[ErrorLogEntry] = []


func _init() -> void:
	super("GodotGdErrorMonitor")
	_godot_log_file = GdUnitSettings.get_log_path()
	_report_enabled = _is_reporting_enabled()


func start() -> void:
	var file := FileAccess.open(_godot_log_file, FileAccess.READ)
	if file:
		file.seek_end(0)
		_eof = file.get_length()


func stop() -> void:
	pass


func to_reports() -> Array[GdUnitReport]:
	var reports_: Array[GdUnitReport] = []
	if _report_enabled:
		reports_.assign(_entries.map(_to_report))
	_entries.clear()
	return reports_


static func _to_report(errorLog: ErrorLogEntry) -> GdUnitReport:
	var failure := "%s\n\t%s\n%s %s" % [
		GdAssertMessages._error("Godot Runtime Error !"),
		GdAssertMessages._colored_value(errorLog._details),
		GdAssertMessages._error("Error:"),
		GdAssertMessages._colored_value(errorLog._message)]
	return GdUnitReport.new().create(GdUnitReport.ABORT, errorLog._line, failure)


func scan(force_collect_reports := false) -> Array[ErrorLogEntry]:
	await (Engine.get_main_loop() as SceneTree).process_frame
	await (Engine.get_main_loop() as SceneTree).physics_frame
	_entries.append_array(_collect_log_entries(force_collect_reports))
	return _entries


func erase_log_entry(entry: ErrorLogEntry) -> void:
	_entries.erase(entry)


func _collect_log_entries(force_collect_reports: bool) -> Array[ErrorLogEntry]:
	var file := FileAccess.open(_godot_log_file, FileAccess.READ)
	file.seek(_eof)
	var records := PackedStringArray()
	while not file.eof_reached():
		@warning_ignore("return_value_discarded")
		records.append(file.get_line())
	file.seek_end(0)
	_eof = file.get_length()
	var log_entries: Array[ErrorLogEntry]= []
	var is_report_errors := force_collect_reports or _is_report_push_errors()
	var is_report_script_errors := force_collect_reports or _is_report_script_errors()
	for index in records.size():
		if force_collect_reports:
			log_entries.append(ErrorLogEntry.extract_push_warning(records, index))
		if is_report_errors:
			log_entries.append(ErrorLogEntry.extract_push_error(records, index))
		if is_report_script_errors:
			log_entries.append(ErrorLogEntry.extract_error(records, index))
	return log_entries.filter(func(value: ErrorLogEntry) -> bool: return value != null )


func _is_reporting_enabled() -> bool:
	return _is_report_script_errors() or _is_report_push_errors()


func _is_report_push_errors() -> bool:
	return GdUnitSettings.is_report_push_errors()


func _is_report_script_errors() -> bool:
	return GdUnitSettings.is_report_script_errors()
extends RefCounted
class_name GdUnit4CSharpApiLoader


static func instance() -> Object:
	return GdUnitSingleton.instance("GdUnit4CSharpApi", func() -> Object:
		if not GdUnit4CSharpApiLoader.is_mono_supported():
			return null
		@warning_ignore("unsafe_method_access")
		return load("res://addons/gdUnit4/src/mono/GdUnit4CSharpApi.cs").new()
	)


static func is_engine_version_supported(engine_version :int = Engine.get_version_info().hex) -> bool:
	return engine_version >= 0x40200


# test is Godot mono running
static func is_mono_supported() -> bool:
	return ClassDB.class_exists("CSharpScript") and is_engine_version_supported()


static func version() -> String:
	if not GdUnit4CSharpApiLoader.is_mono_supported():
		return "unknown"
	@warning_ignore("unsafe_method_access")
	return instance().Version()


static func create_test_suite(source_path :String, line_number :int, test_suite_path :String) -> GdUnitResult:
	if not GdUnit4CSharpApiLoader.is_mono_supported():
		return  GdUnitResult.error("Can't create test suite. No C# support found.")
	@warning_ignore("unsafe_method_access")
	var result: Dictionary = instance().CreateTestSuite(source_path, line_number, test_suite_path)
	if result.has("error"):
		return GdUnitResult.error(str(result.get("error")))
	return  GdUnitResult.success(result)


static func is_test_suite(resource_path :String) -> bool:
	if not is_csharp_file(resource_path) or not GdUnit4CSharpApiLoader.is_mono_supported():
		return false

	if resource_path.is_empty():
		if GdUnitSettings.is_report_push_errors():
			push_error("Can't create test suite. Missing resource path.")
		return  false
	@warning_ignore("unsafe_method_access")
	return instance().IsTestSuite(resource_path)


static func parse_test_suite(source_path :String) -> Node:
	if not GdUnit4CSharpApiLoader.is_mono_supported():
		if GdUnitSettings.is_report_push_errors():
			push_error("Can't create test suite. No c# support found.")
		return null
	@warning_ignore("unsafe_method_access")
	return instance().ParseTestSuite(source_path)


static func create_executor(listener :Node) -> RefCounted:
	if not GdUnit4CSharpApiLoader.is_mono_supported():
		return null
	@warning_ignore("unsafe_method_access")
	return instance().Executor(listener)


static func is_csharp_file(resource_path :String) -> bool:
	var ext := resource_path.get_extension()
	return ext == "cs" and GdUnit4CSharpApiLoader.is_mono_supported()
@tool
extends Node

@onready var _server :GdUnitTcpServer = $TcpServer


@warning_ignore("return_value_discarded")
func _ready() -> void:
	var result := _server.start()
	if result.is_error():
		push_error(result.error_message())
		return
	var server_port :int = result.value()
	Engine.set_meta("gdunit_server_port", server_port)
	_server.client_connected.connect(_on_client_connected)
	_server.client_disconnected.connect(_on_client_disconnected)
	_server.rpc_data.connect(_receive_rpc_data)
	GdUnitCommandHandler.instance().gdunit_runner_stop.connect(_on_gdunit_runner_stop)


func _on_client_connected(client_id: int) -> void:
	GdUnitSignals.instance().gdunit_client_connected.emit(client_id)


func _on_client_disconnected(client_id: int) -> void:
	GdUnitSignals.instance().gdunit_client_disconnected.emit(client_id)


func _on_gdunit_runner_stop(client_id: int) -> void:
	if _server:
		_server.disconnect_client(client_id)


func _receive_rpc_data(p_rpc: Variant) -> void:
	if p_rpc is RPCMessage:
		GdUnitSignals.instance().gdunit_message.emit(p_rpc.message())
		return
	if p_rpc is RPCGdUnitEvent:
		GdUnitSignals.instance().gdunit_event.emit(p_rpc.event())
		return
	if p_rpc is RPCGdUnitTestSuite:
		GdUnitSignals.instance().gdunit_add_test_suite.emit(p_rpc.dto())
class_name GdUnitServerConstants
extends RefCounted

const DEFAULT_SERVER_START_RETRY_TIMES :int = 5
const GD_TEST_SERVER_PORT :int = 31002
const JSON_RESPONSE_DELIMITER :String = "<<JRD>>"
class_name GdUnitTask
extends RefCounted

const TASK_NAME = "task_name"
const TASK_ARGS = "task_args"

var _task_name :String
var _fref :Callable


func _init(task_name :String,instance :Object,func_name :String) -> void:
	_task_name = task_name
	if not instance.has_method(func_name):
		push_error("Can't create GdUnitTask, Invalid func name '%s' for instance '%s'" % [instance, func_name])
	_fref = Callable(instance, func_name)


func name() -> String:
	return _task_name


func execute(args :Array) -> GdUnitResult:
	if args.is_empty():
		return _fref.call()
	return _fref.callv(args)
class_name GdUnitTcpClient
extends Node

signal connection_succeeded(message :String)
signal connection_failed(message :String)


var _host :String
var _port :int
var _client_id :int
var _connected :bool
var _stream :StreamPeerTCP


func _ready() -> void:
	_connected = false
	_stream = StreamPeerTCP.new()
	_stream.set_big_endian(true)


func stop() -> void:
	console("Client: disconnect from server")
	if _stream != null:
		rpc_send(RPCClientDisconnect.new().with_id(_client_id))
	if _stream != null:
		_stream.disconnect_from_host()
	_connected = false


func start(host :String, port :int) -> GdUnitResult:
	_host = host
	_port = port
	if _connected:
		return GdUnitResult.warn("Client already connected ... %s:%d" % [_host, _port])

	# Connect client to server
	if _stream.get_status() != StreamPeerTCP.STATUS_CONNECTED:
		var err := _stream.connect_to_host(host, port)
		#prints("connect_to_host", host, port, err)
		if err != OK:
			return GdUnitResult.error("GdUnit4: Can't establish client, error code: %s" % err)
	return GdUnitResult.success("GdUnit4: Client connected checked port %d" % port)


func _process(_delta :float) -> void:
	match _stream.get_status():
		StreamPeerTCP.STATUS_NONE:
			return

		StreamPeerTCP.STATUS_CONNECTING:
			set_process(false)
			# wait until client is connected to server
			for retry in 10:
				@warning_ignore("return_value_discarded")
				_stream.poll()
				console("wait to connect ..")
				if _stream.get_status() == StreamPeerTCP.STATUS_CONNECTING:
					await get_tree().create_timer(0.500).timeout
				if _stream.get_status() == StreamPeerTCP.STATUS_CONNECTED:
					set_process(true)
					return
			set_process(true)
			_stream.disconnect_from_host()
			console("connection failed")
			connection_failed.emit("Connect to TCP Server %s:%d faild!" % [_host, _port])

		StreamPeerTCP.STATUS_CONNECTED:
			if not _connected:
				var rpc_ :RPC = null
				set_process(false)
				while rpc_ == null:
					await get_tree().create_timer(0.500).timeout
					rpc_ = rpc_receive()
				set_process(true)
				_client_id = (rpc_ as RPCClientConnect).client_id()
				console("Connected to Server: %d" % _client_id)
				connection_succeeded.emit("Connect to TCP Server %s:%d success." % [_host, _port])
				_connected = true
			process_rpc()

		StreamPeerTCP.STATUS_ERROR:
			console("connection failed")
			_stream.disconnect_from_host()
			connection_failed.emit("Connect to TCP Server %s:%d faild!" % [_host, _port])
			return


func is_client_connected() -> bool:
	return _connected


func process_rpc() -> void:
	if _stream.get_available_bytes() > 0:
		var rpc_ := rpc_receive()
		if rpc_ is RPCClientDisconnect:
			stop()


func rpc_send(p_rpc :RPC) -> void:
	if _stream != null:
		var data := GdUnitServerConstants.JSON_RESPONSE_DELIMITER + p_rpc.serialize() + GdUnitServerConstants.JSON_RESPONSE_DELIMITER
		@warning_ignore("return_value_discarded")
		_stream.put_data(data.to_utf8_buffer())


func rpc_receive() -> RPC:
	if _stream != null:
		while _stream.get_available_bytes() > 0:
			var available_bytes := _stream.get_available_bytes()
			var data := _stream.get_data(available_bytes)
			var received_data: PackedByteArray = data[1]
			# data send by Godot has this magic header of 12 bytes
			var header := Array(received_data.slice(0, 4))
			if header == [0, 0, 0, 124]:
				received_data = received_data.slice(12, available_bytes)
			var decoded := received_data.get_string_from_utf8()
			if decoded == "":
				#prints("decoded is empty", available_bytes, received_data.get_string_from_utf8())
				return null
			return RPC.deserialize(decoded)
	return null


func console(_message :String) -> void:
	#prints("TCP Client:", _message)
	pass


func _on_connection_failed(message :String) -> void:
	console("connection faild: " + message)


func _on_connection_succeeded(message :String) -> void:
	console("connected: " + message)
@tool
class_name GdUnitTcpServer
extends Node

signal client_connected(client_id :int)
signal client_disconnected(client_id :int)
@warning_ignore("unused_signal")
signal rpc_data(rpc_data: RPC)

var _server :TCPServer


class TcpConnection extends Node:
	var _id :int
	# we do use untyped here because we using a mock for testing and the static type is break the mock
	@warning_ignore("untyped_declaration")
	var _stream
	var _readBuffer :String = ""


	@warning_ignore("unsafe_method_access")
	func _init(p_server :Variant) -> void:
		assert(p_server is TCPServer)
		_stream = p_server.take_connection()
		_stream.set_big_endian(true)
		_id = _stream.get_instance_id()
		rpc_send(RPCClientConnect.new().with_id(_id))


	func _ready() -> void:
		server().client_connected.emit(_id)


	func close() -> void:
		if _stream != null:
			@warning_ignore("unsafe_method_access")
			_stream.disconnect_from_host()
			_readBuffer = ""
			_stream = null
			queue_free()


	func id() -> int:
		return _id


	func server() -> GdUnitTcpServer:
		return get_parent()


	func rpc_send(p_rpc: RPC) -> void:
		@warning_ignore("unsafe_method_access")
		_stream.put_var(p_rpc.serialize(), true)


	func _process(_delta: float) -> void:
		@warning_ignore("unsafe_method_access")
		if _stream == null or _stream.get_status() != StreamPeerTCP.STATUS_CONNECTED:
			return
		receive_packages()


	@warning_ignore("unsafe_method_access")
	func receive_packages() -> void:
		var available_bytes :int = _stream.get_available_bytes()
		if available_bytes > 0:
			var partial_data :Array = _stream.get_partial_data(available_bytes)
			# Check for read error.
			if partial_data[0] != OK:
				push_error("Error getting data from stream: %s " % partial_data[0])
				return
			else:
				var received_data: PackedByteArray = partial_data[1]
				for package in _read_next_data_packages(received_data):
					var rpc_ := RPC.deserialize(package)
					if rpc_ is RPCClientDisconnect:
						close()
					server().rpc_data.emit(rpc_)


	func _read_next_data_packages(data_package: PackedByteArray) -> PackedStringArray:
		_readBuffer += data_package.get_string_from_utf8()
		var json_array := _readBuffer.split(GdUnitServerConstants.JSON_RESPONSE_DELIMITER)
		# We need to check if the current data is terminated by the delemiter (data packets can be split unspecifically).
		# If not, store the last part in _readBuffer and complete it on the next data packet that is received
		if not _readBuffer.ends_with(GdUnitServerConstants.JSON_RESPONSE_DELIMITER):
			_readBuffer = json_array[-1]
			json_array.remove_at(json_array.size()-1)
		else:
		# Reset the buffer if a completely terminated packet was received
			_readBuffer = ""
		# remove empty packages
		for index in json_array.size():
			if index < json_array.size() and json_array[index].is_empty():
				json_array.remove_at(index)
		return json_array


	func console(_message :String) -> void:
		#print_debug("TCP Connection:", _message)
		pass


@warning_ignore("return_value_discarded")
func _ready() -> void:
	_server = TCPServer.new()
	client_connected.connect(_on_client_connected)
	client_disconnected.connect(_on_client_disconnected)


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		stop()


func start() -> GdUnitResult:
	var server_port := GdUnitServerConstants.GD_TEST_SERVER_PORT
	var err := OK
	for retry in GdUnitServerConstants.DEFAULT_SERVER_START_RETRY_TIMES:
		err = _server.listen(server_port, "127.0.0.1")
		if err != OK:
			prints("GdUnit4: Can't establish server checked port: %d, Error: %s" % [server_port, error_string(err)])
			server_port += 1
			prints("GdUnit4: Retry (%d) ..." % retry)
		else:
			break
	if err != OK:
		if err == ERR_ALREADY_IN_USE:
			return GdUnitResult.error("GdUnit4: Can't establish server, the server is already in use. Error: %s, " % error_string(err))
		return GdUnitResult.error("GdUnit4: Can't establish server. Error: %s." % error_string(err))
	prints("GdUnit4: Test server successfully started checked port: %d" % server_port)
	return GdUnitResult.success(server_port)


func stop() -> void:
	if _server:
		_server.stop()
	for connection in get_children():
		if connection is TcpConnection:
			@warning_ignore("unsafe_method_access")
			connection.close()
			remove_child(connection)
	_server = null


func disconnect_client(client_id: int) -> void:
	client_disconnected.emit(client_id)


func _process(_delta: float) -> void:
	if _server != null and not _server.is_listening():
		return
	# check if connection is ready to be used
	if _server.is_connection_available():
		add_child(TcpConnection.new(_server))


func _on_client_connected(client_id: int) -> void:
	console("Client connected %d" % client_id)


@warning_ignore("unsafe_method_access")
func _on_client_disconnected(client_id: int) -> void:
	for connection in get_children():
		if connection is TcpConnection and connection.id() == client_id:
			connection.close()
			remove_child(connection)


func console(_message: String) -> void:
	#print_debug("TCP Server:", _message)
	pass
class_name RPC
extends RefCounted


func serialize() -> String:
	return JSON.stringify(inst_to_dict(self))


# using untyped version see comments below
static func deserialize(json_value :String) -> Object:
	var json := JSON.new()
	var err := json.parse(json_value)
	if err != OK:
		push_error("Can't deserialize JSON, error at line %d: %s \n json: '%s'" % [json.get_error_line(), json.get_error_message(), json_value])
		return null
	var result :Dictionary = json.get_data()
	if not typeof(result) == TYPE_DICTIONARY:
		push_error("Can't deserialize JSON, error at line %d: %s \n json: '%s'" % [result.error_line, result.error_string, json_value])
		return null
	return dict_to_inst(result)

# this results in orpan node, for more details https://github.com/godotengine/godot/issues/50069
#func deserialize2(data :Dictionary) -> RPC:
#	return  dict_to_inst(data) as RPC
class_name RPCClientConnect
extends RPC

var _client_id :int


func with_id(p_client_id :int) -> RPCClientConnect:
	_client_id = p_client_id
	return self


func client_id() -> int:
	return _client_id
class_name RPCClientDisconnect
extends RPC

var _client_id :int


func with_id(p_client_id :int) -> RPCClientDisconnect:
	_client_id = p_client_id
	return self


func client_id() -> int:
	return _client_id
class_name RPCGdUnitEvent
extends RPC

var _event :Dictionary


static func of(p_event :GdUnitEvent) -> RPCGdUnitEvent:
	var rpc := RPCGdUnitEvent.new()
	rpc._event = p_event.serialize()
	return rpc


func event() -> GdUnitEvent:
	return GdUnitEvent.new().deserialize(_event)


func _to_string() -> String:
	return "RPCGdUnitEvent: " + str(_event)
class_name RPCGdUnitTestSuite
extends RPC

var _data :Dictionary


static func of(test_suite :Node) -> RPCGdUnitTestSuite:
	var rpc := RPCGdUnitTestSuite.new()
	rpc._data = GdUnitTestSuiteDto.new().serialize(test_suite)
	return rpc


func dto() -> GdUnitResourceDto:
	return GdUnitTestSuiteDto.new().deserialize(_data)


func _to_string() -> String:
	return "RPCGdUnitTestSuite: " + str(_data)
class_name RPCMessage
extends RPC

var _message :String


static func of(p_message :String) -> RPCMessage:
	var rpc := RPCMessage.new()
	rpc._message = p_message
	return rpc


func message() -> String:
	return _message


func _to_string() -> String:
	return "RPCMessage: " + _message
class_name GdUnitResourceDto
extends Resource

var _name :String
var _path :String


func serialize(resource :Node) -> Dictionary:
	var serialized := Dictionary()
	serialized["name"] = resource.get_name()
	@warning_ignore("unsafe_method_access")
	serialized["resource_path"] = resource.ResourcePath()
	return serialized


func deserialize(data :Dictionary) -> GdUnitResourceDto:
	_name = data.get("name", "n.a.")
	_path = data.get("resource_path", "")
	return self


func name() -> String:
	return _name


func path() -> String:
	return _path
class_name GdUnitTestCaseDto
extends GdUnitResourceDto

var _line_number :int = -1
var _script_path: String
var _test_case_names :PackedStringArray = []


@warning_ignore("unsafe_method_access")
func serialize(test_case :Node) -> Dictionary:
	var serialized := super.serialize(test_case)
	if test_case.has_method("line_number"):
		serialized["line_number"] = test_case.line_number()
	else:
		serialized["line_number"] = test_case.get("LineNumber")
	if test_case.has_method("script_path"):
		serialized["script_path"] = test_case.script_path()
	else:
		# TODO 'script_path' needs to be implement in c# the the
		# serialized["script_path"] = test_case.get("ScriptPath")
		serialized["script_path"] = serialized["resource_path"]
	if test_case.has_method("test_case_names"):
		serialized["test_case_names"] = test_case.test_case_names()
	elif test_case.has_method("TestCaseNames"):
		serialized["test_case_names"] = test_case.TestCaseNames()
	return serialized


func deserialize(data :Dictionary) -> GdUnitTestCaseDto:
	@warning_ignore("return_value_discarded")
	super.deserialize(data)
	_line_number = data.get("line_number", -1)
	_script_path = data.get("script_path", data.get("resource_path", ""))
	_test_case_names = data.get("test_case_names", [])
	return self


func line_number() -> int:
	return _line_number


func script_path() -> String:
	return _script_path


func test_case_names() -> PackedStringArray:
	return _test_case_names
class_name GdUnitTestSuiteDto
extends GdUnitResourceDto


# Dictionary[String, GdUnitTestCaseDto]
var _test_cases_by_name := Dictionary()


static func of(test_suite :Node) -> GdUnitTestSuiteDto:
	var dto := GdUnitTestSuiteDto.new()
	return dto.deserialize(dto.serialize(test_suite))


func serialize(test_suite :Node) -> Dictionary:
	var serialized := super.serialize(test_suite)
	var test_cases_ := Array()
	serialized["test_cases"] = test_cases_
	for test_case in test_suite.get_children():
		test_cases_.append(GdUnitTestCaseDto.new().serialize(test_case))
	return serialized


func deserialize(data :Dictionary) -> GdUnitResourceDto:
	@warning_ignore("return_value_discarded")
	super.deserialize(data)
	var test_cases_ :Array = data.get("test_cases", [])
	for test_case :Dictionary in test_cases_:
		add_test_case(GdUnitTestCaseDto.new().deserialize(test_case))
	return self


func add_test_case(test_case :GdUnitTestCaseDto) -> void:
	_test_cases_by_name[test_case.name()] = test_case


func test_case_count() -> int:
	return _test_cases_by_name.size()


func test_cases() -> Array[GdUnitTestCaseDto]:
	var test_cases_ :Array[GdUnitTestCaseDto] = []
	test_cases_.append_array(_test_cases_by_name.values())
	return test_cases_
class_name GdUnitByPathReport
extends GdUnitReportSummary


func _init(p_path :String, report_summaries :Array[GdUnitReportSummary]) -> void:
	_resource_path = p_path
	_reports = report_summaries


# -> Dictionary[String, Array[GdUnitReportSummary]]
static func sort_reports_by_path(report_summaries :Array[GdUnitReportSummary]) -> Dictionary:
	var by_path := Dictionary()
	for report in report_summaries:
		var suite_path :String = ProjectSettings.localize_path(report.path())
		var suite_report :Array[GdUnitReportSummary] = by_path.get(suite_path, [] as Array[GdUnitReportSummary])
		suite_report.append(report)
		by_path[suite_path] = suite_report
	return by_path


func path() -> String:
	return _resource_path.replace("res://", "")


func create_record(report_link :String) -> String:
	return GdUnitHtmlPatterns.build(GdUnitHtmlPatterns.TABLE_RECORD_PATH, self, report_link)


func write(report_dir :String) -> String:
	calculate_summary()
	var template := GdUnitHtmlPatterns.load_template("res://addons/gdUnit4/src/report/template/folder_report.html")
	var path_report := GdUnitHtmlPatterns.build(template, self, "")
	path_report = apply_testsuite_reports(report_dir, path_report, _reports)

	var output_path := "%s/path/%s.html" % [report_dir, path().replace("/", ".")]
	var dir := output_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(dir)
	FileAccess.open(output_path, FileAccess.WRITE).store_string(path_report)
	return output_path


func apply_testsuite_reports(report_dir :String, template :String, test_suite_reports :Array[GdUnitReportSummary]) -> String:
	var table_records := PackedStringArray()
	for report:GdUnitTestSuiteReport in test_suite_reports:
		var report_link := report.output_path(report_dir).replace(report_dir, "..")
		@warning_ignore("return_value_discarded")
		table_records.append(report.create_record(report_link))
	return template.replace(GdUnitHtmlPatterns.TABLE_BY_TESTSUITES, "\n".join(table_records))


func calculate_summary() -> void:
	for report:GdUnitTestSuiteReport in get_reports():
		_error_count += report.error_count()
		_failure_count += report.failure_count()
		_orphan_count += report.orphan_count()
		_skipped_count += report.skipped_count()
		_flaky_count += report.flaky_count()
		_duration += report.duration()
class_name GdUnitHtmlPatterns
extends RefCounted

const TABLE_RECORD_TESTSUITE = """
								<tr class="${report_state}">
									<td><a href=${report_link}>${testsuite_name}</a></td>
									<td><span class="status status-${report_state}">${report_state_label}</span></td>
									<td>${test_count}</td>
									<td>${skipped_count}</td>
									<td>${flaky_count}</td>
									<td>${failure_count}</td>
									<td>${orphan_count}</td>
									<td>${duration}</td>
									<td>
										<div class="status-bar">
											<div class="status-bar-column status-skipped" style="width: ${skipped-percent};"></div>
											<div class="status-bar-column status-passed" style="width: ${passed-percent};"></div>
											<div class="status-bar-column status-flaky" style="width: ${flaky-percent};"></div>
											<div class="status-bar-column status-error" style="width: ${error-percent};"></div>
											<div class="status-bar-column status-failed" style="width: ${failed-percent};"></div>
											<div class="status-bar-column status-warning" style="width: ${warning-percent};"></div>
										</div>
									</td>
								</tr>
"""

const TABLE_RECORD_PATH = """
								<tr class="${report_state}">
									<td><a class="${report_state}" href="${report_link}">${path}</a></td>
									<td><span class="status status-${report_state}">${report_state_label}</span></td>
									<td>${test_count}</td>
									<td>${skipped_count}</td>
									<td>${flaky_count}</td>
									<td>${failure_count}</td>
									<td>${orphan_count}</td>
									<td>${duration}</td>
									<td>
										<div class="status-bar">
											<div class="status-bar-column status-skipped" style="width: ${passed-skipped};"></div>
											<div class="status-bar-column status-passed" style="width: ${passed-percent};"></div>
											<div class="status-bar-column status-flaky" style="width: ${flaky-percent};"></div>
											<div class="status-bar-column status-error" style="width: ${error-percent};"></div>
											<div class="status-bar-column status-failed" style="width: ${failed-percent};"></div>
											<div class="status-bar-column status-warning" style="width: ${warning-percent};"></div>
										</div>
									</td>
								</tr>
"""


const TABLE_REPORT_TESTSUITE = """
								<tr class="${report_state}">
									<td>TestSuite hooks</td>
									<td>n/a</td>
									<td>${orphan_count}</td>
									<td>${duration}</td>
									<td class="report-column">
										<pre>
${failure-report}
										</pre>
									</td>
								</tr>
"""


const TABLE_RECORD_TESTCASE = """
								<tr class="testcase-group">
									<td>${testcase_name}</td>
									<td><span class="status status-${report_state}">${report_state_label}</span></td>
									<td>${skipped_count}</td>
									<td>${orphan_count}</td>
									<td>${duration}</td>
									<td class="report-column">
										<pre>
${failure-report}
										</pre>
									</td>
								</tr>
"""

const TABLE_BY_PATHS = "${report_table_paths}"
const TABLE_BY_TESTSUITES = "${report_table_testsuites}"
const TABLE_BY_TESTCASES = "${report_table_tests}"

# the report state success, error, warning
const REPORT_STATE = "${report_state}"
const REPORT_STATE_LABEL = "${report_state_label}"
const PATH = "${path}"
const RESOURCE_PATH = "${resource_path}"
const TESTSUITE_COUNT = "${suite_count}"
const TESTCASE_COUNT = "${test_count}"
const FAILURE_COUNT = "${failure_count}"
const FLAKY_COUNT = "${flaky_count}"
const SKIPPED_COUNT = "${skipped_count}"
const ORPHAN_COUNT = "${orphan_count}"
const DURATION = "${duration}"
const FAILURE_REPORT = "${failure-report}"
const SUCCESS_PERCENT = "${success_percent}"


const QUICK_STATE_SKIPPED = "${skipped-percent}"
const QUICK_STATE_PASSED = "${passed-percent}"
const QUICK_STATE_FLAKY = "${flaky-percent}"
const QUICK_STATE_ERROR = "${error-percent}"
const QUICK_STATE_FAILED = "${failed-percent}"
const QUICK_STATE_WARNING = "${warning-percent}"

const TESTSUITE_NAME = "${testsuite_name}"
const TESTCASE_NAME = "${testcase_name}"
const REPORT_LINK = "${report_link}"
const BREADCRUMP_PATH_LINK = "${breadcrumb_path_link}"
const BUILD_DATE = "${buid_date}"


static func current_date() -> String:
	return Time.get_datetime_string_from_system(true, true)


static func build(template: String, report: GdUnitReportSummary, report_link: String) -> String:
	return template\
		.replace(PATH, get_report_path(report))\
		.replace(BREADCRUMP_PATH_LINK, get_path_as_link(report))\
		.replace(RESOURCE_PATH, report.resource_path())\
		.replace(TESTSUITE_NAME, report.name_html_encoded())\
		.replace(TESTSUITE_COUNT, str(report.suite_count()))\
		.replace(TESTCASE_COUNT, str(report.test_count()))\
		.replace(FAILURE_COUNT, str(report.error_count() + report.failure_count()))\
		.replace(FLAKY_COUNT, str(report.flaky_count()))\
		.replace(SKIPPED_COUNT, str(report.skipped_count()))\
		.replace(ORPHAN_COUNT, str(report.orphan_count()))\
		.replace(DURATION, LocalTime.elapsed(report.duration()))\
		.replace(SUCCESS_PERCENT, report.calculate_succes_rate(report.test_count(), report.error_count(), report.failure_count()))\
		.replace(REPORT_STATE, report.report_state().to_lower())\
		.replace(REPORT_STATE_LABEL, report.report_state())\
		.replace(QUICK_STATE_SKIPPED, calculate_percentage(report.test_count(), report.skipped_count()))\
		.replace(QUICK_STATE_PASSED, calculate_percentage(report.test_count(), report.success_count()))\
		.replace(QUICK_STATE_FLAKY, calculate_percentage(report.test_count(), report.flaky_count()))\
		.replace(QUICK_STATE_ERROR, calculate_percentage(report.test_count(), report.error_count()))\
		.replace(QUICK_STATE_FAILED, calculate_percentage(report.test_count(), report.failure_count()))\
		.replace(QUICK_STATE_WARNING, calculate_percentage(report.test_count(), 0))\
		.replace(REPORT_LINK, report_link)\
		.replace(BUILD_DATE, current_date())


static func load_template(template_name :String) -> String:
	return FileAccess.open(template_name, FileAccess.READ).get_as_text()


static func get_path_as_link(report: GdUnitReportSummary) -> String:
	return "../path/%s.html" % report.path().replace("/", ".")


static func get_report_path(report: GdUnitReportSummary) -> String:
	var path := report.path()
	if path.is_empty():
		return "/"
	return path


static func calculate_percentage(p_test_count: int, count: int) -> String:
	if count <= 0:
		return "0%"
	return "%d" % (( 0 if count < 0 else count) * 100.0 / p_test_count) + "%"
class_name GdUnitHtmlReport
extends GdUnitReportSummary

const REPORT_DIR_PREFIX = "report_"

var _report_path :String
var _iteration :int


func _init(report_path :String, max_reports: int) -> void:
	if max_reports > 1:
		_iteration = GdUnitFileAccess.find_last_path_index(report_path, REPORT_DIR_PREFIX) + 1
	else:
		_iteration = 1
	_report_path = "%s/%s%d" % [report_path, REPORT_DIR_PREFIX, _iteration]
	@warning_ignore("return_value_discarded")
	DirAccess.make_dir_recursive_absolute(_report_path)


func add_testsuite_report(p_resource_path: String, p_suite_name: String, p_test_count: int) -> void:
	_reports.append(GdUnitTestSuiteReport.new(p_resource_path, p_suite_name, p_test_count))


@warning_ignore("shadowed_variable")
func add_testcase(resource_path :String, suite_name :String, test_name: String) -> void:
	for report:GdUnitTestSuiteReport in _reports:
		if report.resource_path() == resource_path:
			var test_report := GdUnitTestCaseReport.new(resource_path, suite_name, test_name)
			report.add_or_create_test_report(test_report)


func add_testsuite_reports(
	p_resource_path :String,
	p_error_count :int,
	p_failure_count :int,
	p_orphan_count :int,
	p_duration :int,
	p_reports :Array = []) -> void:

	for report:GdUnitTestSuiteReport in _reports:
		if report.resource_path() == p_resource_path:
			report.set_reports(p_reports)
	update_summary_counters(p_error_count, p_failure_count, p_orphan_count, 0, 0, p_duration)


func add_testcase_reports(
	p_resource_path: String,
	p_test_name: String,
	p_reports: Array[GdUnitReport]) -> void:

	for report:GdUnitTestSuiteReport in _reports:
		if report.resource_path() == p_resource_path:
			report.add_testcase_reports(p_test_name, p_reports)


func update_testsuite_counters(
	p_resource_path :String,
	p_error_count: int,
	p_failure_count: int,
	p_orphan_count: int,
	p_is_skipped: bool,
	p_is_flaky: bool,
	p_duration: int) -> void:

	for report:GdUnitTestSuiteReport in _reports:
		if report.resource_path() == p_resource_path:
			report.update_testsuite_counters(p_error_count, p_failure_count, p_orphan_count, p_is_skipped, p_is_flaky, p_duration)
	update_summary_counters(p_error_count, p_failure_count, p_orphan_count, p_is_skipped, p_is_flaky, 0)


func set_testcase_counters(
	p_resource_path: String,
	p_test_name: String,
	p_error_count: int,
	p_failure_count: int,
	p_orphan_count: int,
	p_is_skipped: bool,
	p_is_flaky: bool,
	p_duration: int) -> void:

	for report:GdUnitTestSuiteReport in _reports:
		if report.resource_path() == p_resource_path:
			report.set_testcase_counters(p_test_name, p_error_count, p_failure_count, p_orphan_count,
				p_is_skipped, p_is_flaky, p_duration)


func update_summary_counters(
	p_error_count: int,
	p_failure_count: int,
	p_orphan_count: int,
	p_is_skipped: bool,
	p_is_flaky: bool,
	p_duration: int) -> void:

	_error_count += p_error_count
	_failure_count += p_failure_count
	_orphan_count += p_orphan_count
	_skipped_count += p_is_skipped as int
	_flaky_count += p_is_flaky as int
	_duration += p_duration


func write() -> String:
	var template := GdUnitHtmlPatterns.load_template("res://addons/gdUnit4/src/report/template/index.html")
	var to_write := GdUnitHtmlPatterns.build(template, self, "")
	to_write = apply_path_reports(_report_path, to_write, _reports)
	to_write = apply_testsuite_reports(_report_path, to_write, _reports)
	# write report
	var index_file := "%s/index.html" % _report_path
	FileAccess.open(index_file, FileAccess.WRITE).store_string(to_write)
	@warning_ignore("return_value_discarded")
	GdUnitFileAccess.copy_directory("res://addons/gdUnit4/src/report/template/css/", _report_path + "/css")
	return index_file


func delete_history(max_reports :int) -> int:
	return GdUnitFileAccess.delete_path_index_lower_equals_than(_report_path.get_base_dir(), REPORT_DIR_PREFIX, _iteration-max_reports)


func apply_path_reports(report_dir :String, template :String, report_summaries :Array) -> String:
	#Dictionary[String, Array[GdUnitReportSummary]]
	var path_report_mapping := GdUnitByPathReport.sort_reports_by_path(report_summaries)
	var table_records := PackedStringArray()
	var paths :Array[String] = []
	paths.append_array(path_report_mapping.keys())
	paths.sort()
	for report_path in paths:
		var reports: Array[GdUnitReportSummary] = path_report_mapping.get(report_path)
		var report := GdUnitByPathReport.new(report_path, reports)
		var report_link :String = report.write(report_dir).replace(report_dir, ".")
		@warning_ignore("return_value_discarded")
		table_records.append(report.create_record(report_link))
	return template.replace(GdUnitHtmlPatterns.TABLE_BY_PATHS, "\n".join(table_records))


func apply_testsuite_reports(report_dir: String, template: String, test_suite_reports: Array[GdUnitReportSummary]) -> String:
	var table_records := PackedStringArray()
	for report: GdUnitTestSuiteReport in test_suite_reports:
		var report_link :String = report.write(report_dir).replace(report_dir, ".")
		@warning_ignore("return_value_discarded")
		table_records.append(report.create_record(report_link) as String)
	return template.replace(GdUnitHtmlPatterns.TABLE_BY_TESTSUITES, "\n".join(table_records))


func iteration() -> int:
	return _iteration
class_name GdUnitReportSummary
extends RefCounted

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const CHARACTERS_TO_ENCODE := {
	'<' : '&lt;',
	'>' : '&gt;'
}

var _resource_path :String
var _name :String
var _test_count := 0
var _failure_count := 0
var _error_count := 0
var _orphan_count := 0
var _skipped_count := 0
var _flaky_count := 0
var _duration := 0
var _reports :Array[GdUnitReportSummary] = []

func name() -> String:
	return _name


func name_html_encoded() -> String:
	return html_encode(_name)


func path() -> String:
	return _resource_path.get_base_dir().replace("res://", "")


func resource_path() -> String:
	return _resource_path


func suite_count() -> int:
	return _reports.size()


func suite_executed_count() -> int:
	var executed := _reports.size()
	for report in _reports:
		if report.test_count() == report.skipped_count():
			executed -= 1
	return executed


func test_count() -> int:
	var count := _test_count
	for report in _reports:
		count += report.test_count()
	return count


func test_executed_count() -> int:
	return test_count() - skipped_count()


func success_count() -> int:
	return test_count() - error_count() - failure_count() - flaky_count() - skipped_count()


func error_count() -> int:
	return _error_count


func failure_count() -> int:
	return _failure_count


func skipped_count() -> int:
	return _skipped_count


func flaky_count() -> int:
	return _flaky_count


func orphan_count() -> int:
	return _orphan_count


func duration() -> int:
	return _duration


func get_reports() -> Array:
	return _reports


func add_report(report :GdUnitReportSummary) -> void:
	_reports.append(report)


func report_state() -> String:
	return calculate_state(error_count(), failure_count(), orphan_count(), flaky_count(), skipped_count())


func succes_rate() -> String:
	return calculate_succes_rate(test_count(), error_count(), failure_count())


func calculate_state(p_error_count :int, p_failure_count :int, p_orphan_count :int, p_flaky_count: int, p_skipped_count: int) -> String:
	if p_skipped_count > 0:
		return "SKIPPED"
	if p_error_count > 0:
		return "ERROR"
	if p_failure_count > 0:
		return "FAILED"
	if p_flaky_count > 0:
		return "FLAKY"
	if p_orphan_count > 0:
		return "WARNING"
	return "PASSED"


func calculate_succes_rate(p_test_count :int, p_error_count :int, p_failure_count :int) -> String:
	if p_failure_count == 0:
		return "100%"
	var count := p_test_count-p_failure_count-p_error_count
	if count < 0:
		return "0%"
	return "%d" % (( 0 if count < 0 else count) * 100.0 / p_test_count) + "%"


func create_summary(_report_dir :String) -> String:
	return ""


func html_encode(value: String) -> String:
	for key: String in CHARACTERS_TO_ENCODE.keys():
		@warning_ignore("unsafe_cast")
		value = value.replace(key, CHARACTERS_TO_ENCODE[key] as String)
	return value


func convert_rtf_to_html(bbcode :String) -> String:
	return GdUnitTools.richtext_normalize(bbcode)
class_name GdUnitTestCaseReport
extends GdUnitReportSummary

var _suite_name :String
var _failure_reports :Array[GdUnitReport]


@warning_ignore("shadowed_variable")
func _init(p_resource_path: String, p_suite_name: String, p_test_name: String) -> void:
	_resource_path = p_resource_path
	_suite_name = p_suite_name
	_name = p_test_name


func suite_name() -> String:
	return _suite_name


func failure_report() -> String:
	var html_report := ""
	for report in get_test_reports():
		html_report += convert_rtf_to_html(str(report))
	return html_report


func create_record(_report_dir :String) -> String:
	return GdUnitHtmlPatterns.TABLE_RECORD_TESTCASE\
		.replace(GdUnitHtmlPatterns.REPORT_STATE, report_state().to_lower())\
		.replace(GdUnitHtmlPatterns.REPORT_STATE_LABEL, report_state())\
		.replace(GdUnitHtmlPatterns.TESTCASE_NAME, name())\
		.replace(GdUnitHtmlPatterns.SKIPPED_COUNT, str(skipped_count()))\
		.replace(GdUnitHtmlPatterns.ORPHAN_COUNT, str(orphan_count()))\
		.replace(GdUnitHtmlPatterns.DURATION, LocalTime.elapsed(_duration))\
		.replace(GdUnitHtmlPatterns.FAILURE_REPORT, failure_report())


func add_testcase_reports(reports: Array[GdUnitReport]) -> void:
	_failure_reports.append_array(reports)


func set_testcase_counters(p_error_count: int, p_failure_count: int, p_orphan_count: int,
	p_is_skipped: bool, p_is_flaky: bool, p_duration: int) -> void:
	_error_count = p_error_count
	_failure_count = p_failure_count
	_orphan_count = p_orphan_count
	_skipped_count = p_is_skipped
	_flaky_count = p_is_flaky as int
	_duration = p_duration


func get_test_reports() -> Array[GdUnitReport]:
	return _failure_reports
class_name GdUnitTestSuiteReport
extends GdUnitReportSummary

var _time_stamp: int
var _failure_reports: Array[GdUnitReport] = []


func _init(p_resource_path: String, p_name: String, p_test_count: int) -> void:
	_resource_path = p_resource_path
	_name = p_name
	_test_count = p_test_count
	_time_stamp = Time.get_unix_time_from_system() as int


func create_record(report_link :String) -> String:
	return GdUnitHtmlPatterns.build(GdUnitHtmlPatterns.TABLE_RECORD_TESTSUITE, self, report_link)


func output_path(report_dir :String) -> String:
	return "%s/test_suites/%s.%s.html" % [report_dir, path().replace("/", "."), name()]


func failure_report() -> String:
	var html_report := ""
	for report in _failure_reports:
		html_report += convert_rtf_to_html(str(report))
	return html_report


func test_suite_failure_report() -> String:
	return GdUnitHtmlPatterns.TABLE_REPORT_TESTSUITE\
		.replace(GdUnitHtmlPatterns.REPORT_STATE, report_state().to_lower())\
		.replace(GdUnitHtmlPatterns.REPORT_STATE_LABEL, report_state())\
		.replace(GdUnitHtmlPatterns.ORPHAN_COUNT, str(orphan_count()))\
		.replace(GdUnitHtmlPatterns.DURATION, LocalTime.elapsed(_duration))\
		.replace(GdUnitHtmlPatterns.FAILURE_REPORT, failure_report())


func write(report_dir :String) -> String:
	var template := GdUnitHtmlPatterns.load_template("res://addons/gdUnit4/src/report/template/suite_report.html")
	template = GdUnitHtmlPatterns.build(template, self, "")

	var report_output_path := output_path(report_dir)
	var test_report_table := PackedStringArray()
	if not _failure_reports.is_empty():
		@warning_ignore("return_value_discarded")
		test_report_table.append(test_suite_failure_report())
	for test_report: GdUnitTestCaseReport in _reports:
		@warning_ignore("return_value_discarded")
		test_report_table.append(test_report.create_record(report_output_path))

	template = template.replace(GdUnitHtmlPatterns.TABLE_BY_TESTCASES, "\n".join(test_report_table))

	var dir := report_output_path.get_base_dir()
	if not DirAccess.dir_exists_absolute(dir):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(dir)
	FileAccess.open(report_output_path, FileAccess.WRITE).store_string(template)
	return report_output_path


func set_duration(p_duration :int) -> void:
	_duration = p_duration


func time_stamp() -> int:
	return _time_stamp


func duration() -> int:
	return _duration


func set_skipped(skipped :int) -> void:
	_skipped_count += skipped


func set_orphans(orphans :int) -> void:
	_orphan_count = orphans


func set_failed(count :int) -> void:
	_failure_count += count


func set_reports(failure_reports :Array[GdUnitReport]) -> void:
	_failure_reports = failure_reports


func add_or_create_test_report(test_report: GdUnitTestCaseReport) -> void:
	_reports.append(test_report)


func update_testsuite_counters(p_error_count: int, p_failure_count: int, p_orphan_count: int,
	p_is_skipped: bool, p_is_flaky: bool, p_duration: int) -> void:
	_error_count += p_error_count
	_failure_count += p_failure_count
	_orphan_count += p_orphan_count
	_skipped_count += p_is_skipped as int
	_flaky_count += p_is_flaky as int
	_duration += p_duration


func set_testcase_counters(test_name: String, p_error_count: int, p_failure_count: int, p_orphan_count: int,
	p_is_skipped: bool, p_is_flaky: bool, p_duration: int) -> void:
	if _reports.is_empty():
		return
	var test_report:GdUnitTestCaseReport = _reports.filter(func (report: GdUnitTestCaseReport) -> bool:
		return report.name() == test_name
		).back()
	if test_report:
		test_report.set_testcase_counters(p_error_count, p_failure_count, p_orphan_count, p_is_skipped, p_is_flaky, p_duration)


func add_testcase_reports(test_name: String, reports: Array[GdUnitReport] ) -> void:
	if reports.is_empty():
		return
	# we lookup to latest matching report because of flaky tests could be retry the tests
	# and resultis in multipe report entries with the same name
	var test_report:GdUnitTestCaseReport = _reports.filter(func (report: GdUnitTestCaseReport) -> bool:
		return report.name() == test_name
		).back()
	if test_report:
		test_report.add_testcase_reports(reports)
# This class implements the JUnit XML file format
# based checked https://github.com/windyroad/JUnit-Schema/blob/master/JUnit.xsd
class_name JUnitXmlReport
extends RefCounted

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")

const ATTR_CLASSNAME := "classname"
const ATTR_ERRORS := "errors"
const ATTR_FAILURES := "failures"
const ATTR_HOST := "hostname"
const ATTR_ID := "id"
const ATTR_MESSAGE := "message"
const ATTR_NAME := "name"
const ATTR_PACKAGE := "package"
const ATTR_SKIPPED := "skipped"
const ATTR_FLAKY := "flaky"
const ATTR_TESTS := "tests"
const ATTR_TIME := "time"
const ATTR_TIMESTAMP := "timestamp"
const ATTR_TYPE := "type"

const HEADER := '<?xml version="1.0" encoding="UTF-8" ?>\n'

var _report_path :String
var _iteration :int


func _init(path :String, iteration :int) -> void:
	_iteration = iteration
	_report_path = path


func write(report :GdUnitReportSummary) -> String:
	var result_file: String = "%s/results.xml" % _report_path
	var file := FileAccess.open(result_file, FileAccess.WRITE)
	if file == null:
		push_warning("Can't saving the result to '%s'\n Error: %s" % [result_file, error_string(FileAccess.get_open_error())])
	file.store_string(build_junit_report(report))
	return result_file


func build_junit_report(report :GdUnitReportSummary) -> String:
	var iso8601_datetime := Time.get_date_string_from_system()
	var test_suites := XmlElement.new("testsuites")\
		.attribute(ATTR_ID, iso8601_datetime)\
		.attribute(ATTR_NAME, "report_%s" % _iteration)\
		.attribute(ATTR_TESTS, report.test_count())\
		.attribute(ATTR_FAILURES, report.failure_count())\
		.attribute(ATTR_SKIPPED, report.skipped_count())\
		.attribute(ATTR_FLAKY, report.flaky_count())\
		.attribute(ATTR_TIME, JUnitXmlReport.to_time(report.duration()))\
		.add_childs(build_test_suites(report))
	var as_string := test_suites.to_xml()
	test_suites.dispose()
	return HEADER + as_string


func build_test_suites(summary :GdUnitReportSummary) -> Array:
	var test_suites :Array[XmlElement] = []
	for index in summary.get_reports().size():
		var suite_report :GdUnitTestSuiteReport = summary.get_reports()[index]
		var iso8601_datetime := Time.get_datetime_string_from_unix_time(suite_report.time_stamp())
		test_suites.append(XmlElement.new("testsuite")\
			.attribute(ATTR_ID, index)\
			.attribute(ATTR_NAME, suite_report.name())\
			.attribute(ATTR_PACKAGE, suite_report.path())\
			.attribute(ATTR_TIMESTAMP, iso8601_datetime)\
			.attribute(ATTR_HOST, "localhost")\
			.attribute(ATTR_TESTS, suite_report.test_count())\
			.attribute(ATTR_FAILURES, suite_report.failure_count())\
			.attribute(ATTR_ERRORS, suite_report.error_count())\
			.attribute(ATTR_SKIPPED, suite_report.skipped_count())\
			.attribute(ATTR_FLAKY, suite_report.flaky_count())\
			.attribute(ATTR_TIME, JUnitXmlReport.to_time(suite_report.duration()))\
			.add_childs(build_test_cases(suite_report)))
	return test_suites


func build_test_cases(suite_report :GdUnitTestSuiteReport) -> Array:
	var test_cases :Array[XmlElement] = []
	for index in suite_report.get_reports().size():
		var report :GdUnitTestCaseReport = suite_report.get_reports()[index]
		test_cases.append( XmlElement.new("testcase")\
			.attribute(ATTR_NAME, JUnitXmlReport.encode_xml(report.name()))\
			.attribute(ATTR_CLASSNAME, report.suite_name())\
			.attribute(ATTR_TIME, JUnitXmlReport.to_time(report.duration()))\
			.add_childs(build_reports(report)))
	return test_cases


func build_reports(test_report: GdUnitTestCaseReport) -> Array:
	var failure_reports :Array[XmlElement] = []

	for report: GdUnitReport in test_report.get_test_reports():
		if report.is_failure():
			failure_reports.append(XmlElement.new("failure")\
				.attribute(ATTR_MESSAGE, "FAILED: %s:%d" % [test_report._resource_path, report.line_number()])\
				.attribute(ATTR_TYPE, JUnitXmlReport.to_type(report.type()))\
				.text(convert_rtf_to_text(report.message())))
		elif report.is_error():
			failure_reports.append(XmlElement.new("error")\
				.attribute(ATTR_MESSAGE, "ERROR: %s:%d" % [test_report._resource_path, report.line_number()])\
				.attribute(ATTR_TYPE, JUnitXmlReport.to_type(report.type()))\
				.text(convert_rtf_to_text(report.message())))
		elif report.is_skipped():
			failure_reports.append(XmlElement.new("skipped")\
				.attribute(ATTR_MESSAGE, "SKIPPED: %s:%d" % [test_report._resource_path, report.line_number()])\
				.text(convert_rtf_to_text(report.message())))
	return failure_reports


func convert_rtf_to_text(bbcode :String) -> String:
	return GdUnitTools.richtext_normalize(bbcode)


static func to_type(type :int) -> String:
	match type:
		GdUnitReport.SUCCESS:
			return "SUCCESS"
		GdUnitReport.WARN:
			return "WARN"
		GdUnitReport.FAILURE:
			return "FAILURE"
		GdUnitReport.ORPHAN:
			return "ORPHAN"
		GdUnitReport.TERMINATED:
			return "TERMINATED"
		GdUnitReport.INTERUPTED:
			return "INTERUPTED"
		GdUnitReport.ABORT:
			return "ABORT"
	return "UNKNOWN"


static func to_time(duration :int) -> String:
	return "%4.03f" % (duration / 1000.0)


static func encode_xml(value :String) -> String:
	return value.xml_escape(true)


#static func to_ISO8601_datetime() -> String:
	#return "%04d-%02d-%02dT%02d:%02d:%02d" % [date["year"], date["month"], date["day"],  date["hour"], date["minute"], date["second"]]
class_name XmlElement
extends RefCounted

var _name :String
# Dictionary[String, String]
var _attributes :Dictionary = {}
var _childs :Array[XmlElement] = []
var _parent :XmlElement = null
var _text :String = ""


func _init(name :String) -> void:
	_name = name


func dispose() -> void:
	for child in _childs:
		child.dispose()
	_childs.clear()
	_attributes.clear()
	_parent = null


func attribute(name :String, value :Variant) -> XmlElement:
	_attributes[name] = str(value)
	return self


func text(p_text :String) -> XmlElement:
	_text = p_text if p_text.ends_with("\n") else p_text + "\n"
	return self


func add_child(child :XmlElement) -> XmlElement:
	_childs.append(child)
	child._parent = self
	return self


func add_childs(childs :Array[XmlElement]) -> XmlElement:
	for child in childs:
		@warning_ignore("return_value_discarded")
		add_child(child)
	return self


func indentation() -> String:
	return "" if _parent == null else _parent.indentation() + "	"


func to_xml() -> String:
	var attributes := ""
	for key in _attributes.keys() as Array[String]:
		attributes += ' {attr}="{value}"'.format({"attr": key, "value": _attributes.get(key)})

	var childs := ""
	for child in _childs:
		childs += child.to_xml()

	return "{_indentation}<{name}{attributes}>\n{childs}{text}{_indentation}</{name}>\n"\
		.format({"name": _name,
			"attributes": attributes,
			"childs": childs,
			"_indentation": indentation(),
			"text": cdata(_text)})


func cdata(p_text :String) -> String:
	return "" if p_text.is_empty() else "<![CDATA[\n{text}]]>\n".format({"text" : p_text})
class_name GdUnitSpyBuilder
extends GdUnitClassDoubler

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const SPY_TEMPLATE :GDScript = preload("res://addons/gdUnit4/src/spy/GdUnitSpyImpl.gd")
const EXCLUDE_PROPERTIES_TO_COPY = ["script", "type"]


static func build(to_spy: Variant, debug_write := false) -> Variant:
	if GdObjects.is_singleton(to_spy):
		@warning_ignore("unsafe_cast")
		push_error("Spy on a Singleton is not allowed! '%s'" % (to_spy as Object).get_class())
		return null

	# if resource path load it before
	if GdObjects.is_scene_resource_path(to_spy):
		var scene_resource_path :String = to_spy
		if not FileAccess.file_exists(scene_resource_path):
			push_error("Can't build spy on scene '%s'! The given resource not exists!" % scene_resource_path)
			return null
		var scene_to_spy: PackedScene = load(scene_resource_path)
		return spy_on_scene(scene_to_spy.instantiate() as Node, debug_write)
	# spy checked PackedScene
	if GdObjects.is_scene(to_spy):
		var scene_to_spy: PackedScene = to_spy
		return spy_on_scene(scene_to_spy.instantiate() as Node, debug_write)
	# spy checked a scene instance
	if GdObjects.is_instance_scene(to_spy):
		@warning_ignore("unsafe_cast")
		return spy_on_scene(to_spy as Node, debug_write)

	var excluded_functions := []
	if to_spy is Callable:
		@warning_ignore("unsafe_cast")
		to_spy = CallableDoubler.new(to_spy as Callable)
		excluded_functions = CallableDoubler.excluded_functions()

	var spy := spy_on_script(to_spy, excluded_functions, debug_write)
	if spy == null:
		return null
	var spy_instance :Object = spy.new()
	@warning_ignore("unsafe_cast")
	copy_properties(to_spy as Object, spy_instance)
	@warning_ignore("return_value_discarded")
	GdUnitObjectInteractions.reset(spy_instance)
	@warning_ignore("unsafe_method_access")
	spy_instance.__set_singleton(to_spy)
	# we do not call the original implementation for _ready and all input function, this is actualy done by the engine
	@warning_ignore("unsafe_method_access")
	spy_instance.__exclude_method_call([ "_input", "_gui_input", "_input_event", "_unhandled_input"])
	return register_auto_free(spy_instance)


static func get_class_info(clazz :Variant) -> Dictionary:
	var clazz_path := GdObjects.extract_class_path(clazz)
	var clazz_name :String = GdObjects.extract_class_name(clazz).value()
	return {
		"class_name" : clazz_name,
		"class_path" : clazz_path
	}


static func spy_on_script(instance :Variant, function_excludes :PackedStringArray, debug_write :bool) -> GDScript:
	if GdArrayTools.is_array_type(instance):
		if GdUnitSettings.is_verbose_assert_errors():
			push_error("Can't build spy checked type '%s'! Spy checked Container Built-In Type not supported!" % type_string(typeof(instance)))
		return null
	var class_info := get_class_info(instance)
	var clazz_name :String = class_info.get("class_name")
	var clazz_path :PackedStringArray = class_info.get("class_path", [clazz_name])
	if not GdObjects.is_instance(instance):
		if GdUnitSettings.is_verbose_assert_errors():
			push_error("Can't build spy for class type '%s'! Using an instance instead e.g. 'spy(<instance>)'" % [clazz_name])
		return null
	@warning_ignore("unsafe_cast")
	var lines := load_template(SPY_TEMPLATE.source_code, class_info, instance as Object)
	@warning_ignore("unsafe_cast")
	lines += double_functions(instance as Object, clazz_name, clazz_path, GdUnitSpyFunctionDoubler.new(), function_excludes)

	var spy := GDScript.new()
	spy.source_code = "\n".join(lines)
	spy.resource_name = "Spy%s.gd" % clazz_name
	spy.resource_path = GdUnitFileAccess.create_temp_dir("spy") + "/Spy%s_%d.gd" % [clazz_name, Time.get_ticks_msec()]

	if debug_write:
		@warning_ignore("return_value_discarded")
		DirAccess.remove_absolute(spy.resource_path)
		@warning_ignore("return_value_discarded")
		ResourceSaver.save(spy, spy.resource_path)
	var error := spy.reload(true)
	if error != OK:
		push_error("Unexpected Error!, SpyBuilder error, please contact the developer.")
		return null
	return spy


static func spy_on_scene(scene :Node, debug_write :bool) -> Object:
	if scene.get_script() == null:
		if GdUnitSettings.is_verbose_assert_errors():
			push_error("Can't create a spy checked a scene without script '%s'" % scene.get_scene_file_path())
		return null
	# buils spy checked original script
	@warning_ignore("unsafe_cast")
	var scene_script :Object = (scene.get_script() as GDScript).new()
	var spy := spy_on_script(scene_script, GdUnitClassDoubler.EXLCUDE_SCENE_FUNCTIONS, debug_write)
	scene_script.free()
	if spy == null:
		return null
	# replace original script whit spy
	scene.set_script(spy)
	return register_auto_free(scene)


static func copy_properties(source :Object, dest :Object) -> void:
	for property in source.get_property_list():
		var property_name :String = property["name"]
		var property_value :Variant = source.get(property_name)
		if EXCLUDE_PROPERTIES_TO_COPY.has(property_name):
			continue
		#if dest.get(property_name) == null:
		#	prints("|%s|" % property_name, source.get(property_name))

		# check for invalid name property
		if property_name == "name" and property_value == "":
			dest.set(property_name, "<empty>");
			continue
		dest.set(property_name, property_value)


static func register_auto_free(obj :Variant) -> Variant:
	return GdUnitThreadManager.get_current_context().get_execution_context().register_auto_free(obj)
class_name GdUnitSpyFunctionDoubler
extends GdFunctionDoubler


const TEMPLATE_RETURN_VARIANT = """
	var args__: Array = ["$(func_name)", $(arguments)]

	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return ${default_return_value}
	else:
		$(instance)__save_function_interaction(args__)

	if $(instance)__do_call_real_func("$(func_name)"):
		return $(await)super($(arguments))
	return ${default_return_value}

"""


const TEMPLATE_RETURN_VOID = """
	var args__: Array = ["$(func_name)", $(arguments)]

	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return
	else:
		$(instance)__save_function_interaction(args__)

	if $(instance)__do_call_real_func("$(func_name)"):
		$(await)super($(arguments))

"""


const TEMPLATE_RETURN_VOID_VARARG = """
	var varargs__: Array = __filter_vargs([$(varargs)])
	var args__: Array = ["$(func_name)", $(arguments)] + varargs__

	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return
	else:
		$(instance)__save_function_interaction(args__)

	$(await)$(instance)__call_func("$(func_name)", [$(arguments)] + varargs__)

"""


const TEMPLATE_RETURN_VARIANT_VARARG = """
	var varargs__: Array = __filter_vargs([$(varargs)])
	var args__: Array = ["$(func_name)", $(arguments)] + varargs__

	if $(instance)__is_verify_interactions():
		$(instance)__verify_interactions(args__)
		return ${default_return_value}
	else:
		$(instance)__save_function_interaction(args__)

	return $(await)$(instance)__call_func("$(func_name)", [$(arguments)] + varargs__)

"""


const TEMPLATE_CALLABLE_CALL = """
	var used_arguments__ := __filter_vargs([$(arguments)])

	if __is_verify_interactions():
		__verify_interactions(["call", used_arguments__])
		return ${default_return_value}
	else:
		# append possible binded values to complete the original argument list
		var args__ := used_arguments__.duplicate()
		args__.append_array(super.get_bound_arguments())
		__save_function_interaction(["call", args__])

	if __do_call_real_func("call"):
		return _cb.callv(used_arguments__)
	return ${default_return_value}

"""


func _init(push_errors :bool = false) -> void:
	super._init(push_errors)


func get_template(fd: GdFunctionDescriptor, is_callable: bool) -> String:
	if is_callable and  fd.name() == "call":
		return TEMPLATE_CALLABLE_CALL
	if  fd.is_vararg():
		return TEMPLATE_RETURN_VOID_VARARG if fd.return_type() == TYPE_NIL else TEMPLATE_RETURN_VARIANT_VARARG
	var return_type :Variant = fd.return_type()
	if return_type is StringName:
		return TEMPLATE_RETURN_VARIANT
	return TEMPLATE_RETURN_VOID if (return_type == TYPE_NIL or return_type == GdObjects.TYPE_VOID) else TEMPLATE_RETURN_VARIANT

const __INSTANCE_ID = "${instance_id}"
const __SOURCE_CLASS = "${source_class}"

var __instance_delegator :Object
var __excluded_methods :PackedStringArray = []


static func __instance() -> Variant:
	return Engine.get_meta(__INSTANCE_ID)


func _notification(what :int) -> void:
	if what == NOTIFICATION_PREDELETE:
		if Engine.has_meta(__INSTANCE_ID):
			Engine.remove_meta(__INSTANCE_ID)


func __instance_id() -> String:
	return __INSTANCE_ID


func __set_singleton(delegator :Object) -> void:
	# store self need to mock static functions
	Engine.set_meta(__INSTANCE_ID, self)
	__instance_delegator = delegator


func __release_double() -> void:
	# we need to release the self reference manually to prevent orphan nodes
	Engine.remove_meta(__INSTANCE_ID)
	__instance_delegator = null


func __do_call_real_func(func_name :String) -> bool:
	return not __excluded_methods.has(func_name)


func __exclude_method_call(exluded_methods :PackedStringArray) -> void:
	__excluded_methods.append_array(exluded_methods)


func __call_func(func_name :String, arguments :Array) -> Variant:
	return __instance_delegator.callv(func_name, arguments)
@tool
extends Control

const GdUnitUpdateClient = preload("res://addons/gdUnit4/src/update/GdUnitUpdateClient.gd")
const TITLE = "gdUnit4 ${version} Console"

@onready var header := $VBoxContainer/Header
@onready var title: RichTextLabel = $VBoxContainer/Header/header_title
@onready var output: RichTextLabel = $VBoxContainer/Console/TextEdit

var _text_color: Color
var _function_color: Color
var _engine_type_color: Color
var _statistics := {}
var _summary := {
	"total_count": 0,
	"error_count": 0,
	"failed_count": 0,
	"skipped_count": 0,
	"flaky_count": 0,
	"orphan_nodes": 0
}


@warning_ignore("return_value_discarded")
func _ready() -> void:
	init_colors()
	GdUnitFonts.init_fonts(output)
	GdUnit4Version.init_version_label(title)
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	GdUnitSignals.instance().gdunit_message.connect(_on_gdunit_message)
	GdUnitSignals.instance().gdunit_client_connected.connect(_on_gdunit_client_connected)
	GdUnitSignals.instance().gdunit_client_disconnected.connect(_on_gdunit_client_disconnected)
	output.clear()


func _notification(what: int) -> void:
	if what == EditorSettings.NOTIFICATION_EDITOR_SETTINGS_CHANGED:
		init_colors()
	if what == NOTIFICATION_PREDELETE:
		var instance := GdUnitSignals.instance()
		if instance.gdunit_event.is_connected(_on_gdunit_event):
			instance.gdunit_event.disconnect(_on_gdunit_event)
		if instance.gdunit_message.is_connected(_on_gdunit_event):
			instance.gdunit_message.disconnect(_on_gdunit_message)
		if instance.gdunit_client_connected.is_connected(_on_gdunit_event):
			instance.gdunit_client_connected.disconnect(_on_gdunit_client_connected)
		if instance.gdunit_client_disconnected.is_connected(_on_gdunit_event):
			instance.gdunit_client_disconnected.disconnect(_on_gdunit_client_disconnected)


func init_colors() -> void:
	var settings := EditorInterface.get_editor_settings()
	_text_color = settings.get_setting("text_editor/theme/highlighting/text_color")
	_function_color = settings.get_setting("text_editor/theme/highlighting/function_color")
	_engine_type_color = settings.get_setting("text_editor/theme/highlighting/engine_type_color")


func init_statistics(event: GdUnitEvent) -> void:
	_statistics["total_count"] = event.total_count()
	_statistics["error_count"] = 0
	_statistics["failed_count"] = 0
	_statistics["skipped_count"] = 0
	_statistics["flaky_count"] = 0
	_statistics["orphan_nodes"] = 0
	_summary["total_count"] += event.total_count()


func reset_statistics() -> void:
	for k: String in _statistics.keys():
		_statistics[k] = 0
	for k: String in _summary.keys():
		_summary[k] = 0


func update_statistics(event: GdUnitEvent) -> void:
	_statistics["error_count"] += event.error_count()
	_statistics["failed_count"] += event.failed_count()
	_statistics["skipped_count"] += event.is_skipped() as int
	_statistics["flaky_count"] += event.is_flaky() as int
	_statistics["orphan_nodes"] += event.orphan_nodes()
	_summary["error_count"] += event.error_count()
	_summary["failed_count"] += event.failed_count()
	_summary["skipped_count"] += event.is_skipped() as int
	_summary["flaky_count"] += event.is_flaky() as int
	_summary["orphan_nodes"] += event.orphan_nodes()


func print_message(message: String, color: Color=_text_color, indent:=0) -> void:
	for i in indent:
		output.push_indent(1)
	output.push_color(color)
	output.append_text(message)
	output.pop()
	for i in indent:
		output.pop()


func println_message(message: String, color: Color=_text_color, indent:=-1) -> void:
	print_message(message, color, indent)
	output.newline()


func line_number(report: GdUnitReport) -> String:
	return str(report._line_number) if report._line_number != -1 else "<n/a>"


func setup_update_notification(control: Button) -> void:
	if not GdUnitSettings.is_update_notification_enabled():
		print_message("The search for updates is deactivated.", Color.CORNFLOWER_BLUE)
		return

	println_message("Searching for updates.", Color.CORNFLOWER_BLUE)
	var update_client := GdUnitUpdateClient.new()
	add_child(update_client)
	var response :GdUnitUpdateClient.HttpResponse = await update_client.request_latest_version()
	if response.status() != 200:
		println_message("Information cannot be retrieved from GitHub!", Color.INDIAN_RED)
		println_message("Error:  %s" % response.response(), Color.INDIAN_RED)
		return
	var latest_version := update_client.extract_latest_version(response)
	if not latest_version.is_greater(GdUnit4Version.current()):
		println_message("GdUnit4 is up-to-date.", Color.FOREST_GREEN)
		return

	println_message("A new update is available %s" % latest_version, Color.YELLOW)
	println_message("Open the GdUnit4 settings and check the update tab.", Color.YELLOW)

	control.icon = GdUnitUiTools.get_icon("Notification", Color.YELLOW)
	var tween :=create_tween()
	tween.tween_property(control, "self_modulate", Color.VIOLET, .2).set_trans(Tween.TransitionType.TRANS_LINEAR)
	tween.tween_property(control, "self_modulate", Color.YELLOW, .2).set_trans(Tween.TransitionType.TRANS_BOUNCE)
	tween.parallel()
	tween.tween_property(control, "scale", Vector2.ONE*1.05, .4).set_trans(Tween.TransitionType.TRANS_LINEAR)
	tween.tween_property(control, "scale", Vector2.ONE, .4).set_trans(Tween.TransitionType.TRANS_BOUNCE)
	tween.set_loops(-1)
	tween.play()


func _on_gdunit_event(event: GdUnitEvent) -> void:
	match event.type():
		GdUnitEvent.INIT:
			reset_statistics()

		GdUnitEvent.STOP:
			print_message("Summary:", Color.DODGER_BLUE)
			println_message("| %d total | %d error | %d failed | %d flaky | %d skipped | %d orphans |" %\
				[_summary["total_count"],
				_summary["error_count"],
				_summary["failed_count"],
				_summary["flaky_count"],
				_summary["skipped_count"],
				_summary["orphan_nodes"]],
				_text_color, 1)
			print_message("[wave][/wave]")

		GdUnitEvent.TESTSUITE_BEFORE:
			init_statistics(event)
			print_message("Execute: ", Color.DODGER_BLUE)
			println_message(event._suite_name, _engine_type_color)

		GdUnitEvent.TESTSUITE_AFTER:
			if not event.reports().is_empty():
				println_message("\t" + event._suite_name, _engine_type_color)
				for report: GdUnitReport in event.reports():
					println_message("line %s: %s" % [line_number(report), report._message], _text_color, 2)
			if event.is_success() and event.is_flaky():
				print_message("[wave]FLAKY[/wave]", Color.GREEN_YELLOW)
			elif event.is_success():
				print_message("[wave]PASSED[/wave]", Color.LIGHT_GREEN)
			else:
				print_message("[shake rate=5 level=10][b]FAILED[/b][/shake]", Color.FIREBRICK)
			print_message(" | %d total | %d error | %d failed | %d flaky | %d skipped | %d orphans |" %\
				[_statistics["total_count"],
				_statistics["error_count"],
				_statistics["failed_count"],
				_statistics["flaky_count"],
				_statistics["skipped_count"],
				_statistics["orphan_nodes"]])
			println_message("%+12s" % LocalTime.elapsed(event.elapsed_time()))
			println_message(" ")


		GdUnitEvent.TESTCASE_BEFORE:
			var spaces := "-%d" % (80 - event._suite_name.length())
			print_message(event._suite_name, _engine_type_color, 1)
			print_message(":")
			print_message(("%" + spaces + "s") % event._test_name, _function_color)

		GdUnitEvent.TESTCASE_AFTER:
			var reports := event.reports()
			if event.is_flaky() and event.is_success():
				var retries :int = event.statistic(GdUnitEvent.RETRY_COUNT)
				print_message("[wave]FLAKY[/wave] (%d retries)" % retries, Color.GREEN_YELLOW)
			elif event.is_success():
				print_message("PASSED", Color.LIGHT_GREEN)
			elif event.is_skipped():
				print_message("SKIPPED", Color.GOLDENROD)
			elif event.is_error() or event.is_failed():
				var retries :int = event.statistic(GdUnitEvent.RETRY_COUNT)
				if retries > 1:
					print_message("[wave]FAILED[/wave] (retry %d)" % retries, Color.FIREBRICK)
				else:
					print_message("[wave]FAILED[/wave]", Color.FIREBRICK)
			elif event.is_warning():
				print_message("WARNING", Color.YELLOW)
			println_message(" %+12s" % LocalTime.elapsed(event.elapsed_time()))

			for report: GdUnitReport in event.reports():
				println_message("line %s: %s" % [line_number(report), report._message], _text_color, 2)

		GdUnitEvent.TESTCASE_STATISTICS:
			update_statistics(event)


func _on_gdunit_client_connected(client_id: int) -> void:
	output.clear()
	output.append_text("[color=#9887c4]GdUnit Test Client connected with id %d[/color]\n" % client_id)
	output.newline()


func _on_gdunit_client_disconnected(client_id: int) -> void:
	output.append_text("[color=#9887c4]GdUnit Test Client disconnected with id %d[/color]\n" % client_id)
	output.newline()


func _on_gdunit_message(message: String) -> void:
	output.newline()
	output.append_text(message)
	output.newline()
class_name GdUnitFonts
extends RefCounted

const FONT_MONO = "res://addons/gdUnit4/src/update/assets/fonts/static/RobotoMono-Regular.ttf"
const FONT_MONO_BOLT = "res://addons/gdUnit4/src/update/assets/fonts/static/RobotoMono-Bold.ttf"
const FONT_MONO_BOLT_ITALIC = "res://addons/gdUnit4/src/update/assets/fonts/static/RobotoMono-BoldItalic.ttf"
const FONT_MONO_ITALIC = "res://addons/gdUnit4/src/update/assets/fonts/static/RobotoMono-Italic.ttf"


static func init_fonts(item: CanvasItem) -> float:
	# add a default fallback font
	item.set("theme_override_fonts/font", load_and_resize_font(FONT_MONO, 16))
	item.set("theme_override_fonts/normal_font", load_and_resize_font(FONT_MONO, 16))
	item.set("theme_override_font_sizes/font_size", 16)
	if Engine.is_editor_hint():
		var settings := EditorInterface.get_editor_settings()
		var scale_factor := EditorInterface.get_editor_scale()
		var font_size: float = settings.get_setting("interface/editor/main_font_size")
		font_size *= scale_factor
		var font_mono := load_and_resize_font(FONT_MONO, font_size)
		item.set("theme_override_fonts/normal_font", font_mono)
		item.set("theme_override_fonts/bold_font", load_and_resize_font(FONT_MONO_BOLT, font_size))
		item.set("theme_override_fonts/italics_font", load_and_resize_font(FONT_MONO_ITALIC, font_size))
		item.set("theme_override_fonts/bold_italics_font", load_and_resize_font(FONT_MONO_BOLT_ITALIC, font_size))
		item.set("theme_override_fonts/mono_font", font_mono)
		item.set("theme_override_font_sizes/font_size", font_size)
		item.set("theme_override_font_sizes/normal_font_size", font_size)
		item.set("theme_override_font_sizes/bold_font_size", font_size)
		item.set("theme_override_font_sizes/italics_font_size", font_size)
		item.set("theme_override_font_sizes/bold_italics_font_size", font_size)
		item.set("theme_override_font_sizes/mono_font_size", font_size)
		return font_size
	return 16.0


static func load_and_resize_font(font_resource: String, size: float) -> FontFile:
	var font: FontFile = ResourceLoader.load(font_resource, "FontFile")
	if font == null:
		push_error("Can't load font '%s'" % font_resource)
		return null
	var resized_font: FontFile = font.duplicate()
	resized_font.fixed_size = int(size)
	return resized_font
@tool
class_name GdUnitInspecor
extends Panel

const ScriptEditorContextMenuHandler = preload("res://addons/gdUnit4/src/ui/menu/ScriptEditorContextMenuHandler.gd")
const EditorFileSystemContextMenuHandler = preload("res://addons/gdUnit4/src/ui/menu/EditorFileSystemContextMenuHandler.gd")

var _command_handler := GdUnitCommandHandler.instance()


func _ready() -> void:
	if Engine.is_editor_hint():
		_getEditorThemes()
	@warning_ignore("return_value_discarded")
	GdUnitCommandHandler.instance().gdunit_runner_start.connect(func() -> void:
		var control :Control = get_parent_control()
		# if the tab is floating we dont need to set as current
		if control is TabContainer:
			var tab_container :TabContainer = control
			for tab_index in tab_container.get_tab_count():
				if tab_container.get_tab_title(tab_index) == "GdUnit":
					tab_container.set_current_tab(tab_index)
	)
	if Engine.is_editor_hint():
		add_script_editor_context_menu()
		add_file_system_dock_context_menu()


func _process(_delta: float) -> void:
	_command_handler._do_process()


func _getEditorThemes() -> void:
	# example to access current theme
	#var editiorTheme := interface.get_base_control().theme
	# setup inspector button icons
	#var stylebox_types :PackedStringArray = editiorTheme.get_stylebox_type_list()
	#for stylebox_type in stylebox_types:
		#prints("stylebox_type", stylebox_type)
	#	if "Tree" == stylebox_type:
	#		prints(editiorTheme.get_stylebox_list(stylebox_type))
	#var style:StyleBoxFlat = editiorTheme.get_stylebox("panel", "Tree")
	#style.bg_color = Color.RED
	#var locale = interface.get_editor_settings().get_setting("interface/editor/editor_language")
	#sessions_label.add_theme_color_override("font_color", get_color("contrast_color_2", "Editor"))
	#status_label.add_theme_color_override("font_color", get_color("contrast_color_2", "Editor"))
	#no_sessions_label.add_theme_color_override("font_color", get_color("contrast_color_2", "Editor"))
	pass


# Context menu registrations ----------------------------------------------------------------------
func add_file_system_dock_context_menu() -> void:
	var is_test_suite := func is_visible(script: Script, is_ts: bool) -> bool:
		if script == null:
			return false
		return GdObjects.is_test_suite(script) == is_ts
	var menu :Array[GdUnitContextMenuItem] = [
		GdUnitContextMenuItem.new(GdUnitContextMenuItem.MENU_ID.TEST_RUN, "Run Testsuites", "Play", is_test_suite.bind(true), _command_handler.command(GdUnitCommandHandler.CMD_RUN_TESTSUITE)),
		GdUnitContextMenuItem.new(GdUnitContextMenuItem.MENU_ID.TEST_DEBUG, "Debug Testsuites", "PlayStart", is_test_suite.bind(true), _command_handler.command(GdUnitCommandHandler.CMD_RUN_TESTSUITE_DEBUG)),
	]
	add_child(EditorFileSystemContextMenuHandler.new(menu))


func add_script_editor_context_menu() -> void:
	var is_test_suite := func is_visible(script: Script, is_ts: bool) -> bool:
		return GdObjects.is_test_suite(script) == is_ts
	var menu :Array[GdUnitContextMenuItem] = [
		GdUnitContextMenuItem.new(GdUnitContextMenuItem.MENU_ID.TEST_RUN, "Run Tests", "Play", is_test_suite.bind(true), _command_handler.command(GdUnitCommandHandler.CMD_RUN_TESTCASE)),
		GdUnitContextMenuItem.new(GdUnitContextMenuItem.MENU_ID.TEST_DEBUG, "Debug Tests", "PlayStart", is_test_suite.bind(true),_command_handler.command(GdUnitCommandHandler.CMD_RUN_TESTCASE_DEBUG)),
		GdUnitContextMenuItem.new(GdUnitContextMenuItem.MENU_ID.CREATE_TEST, "Create Test", "New", is_test_suite.bind(false), _command_handler.command(GdUnitCommandHandler.CMD_CREATE_TESTCASE))
	]
	add_child(ScriptEditorContextMenuHandler.new(menu))


func _on_MainPanel_run_testsuite(test_suite_paths: Array, debug: bool) -> void:
	_command_handler.cmd_run_test_suites(test_suite_paths, debug)


func _on_MainPanel_run_testcase(resource_path: String, test_case: String, test_param_index: int, debug: bool) -> void:
	_command_handler.cmd_run_test_case(resource_path, test_case, test_param_index, debug)


@warning_ignore("redundant_await")
func _on_status_bar_request_discover_tests() -> void:
	await _command_handler.cmd_discover_tests()
class_name GdUnitInspectorTreeConstants
extends RefCounted


# the inspector panel presantation
enum TREE_VIEW_MODE {
	TREE,
	FLAT
}


# The inspector sort modes
enum SORT_MODE {
	UNSORTED,
	NAME_ASCENDING,
	NAME_DESCENDING,
	EXECUTION_TIME
}
class_name GdUnitUiTools
extends RefCounted


static var _spinner: AnimatedTexture


enum ImageFlipMode {
	HORIZONTAl,
	VERITCAL
}


## Returns the icon by name, if it exists.
static func get_icon(icon_name: String, color: = Color.BLACK) -> Texture2D:
	if not Engine.is_editor_hint():
		return null
	var icon := EditorInterface.get_base_control().get_theme_icon(icon_name, "EditorIcons")
	if icon == null:
		return null
	if color != Color.BLACK:
		icon = _modulate_texture(icon, color)
	return icon


## Returns the icon flipped
static func get_flipped_icon(icon_name: String, mode: = ImageFlipMode.HORIZONTAl) -> Texture2D:
	if not Engine.is_editor_hint():
		return null
	var icon := EditorInterface.get_base_control().get_theme_icon(icon_name, "EditorIcons")
	if icon == null:
		return null
	return ImageTexture.create_from_image(_flip_image(icon, mode))


static func get_spinner() -> AnimatedTexture:
	if _spinner != null:
		return _spinner
	_spinner = AnimatedTexture.new()
	_spinner.frames = 8
	_spinner.speed_scale = 2.5
	for frame in _spinner.frames:
		_spinner.set_frame_texture(frame, get_icon("Progress%d" % (frame+1)))
		_spinner.set_frame_duration(frame, 0.2)
	return _spinner


static func get_color_animated_icon(icon_name :String, from :Color, to :Color) -> AnimatedTexture:
	var texture := AnimatedTexture.new()
	texture.frames = 8
	texture.speed_scale = 2.5
	var color := from
	for frame in texture.frames:
		color = lerp(color, to, .2)
		texture.set_frame_texture(frame, get_icon(icon_name, color))
		texture.set_frame_duration(frame, 0.2)
	return texture


static func get_run_overall_icon() -> Texture2D:
	if not Engine.is_editor_hint():
		return null
	var icon := EditorInterface.get_base_control().get_theme_icon("Play", "EditorIcons")
	var image := _merge_images(icon.get_image(), Vector2i(-2, 0), icon.get_image(), Vector2i(3, 0))
	return ImageTexture.create_from_image(image)


static func get_GDScript_icon(status: String, color: Color) -> Texture2D:
	if not Engine.is_editor_hint():
		return null
	var icon_a := EditorInterface.get_base_control().get_theme_icon("GDScript", "EditorIcons")
	var icon_b := EditorInterface.get_base_control().get_theme_icon(status, "EditorIcons")
	var overlay_image := _modulate_image(icon_b.get_image(), color)
	var image := _merge_images_scaled(icon_a.get_image(), Vector2i(0, 0), overlay_image, Vector2i(5, 5))
	return ImageTexture.create_from_image(image)


static func get_CSharpScript_icon(status: String, color: Color) -> Texture2D:
	if not Engine.is_editor_hint():
		return null
	var icon_a := EditorInterface.get_base_control().get_theme_icon("CSharpScript", "EditorIcons")
	var icon_b := EditorInterface.get_base_control().get_theme_icon(status, "EditorIcons")
	var overlay_image := _modulate_image(icon_b.get_image(), color)
	var image := _merge_images_scaled(icon_a.get_image(), Vector2i(0, 0), overlay_image, Vector2i(5, 5))
	return ImageTexture.create_from_image(image)


static func _modulate_texture(texture: Texture2D, color: Color) -> Texture2D:
	var image := _modulate_image(texture.get_image(), color)
	return ImageTexture.create_from_image(image)


static func _modulate_image(image: Image, color: Color) -> Image:
	var data: PackedByteArray = image.data["data"]
	for pixel in range(0, data.size(), 4):
		var pixel_a := _to_color(data, pixel)
		if pixel_a.a8 != 0:
			pixel_a = pixel_a.lerp(color, .9)
		data[pixel + 0] = pixel_a.r8
		data[pixel + 1] = pixel_a.g8
		data[pixel + 2] = pixel_a.b8
		data[pixel + 3] = pixel_a.a8
	var output_image := Image.new()
	output_image.set_data(image.get_width(), image.get_height(), image.has_mipmaps(), image.get_format(), data)
	return output_image


static func _merge_images(image1: Image, offset1: Vector2i, image2: Image, offset2: Vector2i) -> Image:
	## we need to fix the image to have the same size to avoid merge conflicts
	if image1.get_height() < image2.get_height():
		image1.resize(image2.get_width(), image2.get_height())
	# Create a new Image for the merged result
	var merged_image := Image.create(image1.get_width(), image1.get_height(), false, Image.FORMAT_RGBA8)
	merged_image.blit_rect_mask(image1, image2, Rect2(Vector2.ZERO, image1.get_size()), offset1)
	merged_image.blit_rect_mask(image1, image2, Rect2(Vector2.ZERO, image2.get_size()), offset2)
	return merged_image


@warning_ignore("narrowing_conversion")
static func _merge_images_scaled(image1: Image, offset1: Vector2i, image2: Image, offset2: Vector2i) -> Image:
	## we need to fix the image to have the same size to avoid merge conflicts
	if image1.get_height() < image2.get_height():
		image1.resize(image2.get_width(), image2.get_height())
	# Create a new Image for the merged result
	var merged_image := Image.create(image1.get_width(), image1.get_height(), false, image1.get_format())
	merged_image.blend_rect(image1, Rect2(Vector2.ZERO, image1.get_size()), offset1)
	image2.resize(image2.get_width()/1.3, image2.get_height()/1.3)
	merged_image.blend_rect(image2, Rect2(Vector2.ZERO, image2.get_size()), offset2)
	return merged_image


static func _flip_image(texture: Texture2D, mode: ImageFlipMode) -> Image:
	var flipped_image := Image.new()
	flipped_image.copy_from(texture.get_image())
	if mode == ImageFlipMode.VERITCAL:
		flipped_image.flip_x()
	else:
		flipped_image.flip_y()
	return flipped_image


static func _to_color(data: PackedByteArray, position: int) -> Color:
	var pixel_a := Color()
	pixel_a.r8 = data[position + 0]
	pixel_a.g8 = data[position + 1]
	pixel_a.b8 = data[position + 2]
	pixel_a.a8 = data[position + 3]
	return pixel_a
# A tool to provide extended script editor functionallity
class_name ScriptEditorControls
extends RefCounted

# https://github.com/godotengine/godot/blob/master/editor/plugins/script_editor_plugin.h
# the Editor menu popup items
enum {
	FILE_NEW,
	FILE_NEW_TEXTFILE,
	FILE_OPEN,
	FILE_REOPEN_CLOSED,
	FILE_OPEN_RECENT,
	FILE_SAVE,
	FILE_SAVE_AS,
	FILE_SAVE_ALL,
	FILE_THEME,
	FILE_RUN,
	FILE_CLOSE,
	CLOSE_DOCS,
	CLOSE_ALL,
	CLOSE_OTHER_TABS,
	TOGGLE_SCRIPTS_PANEL,
	SHOW_IN_FILE_SYSTEM,
	FILE_COPY_PATH,
	FILE_TOOL_RELOAD_SOFT,
	SEARCH_IN_FILES,
	REPLACE_IN_FILES,
	SEARCH_HELP,
	SEARCH_WEBSITE,
	HELP_SEARCH_FIND,
	HELP_SEARCH_FIND_NEXT,
	HELP_SEARCH_FIND_PREVIOUS,
	WINDOW_MOVE_UP,
	WINDOW_MOVE_DOWN,
	WINDOW_NEXT,
	WINDOW_PREV,
	WINDOW_SORT,
	WINDOW_SELECT_BASE = 100
}


# Saves the given script and closes if requested by <close=true>
# The script is saved when is opened in the editor.
# The script is closed when <close> is set to true.
static func save_an_open_script(script_path: String, close:=false) -> bool:
	#prints("save_an_open_script", script_path, close)
	if !Engine.is_editor_hint():
		return false
	var editor := EditorInterface.get_script_editor()
	var editor_popup := _menu_popup()
	# search for the script in all opened editor scrips
	for open_script in editor.get_open_scripts():
		if open_script.resource_path == script_path:
			# select the script in the editor
			EditorInterface.edit_script(open_script, 0);
			# save and close
			editor_popup.id_pressed.emit(FILE_SAVE)
			if close:
				editor_popup.id_pressed.emit(FILE_CLOSE)
			return true
	return false


# Saves all opened script
static func save_all_open_script() -> void:
	if Engine.is_editor_hint():
		_menu_popup().id_pressed.emit(FILE_SAVE_ALL)


static func close_open_editor_scripts() -> void:
	if Engine.is_editor_hint():
		_menu_popup().id_pressed.emit(CLOSE_ALL)


# Edits the given script.
# The script is openend in the current editor and selected in the file system dock.
# The line and column on which to open the script can also be specified.
# The script will be open with the user-configured editor for the script's language which may be an external editor.
static func edit_script(script_path: String, line_number := -1) -> void:
	var file_system := EditorInterface.get_resource_filesystem()
	file_system.update_file(script_path)
	var file_system_dock := EditorInterface.get_file_system_dock()
	file_system_dock.navigate_to_path(script_path)
	EditorInterface.select_file(script_path)
	var script: GDScript = load(script_path)
	EditorInterface.edit_script(script, line_number)


static func _menu_popup() -> PopupMenu:
	@warning_ignore("unsafe_method_access")
	return EditorInterface.get_script_editor().get_child(0).get_child(0).get_child(0).get_popup()


static func _print_menu(popup: PopupMenu) -> void:
	for itemIndex in popup.item_count:
		prints("get_item_id", popup.get_item_id(itemIndex))
		prints("get_item_accelerator", popup.get_item_accelerator(itemIndex))
		prints("get_item_shortcut", popup.get_item_shortcut(itemIndex))
		prints("get_item_text", popup.get_item_text(itemIndex))
		prints()
@tool
extends Control

var _context_menus := Dictionary()


func _init(context_menus: Array[GdUnitContextMenuItem]) -> void:
	set_name("EditorFileSystemContextMenuHandler")
	for menu in context_menus:
		_context_menus[menu.id] = menu
	var popup := _menu_popup()
	var file_tree := _file_tree()
	@warning_ignore("return_value_discarded")
	popup.about_to_popup.connect(on_context_menu_show.bind(popup, file_tree))
	@warning_ignore("return_value_discarded")
	popup.id_pressed.connect(on_context_menu_pressed.bind(file_tree))


func on_context_menu_show(context_menu: PopupMenu, file_tree: Tree) -> void:
	context_menu.add_separator()
	var current_index := context_menu.get_item_count()
	var selected_test_suites := collect_testsuites(_context_menus.values()[0] as GdUnitContextMenuItem, file_tree)

	for menu_id: int in _context_menus.keys():
		var menu_item: GdUnitContextMenuItem = _context_menus[menu_id]
		if selected_test_suites.size() != 0:
			context_menu.add_item(menu_item.name, menu_id)
			#context_menu.set_item_icon_modulate(current_index, Color.MEDIUM_PURPLE)
			context_menu.set_item_disabled(current_index, !menu_item.is_enabled(null))
			context_menu.set_item_icon(current_index, GdUnitUiTools.get_icon(menu_item.icon))
			current_index += 1


func on_context_menu_pressed(id: int, file_tree: Tree) -> void:
	if !_context_menus.has(id):
		return
	var menu_item: GdUnitContextMenuItem = _context_menus[id]
	var selected_test_suites := collect_testsuites(menu_item, file_tree)
	menu_item.execute([selected_test_suites])


func collect_testsuites(_menu_item: GdUnitContextMenuItem, file_tree: Tree) -> PackedStringArray:
	var file_system := EditorInterface.get_resource_filesystem()
	var selected_item := file_tree.get_selected()
	var selected_test_suites := PackedStringArray()

	while selected_item:
		var resource_path: String = selected_item.get_metadata(0)
		var file_type := file_system.get_file_type(resource_path)
		var is_dir := DirAccess.dir_exists_absolute(resource_path)
		if is_dir:
			@warning_ignore("return_value_discarded")
			selected_test_suites.append(resource_path)
		elif is_dir or file_type == "GDScript" or file_type == "CSharpScript":
			# find a performant way to check if the selected item a testsuite
			var resource := ResourceLoader.load(resource_path, "Script", ResourceLoader.CACHE_MODE_REUSE)
			if _menu_item.is_visible(resource):
				@warning_ignore("return_value_discarded")
				selected_test_suites.append(resource_path)
		selected_item = file_tree.get_next_selected(selected_item)
	return selected_test_suites


func _file_tree() -> Tree:
	return GdObjects.find_nodes_by_class(EditorInterface.get_file_system_dock(), "Tree", true)[-1]


func _menu_popup() -> PopupMenu:
	return GdObjects.find_nodes_by_class(EditorInterface.get_file_system_dock(), "PopupMenu")[-1]
class_name GdUnitContextMenuItem

enum MENU_ID {
	UNDEFINED = 0,
	TEST_RUN = 1000,
	TEST_DEBUG = 1001,
	TEST_RERUN = 1002,
	CREATE_TEST = 1010,
}

var id: MENU_ID = MENU_ID.UNDEFINED:
	set(value):
		id = value
	get:
		return id

var name: StringName:
	set(value):
		name = value
	get:
		return name

var command: GdUnitCommand:
	set(value):
		command = value
	get:
		return command

var visible: Callable:
	set(value):
		visible = value
	get:
		return visible

var icon: String:
	set(value):
		icon = value
	get:
		return icon


func _init(p_id: MENU_ID, p_name: StringName, p_icon :String, p_is_visible: Callable, p_command: GdUnitCommand) -> void:
	assert(p_id != null, "(%s) missing parameter 'MENU_ID'" % p_name)
	assert(p_is_visible != null, "(%s) missing parameter 'GdUnitCommand'" % p_name)
	assert(p_command != null, "(%s) missing parameter 'GdUnitCommand'" % p_name)
	self.id = p_id
	self.name = p_name
	self.icon = p_icon
	self.command = p_command
	self.visible = p_is_visible


func shortcut() -> Shortcut:
	return GdUnitCommandHandler.instance().get_shortcut(command.shortcut)


func is_enabled(script: Script) -> bool:
	return command.is_enabled.call(script)


func is_visible(script: Script) -> bool:
	return visible.call(script)


func execute(arguments:=[]) -> void:
	if arguments.is_empty():
		command.runnable.call()
	else:
		command.runnable.callv(arguments)
@tool
extends Control

var _context_menus := Dictionary()
var _editor: ScriptEditor


func _init(context_menus: Array[GdUnitContextMenuItem]) -> void:
	set_name("ScriptEditorContextMenuHandler")
	for menu in context_menus:
		_context_menus[menu.id] = menu
	_editor = EditorInterface.get_script_editor()
	@warning_ignore("return_value_discarded")
	_editor.editor_script_changed.connect(on_script_changed)
	on_script_changed(active_script())


func _input(event: InputEvent) -> void:
	if event is InputEventKey and event.is_pressed():
		for action: GdUnitContextMenuItem in _context_menus.values():
			if action.shortcut().matches_event(event) and action.is_visible(active_script()):
				#if not has_editor_focus():
				#	return
				action.execute()
				accept_event()
				return


func has_editor_focus() -> bool:
	return (Engine.get_main_loop() as SceneTree).root.gui_get_focus_owner() == active_base_editor()


func on_script_changed(script: Script) -> void:
	if script is Script:
		var popups: Array[Node] = GdObjects.find_nodes_by_class(active_editor(), "PopupMenu", true)
		for popup: PopupMenu in popups:
			if not popup.about_to_popup.is_connected(on_context_menu_show):
				popup.about_to_popup.connect(on_context_menu_show.bind(script, popup))
			if not popup.id_pressed.is_connected(on_context_menu_pressed):
				popup.id_pressed.connect(on_context_menu_pressed)


func on_context_menu_show(script: Script, context_menu: PopupMenu) -> void:
	#prints("on_context_menu_show", _context_menus.keys(), context_menu, self)
	context_menu.add_separator()
	var current_index := context_menu.get_item_count()
	for menu_id: int in _context_menus.keys():
		var menu_item: GdUnitContextMenuItem = _context_menus[menu_id]
		if menu_item.is_visible(script):
			context_menu.add_item(menu_item.name, menu_id)
			context_menu.set_item_disabled(current_index, !menu_item.is_enabled(script))
			context_menu.set_item_shortcut(current_index, menu_item.shortcut(), true)
			current_index += 1


func on_context_menu_pressed(id: int) -> void:
	if !_context_menus.has(id):
		return
	var menu_item: GdUnitContextMenuItem = _context_menus[id]
	menu_item.execute()


func active_editor() -> ScriptEditorBase:
	return _editor.get_current_editor()


func active_base_editor() -> TextEdit:
	return active_editor().get_base_editor()


func active_script() -> Script:
	return _editor.get_current_script()
@tool
extends PanelContainer

signal jump_to_orphan_nodes()

@onready var ICON_GREEN := GdUnitUiTools.get_icon("Unlinked", Color.WEB_GREEN)
@onready var ICON_RED := GdUnitUiTools.get_color_animated_icon("Unlinked", Color.YELLOW, Color.ORANGE_RED)

@onready var _button_time: Button = %btn_time
@onready var _time: Label = %time_value
@onready var _orphans: Label = %orphan_value
@onready var _orphan_button: Button = %btn_orphan

var total_elapsed_time := 0
var total_orphans := 0


func _ready() -> void:
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	_time.text = ""
	_orphans.text = "0"
	_button_time.icon = GdUnitUiTools.get_icon("Time")
	_orphan_button.icon = ICON_GREEN


func status_changed(elapsed_time: int, orphan_nodes: int) -> void:
	total_elapsed_time += elapsed_time
	total_orphans += orphan_nodes
	_time.text = LocalTime.elapsed(total_elapsed_time)
	_orphans.text = str(total_orphans)
	if total_orphans > 0:
		_orphan_button.icon = ICON_RED


func _on_gdunit_event(event: GdUnitEvent) -> void:
	match event.type():
		GdUnitEvent.INIT:
			_orphan_button.icon = ICON_GREEN
			total_elapsed_time = 0
			total_orphans = 0
			status_changed(0, 0)
		GdUnitEvent.TESTCASE_BEFORE:
			pass
		GdUnitEvent.TESTCASE_AFTER:
			status_changed(0, event.orphan_nodes())
		GdUnitEvent.TESTSUITE_BEFORE:
			pass
		GdUnitEvent.TESTSUITE_AFTER:
			status_changed(event.elapsed_time(), event.orphan_nodes())


func _on_ToolButton_pressed() -> void:
	jump_to_orphan_nodes.emit()
@tool
extends ProgressBar

@onready var status: Label = $Label
@onready var style: StyleBoxFlat = get("theme_override_styles/fill")


func _ready() -> void:
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	style.bg_color = Color.DARK_GREEN
	value = 0
	max_value = 0
	update_text()


func progress_init(p_max_value: int) -> void:
	value = 0
	max_value = p_max_value
	style.bg_color = Color.DARK_GREEN
	update_text()


func progress_update(p_value: int, is_failed: bool) -> void:
	value += p_value
	update_text()
	if is_failed:
		style.bg_color = Color.DARK_RED


func update_text() -> void:
	status.text = "%d:%d" % [value, max_value]


func _on_gdunit_event(event: GdUnitEvent) -> void:
	match event.type():
		GdUnitEvent.INIT:
			progress_init(event.total_count())

		GdUnitEvent.DISCOVER_END:
			progress_init(event.total_count())

		GdUnitEvent.TESTCASE_STATISTICS:
			progress_update(1, event.is_failed() or event.is_error())

		GdUnitEvent.TESTSUITE_AFTER:
			progress_update(0, event.is_failed() or event.is_error())
@tool
extends PanelContainer

signal select_failure_next()
signal select_failure_prevous()
signal select_error_next()
signal select_error_prevous()
signal select_flaky_next()
signal select_flaky_prevous()
signal request_discover_tests()

@warning_ignore("unused_signal")
signal tree_view_mode_changed(flat :bool)

@onready var _errors: Label = %error_value
@onready var _failures: Label = %failure_value
@onready var _flaky_value: Label = %flaky_value
@onready var _button_failure_up: Button = %btn_failure_up
@onready var _button_failure_down: Button = %btn_failure_down
@onready var _button_sync: Button = %btn_tree_sync
@onready var _button_view_mode: Button = %btn_tree_mode
@onready var _button_sort_mode: Button = %btn_tree_sort

@onready var _icon_errors: TextureRect = %icon_errors
@onready var _icon_failures: TextureRect = %icon_failures
@onready var _icon_flaky: TextureRect = %icon_flaky

var total_failed := 0
var total_errors := 0
var total_flaky := 0


var icon_mappings := {
	# tree sort modes
	0x100 + GdUnitInspectorTreeConstants.SORT_MODE.UNSORTED : GdUnitUiTools.get_icon("TripleBar"),
	0x100 + GdUnitInspectorTreeConstants.SORT_MODE.NAME_ASCENDING : GdUnitUiTools.get_icon("Sort"),
	0x100 + GdUnitInspectorTreeConstants.SORT_MODE.NAME_DESCENDING : GdUnitUiTools.get_flipped_icon("Sort"),
	0x100 + GdUnitInspectorTreeConstants.SORT_MODE.EXECUTION_TIME : GdUnitUiTools.get_icon("History"),
	# tree view modes
	0x200 + GdUnitInspectorTreeConstants.TREE_VIEW_MODE.TREE : GdUnitUiTools.get_icon("Tree", Color.GHOST_WHITE),
	0x200 + GdUnitInspectorTreeConstants.TREE_VIEW_MODE.FLAT : GdUnitUiTools.get_icon("AnimationTrackGroup", Color.GHOST_WHITE)
}


@warning_ignore("return_value_discarded")
func _ready() -> void:
	_failures.text = "0"
	_errors.text = "0"
	_icon_failures.texture = GdUnitUiTools.get_icon("StatusError", Color.SKY_BLUE)
	_icon_errors.texture = GdUnitUiTools.get_icon("StatusError", Color.DARK_RED)
	_icon_flaky.texture = GdUnitUiTools.get_icon("CheckBox", Color.GREEN_YELLOW)

	_button_failure_up.icon = GdUnitUiTools.get_icon("ArrowUp")
	_button_failure_down.icon = GdUnitUiTools.get_icon("ArrowDown")
	_button_sync.icon = GdUnitUiTools.get_icon("Loop")
	_set_sort_mode_menu_options()
	_set_view_mode_menu_options()
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	GdUnitSignals.instance().gdunit_settings_changed.connect(_on_settings_changed)
	var command_handler := GdUnitCommandHandler.instance()
	command_handler.gdunit_runner_start.connect(_on_gdunit_runner_start)
	command_handler.gdunit_runner_stop.connect(_on_gdunit_runner_stop)



func _set_sort_mode_menu_options() -> void:
	_button_sort_mode.icon = GdUnitUiTools.get_icon("Sort")
	# construct context sort menu according to the available modes
	var context_menu :PopupMenu = _button_sort_mode.get_popup()
	context_menu.clear()

	if not context_menu.index_pressed.is_connected(_on_sort_mode_changed):
		@warning_ignore("return_value_discarded")
		context_menu.index_pressed.connect(_on_sort_mode_changed)

	var configured_sort_mode := GdUnitSettings.get_inspector_tree_sort_mode()
	for sort_mode: String in GdUnitInspectorTreeConstants.SORT_MODE.keys():
		var enum_value :int =  GdUnitInspectorTreeConstants.SORT_MODE.get(sort_mode)
		var icon :Texture2D = icon_mappings[0x100 + enum_value]
		context_menu.add_icon_check_item(icon, normalise(sort_mode), enum_value)
		context_menu.set_item_checked(enum_value, configured_sort_mode == enum_value)


func _set_view_mode_menu_options() -> void:
	_button_view_mode.icon = GdUnitUiTools.get_icon("Tree", Color.GHOST_WHITE)
	# construct context tree view menu according to the available modes
	var context_menu :PopupMenu = _button_view_mode.get_popup()
	context_menu.clear()

	if not context_menu.index_pressed.is_connected(_on_tree_view_mode_changed):
		@warning_ignore("return_value_discarded")
		context_menu.index_pressed.connect(_on_tree_view_mode_changed)

	var configured_tree_view_mode := GdUnitSettings.get_inspector_tree_view_mode()
	for tree_view_mode: String in GdUnitInspectorTreeConstants.TREE_VIEW_MODE.keys():
		var enum_value :int =  GdUnitInspectorTreeConstants.TREE_VIEW_MODE.get(tree_view_mode)
		var icon :Texture2D = icon_mappings[0x200 + enum_value]
		context_menu.add_icon_check_item(icon, normalise(tree_view_mode), enum_value)
		context_menu.set_item_checked(enum_value, configured_tree_view_mode == enum_value)


func normalise(value: String) -> String:
	var parts := value.to_lower().split("_")
	parts[0] = parts[0].capitalize()
	return " ".join(parts)


func status_changed(errors: int, failed: int, flaky: int) -> void:
	total_failed += failed
	total_errors += errors
	total_flaky += flaky
	_failures.text = str(total_failed)
	_errors.text = str(total_errors)
	_flaky_value.text = str(total_flaky)


func disable_buttons(value :bool) -> void:
	_button_sync.set_disabled(value)
	_button_sort_mode.set_disabled(value)
	_button_view_mode.set_disabled(value)


func _on_gdunit_event(event: GdUnitEvent) -> void:
	match event.type():
		GdUnitEvent.DISCOVER_START:
			disable_buttons(true)

		GdUnitEvent.DISCOVER_END:
			disable_buttons(false)

		GdUnitEvent.INIT:
			total_failed = 0
			total_errors = 0
			total_flaky = 0
			status_changed(0, 0, 0)
		GdUnitEvent.TESTCASE_BEFORE:
			pass
		GdUnitEvent.TESTCASE_STATISTICS:
			if event.is_error():
				status_changed(event.error_count(), 0, event.is_flaky())
			else:
				status_changed(0, event.failed_count(), event.is_flaky())
		GdUnitEvent.TESTSUITE_BEFORE:
			pass
		GdUnitEvent.TESTSUITE_AFTER:
			if event.is_error():
				status_changed(event.error_count(), 0, 0)
			else:
				status_changed(0, event.failed_count(), 0)


func _on_btn_error_up_pressed() -> void:
	select_error_prevous.emit()


func _on_btn_error_down_pressed() -> void:
	select_error_next.emit()


func _on_failure_up_pressed() -> void:
	select_failure_prevous.emit()


func _on_failure_down_pressed() -> void:
	select_failure_next.emit()


func _on_btn_flaky_up_pressed() -> void:
	select_flaky_prevous.emit()


func _on_btn_flaky_down_pressed() -> void:
	select_flaky_next.emit()


func _on_tree_sync_pressed() -> void:
	request_discover_tests.emit()


func _on_sort_mode_changed(index: int) -> void:
	var selected_sort_mode :GdUnitInspectorTreeConstants.SORT_MODE = GdUnitInspectorTreeConstants.SORT_MODE.values()[index]
	GdUnitSettings.set_inspector_tree_sort_mode(selected_sort_mode)


func _on_tree_view_mode_changed(index: int) ->void:
	var selected_tree_mode :GdUnitInspectorTreeConstants.TREE_VIEW_MODE = GdUnitInspectorTreeConstants.TREE_VIEW_MODE.values()[index]
	GdUnitSettings.set_inspector_tree_view_mode(selected_tree_mode)


################################################################################
# external signal receiver
################################################################################
func _on_gdunit_runner_start() -> void:
	disable_buttons(true)


func _on_gdunit_runner_stop(_client_id: int) -> void:
	disable_buttons(false)


func _on_settings_changed(property :GdUnitProperty) -> void:
	if property.name() == GdUnitSettings.INSPECTOR_TREE_SORT_MODE:
		_set_sort_mode_menu_options()
	if property.name() == GdUnitSettings.INSPECTOR_TREE_VIEW_MODE:
		_set_view_mode_menu_options()
@tool
extends PanelContainer

signal run_overall_pressed(debug: bool)
signal run_pressed(debug: bool)
signal stop_pressed()

@onready var _version_label: Control = %version
@onready var _button_wiki: Button = %help
@onready var _tool_button: Button = %tool
@onready var _button_run_overall: Button = %run_overall
@onready var _button_run: Button = %run
@onready var _button_run_debug: Button = %debug
@onready var _button_stop: Button = %stop



const SETTINGS_SHORTCUT_MAPPING := {
	GdUnitSettings.SHORTCUT_INSPECTOR_RERUN_TEST: GdUnitShortcut.ShortCut.RERUN_TESTS,
	GdUnitSettings.SHORTCUT_INSPECTOR_RERUN_TEST_DEBUG: GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG,
	GdUnitSettings.SHORTCUT_INSPECTOR_RUN_TEST_OVERALL: GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL,
	GdUnitSettings.SHORTCUT_INSPECTOR_RUN_TEST_STOP: GdUnitShortcut.ShortCut.STOP_TEST_RUN,
}


@warning_ignore("return_value_discarded")
func _ready() -> void:
	GdUnit4Version.init_version_label(_version_label)
	var command_handler := GdUnitCommandHandler.instance()
	run_pressed.connect(command_handler._on_run_pressed)
	run_overall_pressed.connect(command_handler._on_run_overall_pressed)
	stop_pressed.connect(command_handler._on_stop_pressed)
	command_handler.gdunit_runner_start.connect(_on_gdunit_runner_start)
	command_handler.gdunit_runner_stop.connect(_on_gdunit_runner_stop)
	GdUnitSignals.instance().gdunit_settings_changed.connect(_on_gdunit_settings_changed)
	init_buttons()
	init_shortcuts(command_handler)



func init_buttons() -> void:
	_button_run_overall.icon = GdUnitUiTools.get_run_overall_icon()
	_button_run_overall.visible = GdUnitSettings.is_inspector_toolbar_button_show()
	_button_run.icon = GdUnitUiTools.get_icon("Play")
	_button_run_debug.icon = GdUnitUiTools.get_icon("PlayStart")
	_button_stop.icon = GdUnitUiTools.get_icon("Stop")
	_tool_button.icon = GdUnitUiTools.get_icon("Tools")
	_button_wiki.icon = GdUnitUiTools.get_icon("HelpSearch")


func init_shortcuts(command_handler: GdUnitCommandHandler) -> void:
	_button_run.shortcut = command_handler.get_shortcut(GdUnitShortcut.ShortCut.RERUN_TESTS)
	_button_run_overall.shortcut = command_handler.get_shortcut(GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL)
	_button_run_debug.shortcut = command_handler.get_shortcut(GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG)
	_button_stop.shortcut = command_handler.get_shortcut(GdUnitShortcut.ShortCut.STOP_TEST_RUN)
	# register for shortcut changes
	@warning_ignore("return_value_discarded")
	GdUnitSignals.instance().gdunit_settings_changed.connect(_on_settings_changed.bind(command_handler))


func _on_runoverall_pressed(debug:=false) -> void:
	run_overall_pressed.emit(debug)


func _on_run_pressed(debug := false) -> void:
	run_pressed.emit(debug)


func _on_stop_pressed() -> void:
	stop_pressed.emit()


func _on_gdunit_runner_start() -> void:
	_button_run_overall.disabled = true
	_button_run.disabled = true
	_button_run_debug.disabled = true
	_button_stop.disabled = false


func _on_gdunit_runner_stop(_client_id: int) -> void:
	_button_run_overall.disabled = false
	_button_run.disabled = false
	_button_run_debug.disabled = false
	_button_stop.disabled = true


func _on_gdunit_settings_changed(_property: GdUnitProperty) -> void:
	_button_run_overall.visible = GdUnitSettings.is_inspector_toolbar_button_show()


func _on_wiki_pressed() -> void:
	@warning_ignore("return_value_discarded")
	OS.shell_open("https://mikeschulze.github.io/gdUnit4/")


func _on_btn_tool_pressed() -> void:
	var settings_dlg: Window = EditorInterface.get_base_control().find_child("GdUnitSettingsDialog", false, false)
	if settings_dlg == null:
		settings_dlg = preload("res://addons/gdUnit4/src/ui/settings/GdUnitSettingsDialog.tscn").instantiate()
		EditorInterface.get_base_control().add_child(settings_dlg, true)
	settings_dlg.popup_centered_ratio(.60)


func _on_settings_changed(property: GdUnitProperty, command_handler: GdUnitCommandHandler) -> void:
	# needs to wait a frame to be command handler notified first for settings changes
	await get_tree().process_frame
	if SETTINGS_SHORTCUT_MAPPING.has(property.name()):
		var shortcut: GdUnitShortcut.ShortCut = SETTINGS_SHORTCUT_MAPPING.get(property.name(), GdUnitShortcut.ShortCut.NONE)
		match shortcut:
			GdUnitShortcut.ShortCut.RERUN_TESTS:
				_button_run.shortcut = command_handler.get_shortcut(shortcut)
			GdUnitShortcut.ShortCut.RUN_TESTS_OVERALL:
				_button_run_overall.shortcut = command_handler.get_shortcut(shortcut)
			GdUnitShortcut.ShortCut.RERUN_TESTS_DEBUG:
				_button_run_debug.shortcut = command_handler.get_shortcut(shortcut)
			GdUnitShortcut.ShortCut.STOP_TEST_RUN:
				_button_stop.shortcut = command_handler.get_shortcut(shortcut)
@tool
extends VSplitContainer

signal run_testcase(test_suite_resource_path: String, test_case: String, test_param_index: int, run_debug: bool)
signal run_testsuite()

const CONTEXT_MENU_RUN_ID = 0
const CONTEXT_MENU_DEBUG_ID = 1
const CONTEXT_MENU_COLLAPSE_ALL = 3
const CONTEXT_MENU_EXPAND_ALL = 4


@onready var _tree: Tree = $Panel/Tree
@onready var _report_list: Node = $report/ScrollContainer/list
@onready var _report_template: RichTextLabel = $report/report_template
@onready var _context_menu: PopupMenu = $contextMenu
@onready var _discover_hint: Control = %discover_hint
@onready var _spinner: Button = %spinner

# loading tree icons
@onready var ICON_SPINNER := GdUnitUiTools.get_spinner()
@onready var ICON_FOLDER := GdUnitUiTools.get_icon("Folder")
# gdscript icons
@onready var ICON_GDSCRIPT_TEST_DEFAULT := GdUnitUiTools.get_icon("GDScript", Color.LIGHT_GRAY)
@onready var ICON_GDSCRIPT_TEST_SUCCESS := GdUnitUiTools.get_GDScript_icon("StatusSuccess", Color.DARK_GREEN)
@onready var ICON_GDSCRIPT_TEST_FLAKY := GdUnitUiTools.get_GDScript_icon("CheckBox", Color.GREEN_YELLOW)
@onready var ICON_GDSCRIPT_TEST_FAILED := GdUnitUiTools.get_GDScript_icon("StatusError", Color.SKY_BLUE)
@onready var ICON_GDSCRIPT_TEST_ERROR := GdUnitUiTools.get_GDScript_icon("StatusError", Color.DARK_RED)
@onready var ICON_GDSCRIPT_TEST_SUCCESS_ORPHAN := GdUnitUiTools.get_GDScript_icon("Unlinked", Color.DARK_GREEN)
@onready var ICON_GDSCRIPT_TEST_FAILED_ORPHAN := GdUnitUiTools.get_GDScript_icon("Unlinked", Color.SKY_BLUE)
@onready var ICON_GDSCRIPT_TEST_ERRORS_ORPHAN := GdUnitUiTools.get_GDScript_icon("Unlinked", Color.DARK_RED)
# csharp script icons
@onready var ICON_CSSCRIPT_TEST_DEFAULT := GdUnitUiTools.get_icon("CSharpScript", Color.LIGHT_GRAY)
@onready var ICON_CSSCRIPT_TEST_SUCCESS := GdUnitUiTools.get_CSharpScript_icon("StatusSuccess", Color.DARK_GREEN)
@onready var ICON_CSSCRIPT_TEST_FAILED := GdUnitUiTools.get_CSharpScript_icon("StatusError", Color.SKY_BLUE)
@onready var ICON_CSSCRIPT_TEST_ERROR := GdUnitUiTools.get_CSharpScript_icon("StatusError", Color.DARK_RED)
@onready var ICON_CSSCRIPT_TEST_SUCCESS_ORPHAN := GdUnitUiTools.get_CSharpScript_icon("Unlinked", Color.DARK_GREEN)
@onready var ICON_CSSCRIPT_TEST_FAILED_ORPHAN := GdUnitUiTools.get_CSharpScript_icon("Unlinked", Color.SKY_BLUE)
@onready var ICON_CSSCRIPT_TEST_ERRORS_ORPHAN := GdUnitUiTools.get_CSharpScript_icon("Unlinked", Color.DARK_RED)


enum GdUnitType {
	FOLDER,
	TEST_SUITE,
	TEST_CASE,
	TEST_CASE_PARAMETERIZED
}


enum STATE {
	INITIAL,
	RUNNING,
	SUCCESS,
	WARNING,
	FLAKY,
	FAILED,
	ERROR,
	ABORDED,
	SKIPPED
}

const META_GDUNIT_ORIGINAL_INDEX = "gdunit_original_index"
const META_GDUNIT_NAME := "gdUnit_name"
const META_GDUNIT_STATE := "gdUnit_state"
const META_GDUNIT_TYPE := "gdUnit_type"
const META_GDUNIT_TOTAL_TESTS := "gdUnit_suite_total_tests"
const META_GDUNIT_SUCCESS_TESTS := "gdUnit_suite_success_tests"
const META_GDUNIT_REPORT := "gdUnit_report"
const META_GDUNIT_ORPHAN := "gdUnit_orphan"
const META_GDUNIT_EXECUTION_TIME := "gdUnit_execution_time"
const META_RESOURCE_PATH := "resource_path"
const META_LINE_NUMBER := "line_number"
const META_SCRIPT_PATH := "script_path"
const META_TEST_PARAM_INDEX := "test_param_index"

var _tree_root: TreeItem
var _item_hash := Dictionary()
var _tree_view_mode_flat := GdUnitSettings.get_inspector_tree_view_mode() == GdUnitInspectorTreeConstants.TREE_VIEW_MODE.FLAT


func _build_cache_key(resource_path: String, test_name: String) -> Array:
	return [resource_path, test_name]


func get_tree_item(resource_path: String, item_name: String) -> TreeItem:
	var key := _build_cache_key(resource_path, item_name)
	return _item_hash.get(key, null)


func remove_tree_item(resource_path: String, item_name: String) -> bool:
	var key := _build_cache_key(resource_path, item_name)
	var item :TreeItem= _item_hash.get(key, null)
	if item:
		item.get_parent().remove_child(item)
		item.free()
		return _item_hash.erase(key)
	return false


func add_tree_item_to_cache(resource_path: String, test_name: String, item: TreeItem) -> void:
	var key := _build_cache_key(resource_path, test_name)
	_item_hash[key] = item


func clear_tree_item_cache() -> void:
	_item_hash.clear()


func _find_by_resource_path(current: TreeItem, resource_path: String) -> TreeItem:
	for item in current.get_children():
		if item.get_meta(META_RESOURCE_PATH) == resource_path:
			return item
	return null


func _find_first_item_by_state(parent: TreeItem, item_state: STATE, reverse := false) -> TreeItem:
	var itmes := parent.get_children()
	if reverse:
		itmes.reverse()
	for item in itmes:
		if is_test_case(item) and (is_item_state(item, item_state)):
			return item
		var failure_item := _find_first_item_by_state(item, item_state, reverse)
		if failure_item != null:
			return failure_item
	return null


func _find_last_item_by_state(parent: TreeItem, item_state: STATE) -> TreeItem:
	return _find_first_item_by_state(parent, item_state, true)


func _find_item_by_state(current: TreeItem, item_state: STATE, prev := false) -> TreeItem:
	var next := current.get_prev_in_tree() if prev else current.get_next_in_tree()
	if next == null or next == _tree_root:
		return null
	if is_test_case(next) and is_item_state(next, item_state):
		return next
	return _find_item_by_state(next, item_state, prev)


func is_item_state(item: TreeItem, item_state: STATE) -> bool:
	return item.has_meta(META_GDUNIT_STATE) and item.get_meta(META_GDUNIT_STATE) == item_state


func is_state_running(item: TreeItem) -> bool:
	return is_item_state(item, STATE.RUNNING)


func is_state_success(item: TreeItem) -> bool:
	return is_item_state(item, STATE.SUCCESS)


func is_state_warning(item: TreeItem) -> bool:
	return is_item_state(item, STATE.WARNING)


func is_state_failed(item: TreeItem) -> bool:
	return is_item_state(item, STATE.FAILED)


func is_state_error(item: TreeItem) -> bool:
	return is_item_state(item, STATE.ERROR) or is_item_state(item, STATE.ABORDED)


func is_item_state_orphan(item: TreeItem) -> bool:
	return item.has_meta(META_GDUNIT_ORPHAN)


func is_test_suite(item: TreeItem) -> bool:
	return item.has_meta(META_GDUNIT_TYPE) and item.get_meta(META_GDUNIT_TYPE) == GdUnitType.TEST_SUITE


func is_test_case(item: TreeItem) -> bool:
	return item.has_meta(META_GDUNIT_TYPE) and item.get_meta(META_GDUNIT_TYPE) == GdUnitType.TEST_CASE


func is_folder(item: TreeItem) -> bool:
	return item.has_meta(META_GDUNIT_TYPE) and item.get_meta(META_GDUNIT_TYPE) == GdUnitType.FOLDER


@warning_ignore("return_value_discarded")
func _ready() -> void:
	_context_menu.set_item_icon(CONTEXT_MENU_RUN_ID, GdUnitUiTools.get_icon("Play"))
	_context_menu.set_item_icon(CONTEXT_MENU_DEBUG_ID, GdUnitUiTools.get_icon("PlayStart"))
	_context_menu.set_item_icon(CONTEXT_MENU_EXPAND_ALL, GdUnitUiTools.get_icon("ExpandTree"))
	_context_menu.set_item_icon(CONTEXT_MENU_COLLAPSE_ALL, GdUnitUiTools.get_icon("CollapseTree"))
	# do colorize the icons
	#for index in _context_menu.item_count:
	#	_context_menu.set_item_icon_modulate(index, Color.MEDIUM_PURPLE)

	_spinner.icon = GdUnitUiTools.get_spinner()
	init_tree()
	GdUnitSignals.instance().gdunit_settings_changed.connect(_on_settings_changed)
	GdUnitSignals.instance().gdunit_add_test_suite.connect(do_add_test_suite)
	GdUnitSignals.instance().gdunit_event.connect(_on_gdunit_event)
	var command_handler := GdUnitCommandHandler.instance()
	command_handler.gdunit_runner_start.connect(_on_gdunit_runner_start)
	command_handler.gdunit_runner_stop.connect(_on_gdunit_runner_stop)


# we need current to manually redraw bacause of the animation bug
# https://github.com/godotengine/godot/issues/69330
func _process(_delta: float) -> void:
	if is_visible_in_tree():
		queue_redraw()


func init_tree() -> void:
	cleanup_tree()
	_tree.set_hide_root(true)
	_tree.ensure_cursor_is_visible()
	_tree.set_allow_reselect(true)
	_tree.set_allow_rmb_select(true)
	_tree.set_columns(2)
	_tree.set_column_clip_content(0, true)
	_tree.set_column_expand_ratio(0, 1)
	_tree.set_column_custom_minimum_width(0, 240)
	_tree.set_column_expand_ratio(1, 0)
	_tree.set_column_custom_minimum_width(1, 100)
	_tree_root = _tree.create_item()
	# fix tree icon scaling
	var scale_factor := EditorInterface.get_editor_scale() if Engine.is_editor_hint() else 1.0
	_tree.set("theme_override_constants/icon_max_width", 16 * scale_factor)


func cleanup_tree() -> void:
	clear_reports()
	clear_tree_item_cache()
	if not _tree_root:
		return
	_free_recursive()
	_tree.clear()


func _free_recursive(items:=_tree_root.get_children()) -> void:
	for item in items:
		_free_recursive(item.get_children())
		item.call_deferred("free")


func sort_tree_items(parent :TreeItem) -> void:
	parent.visible = false
	var items := parent.get_children()

	# do sort by selected sort mode
	match GdUnitSettings.get_inspector_tree_sort_mode():
		GdUnitInspectorTreeConstants.SORT_MODE.UNSORTED:
			items.sort_custom(sort_items_by_original_index)

		GdUnitInspectorTreeConstants.SORT_MODE.NAME_ASCENDING:
			items.sort_custom(sort_items_by_name.bind(true))

		GdUnitInspectorTreeConstants.SORT_MODE.NAME_DESCENDING:
			items.sort_custom(sort_items_by_name.bind(false))

		GdUnitInspectorTreeConstants.SORT_MODE.EXECUTION_TIME:
			items.sort_custom(sort_items_by_execution_time)

	for item in items:
		parent.remove_child(item)
		parent.add_child(item)
		if item.get_child_count() > 0:
			sort_tree_items(item)
	parent.visible = true
	_tree.queue_redraw()


func sort_items_by_name(a: TreeItem, b: TreeItem, ascending: bool) -> bool:
	var type_a: GdUnitType = a.get_meta(META_GDUNIT_TYPE)
	var type_b: GdUnitType = b.get_meta(META_GDUNIT_TYPE)
	 # Compare types first
	if type_a != type_b:
		return type_a == GdUnitType.FOLDER
	var name_a :String = a.get_meta(META_GDUNIT_NAME)
	var name_b :String = b.get_meta(META_GDUNIT_NAME)
	return name_a.naturalnocasecmp_to(name_b) < 0 if ascending else name_a.naturalnocasecmp_to(name_b) > 0


func sort_items_by_execution_time(a: TreeItem, b: TreeItem) -> bool:
	var type_a: GdUnitType = a.get_meta(META_GDUNIT_TYPE)
	var type_b: GdUnitType = b.get_meta(META_GDUNIT_TYPE)
	 # Compare types first
	if type_a != type_b:
		return type_a == GdUnitType.FOLDER
	var execution_time_a :int = a.get_meta(META_GDUNIT_EXECUTION_TIME)
	var execution_time_b :int = b.get_meta(META_GDUNIT_EXECUTION_TIME)
	# if has same execution time sort by name
	if execution_time_a == execution_time_b:
		var name_a :String = a.get_meta(META_GDUNIT_NAME)
		var name_b :String = b.get_meta(META_GDUNIT_NAME)
		return name_a.naturalnocasecmp_to(name_b) > 0
	return execution_time_a > execution_time_b


func sort_items_by_original_index(a: TreeItem, b: TreeItem) -> bool:
	var type_a: GdUnitType = a.get_meta(META_GDUNIT_TYPE)
	var type_b: GdUnitType = b.get_meta(META_GDUNIT_TYPE)
	if type_a != type_b:
		return type_a == GdUnitType.FOLDER
	var index_a :int = a.get_meta(META_GDUNIT_ORIGINAL_INDEX)
	var index_b :int = b.get_meta(META_GDUNIT_ORIGINAL_INDEX)
	return index_a < index_b


func reset_tree_state(parent: TreeItem) -> void:
	for item in parent.get_children():
		set_state_initial(item)
		reset_tree_state(item)


func select_item(item: TreeItem) -> TreeItem:
	if item != null:
		# enshure the parent is collapsed
		do_collapse_parent(item)
		item.select(0)
		_tree.ensure_cursor_is_visible()
		_tree.scroll_to_item(item, true)
	return item


func do_collapse_parent(item: TreeItem) -> void:
	if item != null:
		item.collapsed = false
		do_collapse_parent(item.get_parent())


func do_collapse_all(collapse: bool, parent := _tree_root) -> void:
	for item in parent.get_children():
		item.collapsed = collapse
		if not collapse:
			do_collapse_all(collapse, item)


func set_state_initial(item: TreeItem) -> void:
	item.set_custom_color(0, Color.LIGHT_GRAY)
	item.set_tooltip_text(0, "")
	item.set_text_overrun_behavior(0, TextServer.OVERRUN_TRIM_CHAR)
	item.set_expand_right(0, true)

	item.set_custom_color(1, Color.LIGHT_GRAY)
	item.set_text(1, "")
	item.set_expand_right(1, true)
	item.set_tooltip_text(1, "")

	item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
	item.set_meta(META_GDUNIT_SUCCESS_TESTS, 0)
	item.remove_meta(META_GDUNIT_REPORT)
	item.remove_meta(META_GDUNIT_ORPHAN)
	set_item_icon_by_state(item)
	init_item_counter(item)


func set_state_running(item: TreeItem) -> void:
	if is_state_running(item):
		return
	item.set_custom_color(0, Color.DARK_GREEN)
	item.set_custom_color(1, Color.DARK_GREEN)
	item.set_icon(0, ICON_SPINNER)
	item.set_meta(META_GDUNIT_STATE, STATE.RUNNING)
	item.collapsed = false
	var parent := item.get_parent()
	if parent != _tree_root:
		set_state_running(parent)
	# force scrolling to current test case
	@warning_ignore("return_value_discarded")
	select_item(item)


func set_state_succeded(item: TreeItem) -> void:
	item.set_custom_color(0, Color.GREEN)
	item.set_custom_color(1, Color.GREEN)
	item.set_meta(META_GDUNIT_STATE, STATE.SUCCESS)
	item.collapsed = GdUnitSettings.is_inspector_node_collapse()
	set_item_icon_by_state(item)


func set_state_flaky(item: TreeItem, event: GdUnitEvent) -> void:
	# Do not overwrite higher states
	if is_state_error(item):
		return
	var retry_count := event.statistic(GdUnitEvent.RETRY_COUNT)
	item.set_meta(META_GDUNIT_STATE, STATE.FLAKY)
	if retry_count > 1:
		item.set_text(0, "%s (%s retries)" % [
			item.get_meta(META_GDUNIT_NAME),
			retry_count])
	item.set_custom_color(0, Color.GREEN_YELLOW)
	item.set_custom_color(1, Color.GREEN_YELLOW)
	item.collapsed = false
	set_item_icon_by_state(item)


func set_state_skipped(item: TreeItem) -> void:
	item.set_meta(META_GDUNIT_STATE, STATE.SKIPPED)
	item.set_text(1, "(skipped)")
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	item.set_custom_color(0, Color.DARK_GRAY)
	item.set_custom_color(1, Color.DARK_GRAY)
	item.collapsed = false
	set_item_icon_by_state(item)


func set_state_warnings(item: TreeItem) -> void:
	# Do not overwrite higher states
	if is_state_error(item) or is_state_failed(item):
		return
	item.set_meta(META_GDUNIT_STATE, STATE.WARNING)
	item.set_custom_color(0, Color.YELLOW)
	item.set_custom_color(1, Color.YELLOW)
	item.collapsed = false
	set_item_icon_by_state(item)


func set_state_failed(item: TreeItem, event: GdUnitEvent) -> void:
	# Do not overwrite higher states
	if is_state_error(item):
		return
	var retry_count := event.statistic(GdUnitEvent.RETRY_COUNT)
	if retry_count > 1:
		item.set_text(0, "%s (%s retries)" % [
			item.get_meta(META_GDUNIT_NAME),
			retry_count])
	item.set_meta(META_GDUNIT_STATE, STATE.FAILED)
	item.set_custom_color(0, Color.LIGHT_BLUE)
	item.set_custom_color(1, Color.LIGHT_BLUE)
	item.collapsed = false
	set_item_icon_by_state(item)


func set_state_error(item: TreeItem) -> void:
	item.set_meta(META_GDUNIT_STATE, STATE.ERROR)
	item.set_custom_color(0, Color.ORANGE_RED)
	item.set_custom_color(1, Color.ORANGE_RED)
	set_item_icon_by_state(item)
	item.collapsed = false


func set_state_aborted(item: TreeItem) -> void:
	item.set_meta(META_GDUNIT_STATE, STATE.ABORDED)
	item.set_custom_color(0, Color.ORANGE_RED)
	item.set_custom_color(1, Color.ORANGE_RED)
	item.clear_custom_bg_color(0)
	item.set_text(1, "(aborted)")
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	set_item_icon_by_state(item)
	item.collapsed = false


func set_state_orphan(item: TreeItem, event: GdUnitEvent) -> void:
	var orphan_count := event.statistic(GdUnitEvent.ORPHAN_NODES)
	if orphan_count == 0:
		return
	if item.has_meta(META_GDUNIT_ORPHAN):
		orphan_count += item.get_meta(META_GDUNIT_ORPHAN)
	item.set_meta(META_GDUNIT_ORPHAN, orphan_count)
	if item.get_meta(META_GDUNIT_STATE) != STATE.FAILED:
		item.set_custom_color(0, Color.YELLOW)
		item.set_custom_color(1, Color.YELLOW)
	item.set_tooltip_text(0, "Total <%d> orphan nodes detected." % orphan_count)
	set_item_icon_by_state(item)


func update_state(item: TreeItem, event: GdUnitEvent, add_reports := true) -> void:
	# we do not show the root
	if item == _tree_root:
		return

	if event.is_success() and event.is_flaky():
		set_state_flaky(item, event)
	elif event.is_success():
		set_state_succeded(item)
	elif event.is_skipped():
		set_state_skipped(item)
	elif event.is_error():
		set_state_error(item)
	elif event.is_failed():
		set_state_failed(item, event)
	elif event.is_warning():
		set_state_warnings(item)
	if add_reports:
		for report in event.reports():
			add_report(item, report)
	set_state_orphan(item, event)
	if is_folder(item):
		update_state(item.get_parent(), event, false)


func add_report(item: TreeItem, report: GdUnitReport) -> void:
	var reports: Array[GdUnitReport] = []
	if item.has_meta(META_GDUNIT_REPORT):
		reports = get_item_reports(item)
	reports.append(report)
	item.set_meta(META_GDUNIT_REPORT, reports)


func abort_running(items:=_tree_root.get_children()) -> void:
	for item in items:
		if is_state_running(item):
			set_state_aborted(item)
			abort_running(item.get_children())


func select_first_failure() -> TreeItem:
	return select_item(_find_first_item_by_state(_tree_root, STATE.FAILED))


func _on_select_next_item_by_state(item_state: int) -> TreeItem:
	var current_selected := _tree.get_selected()
	# If nothing is selected, the first error is selected or the next one in the vicinity of the current selection is found
	current_selected = _find_first_item_by_state(_tree_root, item_state) if current_selected == null else _find_item_by_state(current_selected, item_state)
	# If no next failure found, then we try to select first
	if current_selected == null:
		current_selected = _find_first_item_by_state(_tree_root, item_state)
	return select_item(current_selected)


func _on_select_previous_item_by_state(item_state: int) -> TreeItem:
	var current_selected := _tree.get_selected()
	# If nothing is selected, the first error is selected or the next one in the vicinity of the current selection is found
	current_selected = _find_last_item_by_state(_tree_root, item_state) if current_selected == null else _find_item_by_state(current_selected, item_state, true)
	# If no next failure found, then we try to select first last
	if current_selected == null:
		current_selected = _find_last_item_by_state(_tree_root, item_state)
	return select_item(current_selected)


func select_first_orphan() -> void:
	for parent in _tree_root.get_children():
		if not is_state_success(parent):
			for item in parent.get_children():
				if is_item_state_orphan(item):
					parent.set_collapsed(false)
					@warning_ignore("return_value_discarded")
					select_item(item)
					return


func clear_reports() -> void:
	for child in _report_list.get_children():
		_report_list.remove_child(child)
		child.queue_free()


func show_failed_report(selected_item: TreeItem) -> void:
	clear_reports()
	if selected_item == null or not selected_item.has_meta(META_GDUNIT_REPORT):
		return
	# add new reports
	for report in get_item_reports(selected_item):
		var reportNode: RichTextLabel = _report_template.duplicate()
		_report_list.add_child(reportNode)
		reportNode.append_text(report.to_string())
		reportNode.visible = true


func update_test_suite(event: GdUnitEvent) -> void:
	var item := get_tree_item(extract_resource_path(event), event.suite_name())
	if not item:
		push_error("Internal Error: Can't find test suite %s" % event.suite_name())
		return
	if event.type() == GdUnitEvent.TESTSUITE_BEFORE:
		set_state_running(item)
		return
	if event.type() == GdUnitEvent.TESTSUITE_AFTER:
		update_item_counter(item)
		update_item_elapsed_time_counter(item, event.elapsed_time())

	update_state(item, event)
	update_state(item.get_parent(), event, false)


func update_test_case(event: GdUnitEvent) -> void:
	var item := get_tree_item(extract_resource_path(event), event.test_name())
	if not item:
		push_error("Internal Error: Can't find test case %s:%s" % [event.suite_name(), event.test_name()])
		return
	if event.type() == GdUnitEvent.TESTCASE_BEFORE:
		set_state_running(item)
		return
	if event.type() == GdUnitEvent.TESTCASE_AFTER:
		update_item_elapsed_time_counter(item, event.elapsed_time())
		if event.is_success() or event.is_warning():
			update_item_counter(item)
	update_state(item, event)


func create_tree_item(test_suite: GdUnitTestSuiteDto) -> TreeItem:
	var parent := _tree_root
	var test_root_folder := GdUnitSettings.test_root_folder()
	var resource_path := ProjectSettings.localize_path(test_suite.path())
	var test_base_path := "res://"
	var test_relative_path := resource_path
	if resource_path.contains(test_root_folder):
		var path_elements := resource_path.split(test_root_folder)
		test_base_path = path_elements[0] + "/" + test_root_folder
		test_relative_path = path_elements[1]
	test_relative_path = test_relative_path.replace("res://", "")

	if _tree_view_mode_flat:
		var element := test_relative_path.get_base_dir().trim_prefix("/")
		if element.is_empty():
			return _tree.create_item(parent)
		test_base_path += "/" + element
		parent = create_or_find_item(parent, test_base_path, element)
		return _tree.create_item(parent)

	var elements := test_relative_path.split("/")
	if elements[0] == "res://" or elements[0] == "":
		elements.remove_at(0)
	if elements.size() > 0:
		elements.remove_at(elements.size() - 1)
	for element in elements:
		test_base_path += "/" + element
		parent = create_or_find_item(parent, test_base_path, element)
	return _tree.create_item(parent)


func create_or_find_item(parent: TreeItem, resource_path: String, item_name: String) -> TreeItem:
	var item := _find_by_resource_path(parent, resource_path)
	if item != null:
		return item
	item = _tree.create_item(parent)
	item.set_meta(META_GDUNIT_ORIGINAL_INDEX, item.get_index())
	item.set_text(0, item_name)
	item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
	item.set_meta(META_GDUNIT_NAME, item_name)
	item.set_meta(META_GDUNIT_TYPE, GdUnitType.FOLDER)
	item.set_meta(META_RESOURCE_PATH, resource_path)
	item.set_meta(META_GDUNIT_TOTAL_TESTS, 0)
	item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
	set_item_icon_by_state(item)
	item.collapsed = true
	return item


func create_item(parent: TreeItem, resource_path: String, item_name: String, type: GdUnitType) -> TreeItem:
	var item := _tree.create_item(parent)
	item.set_meta(META_GDUNIT_ORIGINAL_INDEX, item.get_index())
	item.set_text(0, item_name)
	item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
	item.set_meta(META_GDUNIT_NAME, item_name)
	item.set_meta(META_GDUNIT_TYPE, type)
	item.set_meta(META_RESOURCE_PATH, resource_path)
	item.set_meta(META_GDUNIT_TOTAL_TESTS, 0)
	item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
	set_item_icon_by_state(item)
	item.collapsed = true
	return item


func set_item_icon_by_state(item :TreeItem) -> void:
	var resource_path :String = item.get_meta(META_RESOURCE_PATH)
	var state :STATE = item.get_meta(META_GDUNIT_STATE)
	var is_orphan := is_item_state_orphan(item)
	item.set_icon(0, get_icon_by_file_type(resource_path, state, is_orphan))
	if item.get_meta(META_GDUNIT_TYPE) == GdUnitType.FOLDER:
		item.set_icon_modulate(0, Color.SKY_BLUE)


func init_item_counter(item: TreeItem) -> void:
	if item.has_meta(META_GDUNIT_TOTAL_TESTS) and item.get_meta(META_GDUNIT_TOTAL_TESTS) > 0:
		item.set_text(0, "(0/%s) %s" % [
			item.get_meta(META_GDUNIT_TOTAL_TESTS),
			item.get_meta(META_GDUNIT_NAME)])
	init_folder_counter(item.get_parent())


func increment_item_counter(item: TreeItem, increment_count: int) -> void:
	if item != _tree_root and item.get_meta(META_GDUNIT_TOTAL_TESTS) != 0:
		var count: int = item.get_meta(META_GDUNIT_SUCCESS_TESTS)
		item.set_meta(META_GDUNIT_SUCCESS_TESTS, count + increment_count)
		item.set_text(0, "(%s/%s) %s" % [
			item.get_meta(META_GDUNIT_SUCCESS_TESTS),
			item.get_meta(META_GDUNIT_TOTAL_TESTS),
			item.get_meta(META_GDUNIT_NAME)])
		if is_folder(item):
			increment_item_counter(item.get_parent(), increment_count)


func init_folder_counter(item: TreeItem) -> void:
	if item == _tree_root:
		return
	var type :GdUnitType = item.get_meta(META_GDUNIT_TYPE)
	if type == GdUnitType.FOLDER:
		var count :int = item.get_children().reduce(count_tests_total, 0)
		item.set_meta(META_GDUNIT_TOTAL_TESTS, count)
		item.set_meta(META_GDUNIT_SUCCESS_TESTS, 0)
		item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
		init_item_counter(item)


func count_tests_total(accum: int, item: TreeItem) -> int:
	return accum + item.get_meta(META_GDUNIT_TOTAL_TESTS)


func update_item_counter(item: TreeItem) -> void:
	if item == _tree_root:
		return
	var type :GdUnitType = item.get_meta(META_GDUNIT_TYPE)
	match type:
		GdUnitType.TEST_CASE:
			increment_item_counter(item.get_parent(), 1)
		GdUnitType.TEST_CASE_PARAMETERIZED:
			increment_item_counter(item.get_parent(), 1)
		GdUnitType.TEST_SUITE:
			var count: int = item.get_meta(META_GDUNIT_SUCCESS_TESTS)
			increment_item_counter(item.get_parent(), count)


func update_item_elapsed_time_counter(item: TreeItem, time: int) -> void:
	item.set_text(1, "%s" % LocalTime.elapsed(time))
	item.set_text_alignment(1, HORIZONTAL_ALIGNMENT_RIGHT)
	item.set_meta(META_GDUNIT_EXECUTION_TIME, time)

	var parent := item.get_parent()
	if parent == _tree_root:
		return
	var elapsed_time :int = parent.get_meta(META_GDUNIT_EXECUTION_TIME) + time
	var type :GdUnitType = item.get_meta(META_GDUNIT_TYPE)
	match type:
		GdUnitType.TEST_CASE:
			return
		GdUnitType.TEST_SUITE:
			update_item_elapsed_time_counter(parent, elapsed_time)
		#GdUnitType.FOLDER:
		#	update_item_elapsed_time_counter(parent, elapsed_time)


func get_icon_by_file_type(path: String, state: STATE, orphans: bool) -> Texture2D:
	if path.get_extension() == "gd":
		match state:
			STATE.INITIAL:
				return ICON_GDSCRIPT_TEST_DEFAULT
			STATE.SUCCESS:
				return ICON_GDSCRIPT_TEST_SUCCESS_ORPHAN if orphans else ICON_GDSCRIPT_TEST_SUCCESS
			STATE.ERROR:
				return ICON_GDSCRIPT_TEST_ERRORS_ORPHAN if orphans else ICON_GDSCRIPT_TEST_ERROR
			STATE.FAILED:
				return ICON_GDSCRIPT_TEST_FAILED_ORPHAN if orphans else ICON_GDSCRIPT_TEST_FAILED
			STATE.WARNING:
				return ICON_GDSCRIPT_TEST_SUCCESS_ORPHAN if orphans else ICON_GDSCRIPT_TEST_DEFAULT
			STATE.FLAKY:
				return ICON_GDSCRIPT_TEST_SUCCESS_ORPHAN if orphans else ICON_GDSCRIPT_TEST_FLAKY
			_:
				return ICON_GDSCRIPT_TEST_DEFAULT
	if path.get_extension() == "cs":
		match state:
			STATE.INITIAL:
				return ICON_CSSCRIPT_TEST_DEFAULT
			STATE.SUCCESS:
				return ICON_CSSCRIPT_TEST_SUCCESS_ORPHAN if orphans else ICON_CSSCRIPT_TEST_SUCCESS
			STATE.ERROR:
				return ICON_CSSCRIPT_TEST_ERRORS_ORPHAN if orphans else ICON_CSSCRIPT_TEST_ERROR
			STATE.FAILED:
				return ICON_CSSCRIPT_TEST_FAILED_ORPHAN if orphans else ICON_CSSCRIPT_TEST_FAILED
			STATE.WARNING:
				return ICON_CSSCRIPT_TEST_SUCCESS_ORPHAN if orphans else ICON_CSSCRIPT_TEST_DEFAULT
			_:
				return ICON_CSSCRIPT_TEST_DEFAULT
	match state:
		STATE.INITIAL:
			return ICON_FOLDER
		STATE.ERROR:
			return ICON_FOLDER
		STATE.FAILED:
			return ICON_FOLDER
		_:
			return ICON_FOLDER


func discover_test_suite_added(event: GdUnitEventTestDiscoverTestSuiteAdded) -> void:
	# Check first if the test suite already exists
	var item := get_tree_item(extract_resource_path(event), event.suite_name())
	if item != null:
		return
	# Otherwise create it
	prints("Discovered test suite added: '%s' on %s" % [event.suite_name(), extract_resource_path(event)])
	do_add_test_suite(event.suite_dto())


func discover_test_added(event: GdUnitEventTestDiscoverTestAdded) -> void:
	# check if the test already exists
	var test_name := event.test_case_dto().name()
	var resource_path := extract_resource_path(event)
	var item := get_tree_item(resource_path, test_name)
	if item != null:
		return

	item = get_tree_item(resource_path, event.suite_name())
	if not item:
		push_error("Internal Error: Can't find test suite %s:%s" % [event.suite_name(), resource_path])
		return
	prints("Discovered test added: '%s' on %s" % [event.test_name(), resource_path])
	# update test case count
	var test_count :int = item.get_meta(META_GDUNIT_TOTAL_TESTS)
	item.set_meta(META_GDUNIT_TOTAL_TESTS, test_count + 1)
	init_item_counter(item)
	# add new discovered test
	add_test(item, event.test_case_dto())


func discover_test_removed(event: GdUnitEventTestDiscoverTestRemoved) -> void:
	var resource_path := extract_resource_path(event)
	prints("Discovered test removed: '%s' on %s" % [event.test_name(), resource_path])
	var item := get_tree_item(resource_path, event.test_name())
	if not item:
		push_error("Internal Error: Can't find test suite %s:%s" % [event.suite_name(), resource_path])
		return
	# update test case count on test suite
	var parent := item.get_parent()
	var test_count :int = parent.get_meta(META_GDUNIT_TOTAL_TESTS)
	parent.set_meta(META_GDUNIT_TOTAL_TESTS, test_count - 1)
	init_item_counter(parent)
	# finally remove the test
	@warning_ignore("return_value_discarded")
	remove_tree_item(resource_path, event.test_name())


func do_add_test_suite(test_suite: GdUnitTestSuiteDto) -> void:
	var item := create_tree_item(test_suite)
	var suite_name := test_suite.name()
	var resource_path := ProjectSettings.localize_path(test_suite.path())
	item.set_text(0, suite_name)
	item.set_meta(META_GDUNIT_ORIGINAL_INDEX, item.get_index())
	item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
	item.set_meta(META_GDUNIT_NAME, suite_name)
	item.set_meta(META_GDUNIT_TYPE, GdUnitType.TEST_SUITE)
	item.set_meta(META_GDUNIT_TOTAL_TESTS, test_suite.test_case_count())
	item.set_meta(META_GDUNIT_SUCCESS_TESTS, 0)
	item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
	item.set_meta(META_RESOURCE_PATH, resource_path)
	item.set_meta(META_LINE_NUMBER, 1)
	item.collapsed = true
	set_item_icon_by_state(item)
	init_item_counter(item)
	add_tree_item_to_cache(resource_path, suite_name, item)
	for test_case in test_suite.test_cases():
		add_test(item, test_case)


func add_test(parent: TreeItem, test_case: GdUnitTestCaseDto) -> void:
	var item := _tree.create_item(parent)
	var test_name := test_case.name()
	var resource_path :String = parent.get_meta(META_RESOURCE_PATH)
	var test_case_names := test_case.test_case_names()

	item.set_meta(META_GDUNIT_ORIGINAL_INDEX, item.get_index())
	item.set_text(0, test_name)
	item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
	item.set_meta(META_GDUNIT_NAME, test_name)
	item.set_meta(META_GDUNIT_TYPE, GdUnitType.TEST_CASE)
	item.set_meta(META_RESOURCE_PATH, resource_path)
	item.set_meta(META_GDUNIT_SUCCESS_TESTS, 0)
	item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
	item.set_meta(META_GDUNIT_TOTAL_TESTS, test_case_names.size())
	item.set_meta(META_SCRIPT_PATH, test_case.script_path())
	item.set_meta(META_LINE_NUMBER, test_case.line_number())
	item.set_meta(META_TEST_PARAM_INDEX, -1)
	set_item_icon_by_state(item)
	init_item_counter(item)
	add_tree_item_to_cache(resource_path, test_name, item)
	if not test_case_names.is_empty():
		add_test_cases(item, test_case_names)


func add_test_cases(parent: TreeItem, test_case_names: PackedStringArray) -> void:
	for index in test_case_names.size():
		var item := _tree.create_item(parent)
		var test_case_name := test_case_names[index]
		var resource_path :String = parent.get_meta(META_RESOURCE_PATH)
		item.set_meta(META_GDUNIT_ORIGINAL_INDEX, item.get_index())
		item.set_text(0, test_case_name)
		item.set_meta(META_GDUNIT_STATE, STATE.INITIAL)
		item.set_meta(META_GDUNIT_NAME, test_case_name)
		item.set_meta(META_GDUNIT_TOTAL_TESTS, 0)
		item.set_meta(META_GDUNIT_TYPE, GdUnitType.TEST_CASE_PARAMETERIZED)
		item.set_meta(META_GDUNIT_EXECUTION_TIME, 0)
		item.set_meta(META_RESOURCE_PATH, resource_path)
		item.set_meta(META_SCRIPT_PATH, parent.get_meta(META_SCRIPT_PATH))
		item.set_meta(META_LINE_NUMBER, parent.get_meta(META_LINE_NUMBER))
		item.set_meta(META_TEST_PARAM_INDEX, index)
		set_item_icon_by_state(item)
		add_tree_item_to_cache(resource_path, test_case_name, item)


func get_item_reports(item: TreeItem) -> Array[GdUnitReport]:
	return item.get_meta(META_GDUNIT_REPORT)


func _dump_tree_as_json(dump_name: String) -> void:
	var dict := _to_json(_tree_root)
	var file := FileAccess.open("res://%s.json" % dump_name, FileAccess.WRITE)
	file.store_string(JSON.stringify(dict, "\t"))


func _to_json(parent :TreeItem) -> Dictionary:
	var item_as_dict := GdObjects.obj2dict(parent)
	item_as_dict["TreeItem"]["childs"] = parent.get_children().map(func(item: TreeItem) -> Dictionary:
			return _to_json(item))
	return item_as_dict


func extract_resource_path(event: GdUnitEvent) -> String:
	return ProjectSettings.localize_path(event.resource_path())


################################################################################
# Tree signal receiver
################################################################################
func _on_tree_item_mouse_selected(mouse_position: Vector2, mouse_button_index: int) -> void:
	if mouse_button_index == MOUSE_BUTTON_RIGHT:
		_context_menu.position = get_screen_position() + mouse_position
		_context_menu.popup()


func _on_run_pressed(run_debug: bool) -> void:
	_context_menu.hide()
	var item: = _tree.get_selected()
	if item == null:
		print_rich("[color=GOLDENROD]Abort Testrun, no test suite selected![/color]")
		return
	if item.get_meta(META_GDUNIT_TYPE) == GdUnitType.TEST_SUITE or item.get_meta(META_GDUNIT_TYPE) == GdUnitType.FOLDER:
		var resource_path: String = item.get_meta(META_RESOURCE_PATH)
		run_testsuite.emit([resource_path], run_debug)
		return
	var parent := item.get_parent()
	var test_suite_resource_path: String = parent.get_meta(META_RESOURCE_PATH)
	var test_case: String = item.get_meta(META_GDUNIT_NAME)
	# handle parameterized test selection
	var test_param_index: int = item.get_meta(META_TEST_PARAM_INDEX)
	if test_param_index != -1:
		test_case = parent.get_meta(META_GDUNIT_NAME)
	run_testcase.emit(test_suite_resource_path, test_case, test_param_index, run_debug)


func _on_Tree_item_selected() -> void:
	# only show report checked manual item selection
	# we need to check the run mode here otherwise it will be called every selection
	if not _context_menu.is_item_disabled(CONTEXT_MENU_RUN_ID):
		var selected_item: TreeItem = _tree.get_selected()
		show_failed_report(selected_item)


# Opens the test suite
func _on_Tree_item_activated() -> void:
	var selected_item := _tree.get_selected()
	if selected_item != null and selected_item.has_meta(META_LINE_NUMBER):
		var script_path: String = (
			selected_item.get_meta(META_RESOURCE_PATH) if is_test_suite(selected_item)
			else selected_item.get_meta(META_SCRIPT_PATH)
		)
		var line_number: int = selected_item.get_meta(META_LINE_NUMBER)
		var resource: Script = load(script_path)

		if selected_item.has_meta(META_GDUNIT_REPORT):
			var reports := get_item_reports(selected_item)
			var report_line_number := reports[0].line_number()
			# if number -1 we use original stored line number of the test case
			# in non debug mode the line number is not available
			if report_line_number != -1:
				line_number = report_line_number

		EditorInterface.get_file_system_dock().navigate_to_path(script_path)
		EditorInterface.edit_script(resource, line_number)
	elif selected_item.get_meta(META_GDUNIT_TYPE) == GdUnitType.FOLDER:
		# Toggle collapse if dir
		selected_item.collapsed = not selected_item.collapsed


################################################################################
# external signal receiver
################################################################################
func _on_gdunit_runner_start() -> void:
	reset_tree_state(_tree_root)
	_context_menu.set_item_disabled(CONTEXT_MENU_RUN_ID, true)
	_context_menu.set_item_disabled(CONTEXT_MENU_DEBUG_ID, true)
	clear_reports()


func _on_gdunit_runner_stop(_client_id: int) -> void:
	_context_menu.set_item_disabled(CONTEXT_MENU_RUN_ID, false)
	_context_menu.set_item_disabled(CONTEXT_MENU_DEBUG_ID, false)
	abort_running()
	sort_tree_items(_tree_root)
	# wait until the tree redraw
	await get_tree().process_frame
	@warning_ignore("return_value_discarded")
	select_first_failure()


func _on_gdunit_event(event: GdUnitEvent) -> void:
	match event.type():
		GdUnitEvent.DISCOVER_START:
			_tree_root.visible = false
			_discover_hint.visible = true
			init_tree()

		GdUnitEvent.DISCOVER_END:
			sort_tree_items(_tree_root)
			_discover_hint.visible = false
			_tree_root.visible = true
			#_dump_tree_as_json("tree_example_discovered")

		GdUnitEvent.DISCOVER_SUITE_ADDED:
			discover_test_suite_added(event as GdUnitEventTestDiscoverTestSuiteAdded)

		GdUnitEvent.DISCOVER_TEST_ADDED:
			discover_test_added(event as GdUnitEventTestDiscoverTestAdded)

		GdUnitEvent.DISCOVER_TEST_REMOVED:
			discover_test_removed(event as GdUnitEventTestDiscoverTestRemoved)

		GdUnitEvent.INIT:
			if not GdUnitSettings.is_test_discover_enabled():
				init_tree()

		GdUnitEvent.STOP:
			sort_tree_items(_tree_root)
			#_dump_tree_as_json("tree_example")

		GdUnitEvent.TESTCASE_BEFORE:
			update_test_case(event)

		GdUnitEvent.TESTCASE_AFTER:
			update_test_case(event)

		GdUnitEvent.TESTSUITE_BEFORE:
			update_test_suite(event)

		GdUnitEvent.TESTSUITE_AFTER:
			update_test_suite(event)


func _on_context_m_index_pressed(index: int) -> void:
	match index:
		CONTEXT_MENU_DEBUG_ID:
			_on_run_pressed(true)
		CONTEXT_MENU_RUN_ID:
			_on_run_pressed(false)
		CONTEXT_MENU_EXPAND_ALL:
			do_collapse_all(false)
		CONTEXT_MENU_COLLAPSE_ALL:
			do_collapse_all(true)


func _on_settings_changed(property :GdUnitProperty) -> void:
	if property.name() == GdUnitSettings.INSPECTOR_TREE_SORT_MODE:
		sort_tree_items(_tree_root)
		# _dump_tree_as_json("tree_sorted_by_%s" % GdUnitInspectorTreeConstants.SORT_MODE.keys()[property.value()])

	if property.name() == GdUnitSettings.INSPECTOR_TREE_VIEW_MODE:
		_tree_view_mode_flat = property.value() == GdUnitInspectorTreeConstants.TREE_VIEW_MODE.FLAT
		GdUnitCommandHandler.instance().cmd_discover_tests()
@tool
class_name GdUnitInputCapture
extends Control

signal input_completed(input_event: InputEventKey)


var _tween: Tween
var _input_event: InputEventKey


func _ready() -> void:
	reset()
	self_modulate = Color.WHITE
	_tween = create_tween()
	@warning_ignore("return_value_discarded")
	_tween.set_loops()
	@warning_ignore("return_value_discarded")
	_tween.tween_property(%Label, "self_modulate", Color(1, 1, 1, .8), 1.0).from_current().set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_IN_OUT)


func reset() -> void:
	_input_event = InputEventKey.new()


func _input(event: InputEvent) -> void:
	if not is_visible_in_tree():
		return
	if event is InputEventKey and event.is_pressed() and not event.is_echo():
		var _event := event as InputEventKey
		match _event.keycode:
			KEY_CTRL:
				_input_event.ctrl_pressed = true
			KEY_SHIFT:
				_input_event.shift_pressed = true
			KEY_ALT:
				_input_event.alt_pressed = true
			KEY_META:
				_input_event.meta_pressed = true
			_:
				_input_event.keycode = _event.keycode
		_apply_input_modifiers(_event)
		accept_event()

	if event is InputEventKey and not event.is_pressed():
		input_completed.emit(_input_event)
		hide()


func _apply_input_modifiers(event: InputEvent) -> void:
	if event is InputEventWithModifiers:
		var _event := event as InputEventWithModifiers
		_input_event.meta_pressed = _event.meta_pressed or _input_event.meta_pressed
		_input_event.alt_pressed = _event.alt_pressed or _input_event.alt_pressed
		_input_event.shift_pressed = _event.shift_pressed or _input_event.shift_pressed
		_input_event.ctrl_pressed = _event.ctrl_pressed or _input_event.ctrl_pressed
@tool
extends Window

const EAXAMPLE_URL := "https://github.com/MikeSchulze/gdUnit4-examples/archive/refs/heads/master.zip"
const GdUnitTools := preload ("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const GdUnitUpdateClient = preload ("res://addons/gdUnit4/src/update/GdUnitUpdateClient.gd")

@onready var _update_client: GdUnitUpdateClient = $GdUnitUpdateClient
@onready var _version_label: RichTextLabel = %version
@onready var _btn_install: Button = %btn_install_examples
@onready var _progress_bar: ProgressBar = %ProgressBar
@onready var _progress_text: Label = %progress_lbl
@onready var _properties_template: Node = $property_template
@onready var _properties_common: Node = % "common-content"
@onready var _properties_ui: Node = % "ui-content"
@onready var _properties_shortcuts: Node = % "shortcut-content"
@onready var _properties_report: Node = % "report-content"
@onready var _input_capture: GdUnitInputCapture = %GdUnitInputCapture
@onready var _property_error: Window = % "propertyError"
@onready var _tab_container: TabContainer = %Properties
@onready var _update_tab: = %Update

var _font_size: float


func _ready() -> void:
	set_name("GdUnitSettingsDialog")
	# initialize for testing
	if not Engine.is_editor_hint():
		GdUnitSettings.setup()
	GdUnit4Version.init_version_label(_version_label)
	_font_size = GdUnitFonts.init_fonts(_version_label)
	setup_properties(_properties_common, GdUnitSettings.COMMON_SETTINGS)
	setup_properties(_properties_ui, GdUnitSettings.UI_SETTINGS)
	setup_properties(_properties_report, GdUnitSettings.REPORT_SETTINGS)
	setup_properties(_properties_shortcuts, GdUnitSettings.SHORTCUT_SETTINGS)
	check_for_update()


func _sort_by_key(left: GdUnitProperty, right: GdUnitProperty) -> bool:
	return left.name() < right.name()


func setup_properties(properties_parent: Node, property_category: String) -> void:
	# Do remove first potential previous added properties (could be happened when the dlg is opened at twice)
	for child in properties_parent.get_children():
		properties_parent.remove_child(child)

	var category_properties := GdUnitSettings.list_settings(property_category)
	# sort by key
	category_properties.sort_custom(_sort_by_key)
	var theme_ := Theme.new()
	theme_.set_constant("h_separation", "GridContainer", 12)
	var last_category := "!"
	var min_size_overall := 0.0
	var labels := []
	var inputs := []
	var info_labels := []
	var grid: GridContainer = null
	for p in category_properties:
		var min_size_ := 0.0
		var property: GdUnitProperty = p
		var current_category := property.category()
		if not grid or current_category != last_category:
			grid = GridContainer.new()
			grid.columns = 4
			grid.theme = theme_

			var sub_category: Node = _properties_template.get_child(3).duplicate()
			sub_category.get_child(0).text = current_category.capitalize()
			sub_category.custom_minimum_size.y = _font_size + 16
			properties_parent.add_child(sub_category)
			properties_parent.add_child(grid)
			last_category = current_category
		# property name
		var label: Label = _properties_template.get_child(0).duplicate()
		label.text = _to_human_readable(property.name())
		labels.append(label)
		grid.add_child(label)

		# property reset btn
		var reset_btn: Button = _properties_template.get_child(1).duplicate()
		reset_btn.icon = _get_btn_icon("Reload")
		reset_btn.disabled = property.value() == property.default()
		grid.add_child(reset_btn)

		# property type specific input element
		var input: Node = _create_input_element(property, reset_btn)
		inputs.append(input)
		grid.add_child(input)
		@warning_ignore("return_value_discarded")
		reset_btn.pressed.connect(_on_btn_property_reset_pressed.bind(property, input, reset_btn))
		# property help text
		var info: Node = _properties_template.get_child(2).duplicate()
		info.text = property.help()
		info_labels.append(info)
		grid.add_child(info)
		if min_size_overall < min_size_:
			min_size_overall = min_size_

	for controls: Array in [labels, inputs, info_labels]:
		var _size: float = controls.map(func(c: Control) -> float: return c.size.x).max()
		min_size_overall += _size
		for control: Control in controls:
			control.custom_minimum_size.x = _size
	properties_parent.custom_minimum_size.x = min_size_overall


@warning_ignore("return_value_discarded")
func _create_input_element(property: GdUnitProperty, reset_btn: Button) -> Node:
	if property.is_selectable_value():
		var options := OptionButton.new()
		options.alignment = HORIZONTAL_ALIGNMENT_CENTER
		for value in property.value_set():
			options.add_item(value)
		options.item_selected.connect(_on_option_selected.bind(property, reset_btn))
		options.select(property.value())
		return options
	if property.type() == TYPE_BOOL:
		var check_btn := CheckButton.new()
		check_btn.toggled.connect(_on_property_text_changed.bind(property, reset_btn))
		check_btn.button_pressed = property.value()
		return check_btn
	if property.type() in [TYPE_INT, TYPE_STRING]:
		var input := LineEdit.new()
		input.text_changed.connect(_on_property_text_changed.bind(property, reset_btn))
		input.set_context_menu_enabled(false)
		input.set_horizontal_alignment(HORIZONTAL_ALIGNMENT_CENTER)
		input.set_expand_to_text_length_enabled(true)
		input.text = str(property.value())
		return input
	if property.type() == TYPE_PACKED_INT32_ARRAY:
		var key_input_button := Button.new()
		key_input_button.text = to_shortcut(property.value())
		key_input_button.pressed.connect(_on_shortcut_change.bind(key_input_button, property, reset_btn))
		return key_input_button
	return Control.new()


func to_shortcut(keys: PackedInt32Array) -> String:
	var input_event := InputEventKey.new()
	for key in keys:
		match key:
			KEY_CTRL: input_event.ctrl_pressed = true
			KEY_SHIFT: input_event.shift_pressed = true
			KEY_ALT: input_event.alt_pressed = true
			KEY_META: input_event.meta_pressed = true
			_:
				input_event.keycode = key as Key
	return input_event.as_text()


@warning_ignore("return_value_discarded")
func to_keys(input_event: InputEventKey) -> PackedInt32Array:
	var keys := PackedInt32Array()
	if input_event.ctrl_pressed:
		keys.append(KEY_CTRL)
	if input_event.shift_pressed:
		keys.append(KEY_SHIFT)
	if input_event.alt_pressed:
		keys.append(KEY_ALT)
	if input_event.meta_pressed:
		keys.append(KEY_META)
	keys.append(input_event.keycode)
	return keys


func _to_human_readable(value: String) -> String:
	return value.split("/")[-1].capitalize()


func _get_btn_icon(p_name: String) -> Texture2D:
	if not Engine.is_editor_hint():
		var placeholder := PlaceholderTexture2D.new()
		placeholder.size = Vector2(8, 8)
		return placeholder
	return GdUnitUiTools.get_icon(p_name)


func _install_examples() -> void:
	_init_progress(5)
	update_progress("Downloading examples")
	await get_tree().process_frame
	var tmp_path := GdUnitFileAccess.create_temp_dir("download")
	var zip_file := tmp_path + "/examples.zip"
	var response: GdUnitUpdateClient.HttpResponse = await _update_client.request_zip_package(EAXAMPLE_URL, zip_file)
	if response.code() != 200:
		push_warning("Examples cannot be retrieved from GitHub! \n Error code: %d : %s" % [response.code(), response.response()])
		update_progress("Install examples failed! Try it later again.")
		await get_tree().create_timer(3).timeout
		stop_progress()
		return
	# extract zip to tmp
	update_progress("Install examples into project")
	var result := GdUnitFileAccess.extract_zip(zip_file, "res://gdUnit4-examples/")
	if result.is_error():
		update_progress("Install examples failed! %s" % result.error_message())
		await get_tree().create_timer(3).timeout
		stop_progress()
		return
	update_progress("Refresh project")
	await rescan(true)
	update_progress("Examples successfully installed")
	await get_tree().create_timer(3).timeout
	stop_progress()


func rescan(update_scripts:=false) -> void:
	await get_tree().idle_frame
	var fs := EditorInterface.get_resource_filesystem()
	fs.scan_sources()
	while fs.is_scanning():
		await get_tree().create_timer(1).timeout
	if update_scripts:
		EditorInterface.get_resource_filesystem().update_script_classes()


func check_for_update() -> void:
	if not GdUnitSettings.is_update_notification_enabled():
		return
	var response :GdUnitUpdateClient.HttpResponse = await _update_client.request_latest_version()
	if response.status() != 200:
		printerr("Latest version information cannot be retrieved from GitHub!")
		printerr("Error:  %s" % response.response())
		return
	var latest_version := _update_client.extract_latest_version(response)
	if latest_version.is_greater(GdUnit4Version.current()):
		var tab_index := _tab_container.get_tab_idx_from_control(_update_tab)
		_tab_container.set_tab_button_icon(tab_index, GdUnitUiTools.get_icon("Notification", Color.YELLOW))
		_tab_container.set_tab_tooltip(tab_index, "An new update is available.")


func _on_btn_report_bug_pressed() -> void:
	@warning_ignore("return_value_discarded")
	OS.shell_open("https://github.com/MikeSchulze/gdUnit4/issues/new?assignees=MikeSchulze&labels=bug&projects=projects%2F5&template=bug_report.yml&title=GD-XXX%3A+Describe+the+issue+briefly")


func _on_btn_request_feature_pressed() -> void:
	@warning_ignore("return_value_discarded")
	OS.shell_open("https://github.com/MikeSchulze/gdUnit4/issues/new?assignees=MikeSchulze&labels=enhancement&projects=&template=feature_request.md&title=")


func _on_btn_install_examples_pressed() -> void:
	_btn_install.disabled = true
	await _install_examples()
	_btn_install.disabled = false


func _on_btn_close_pressed() -> void:
	hide()


func _on_btn_property_reset_pressed(property: GdUnitProperty, input: Node, reset_btn: Button) -> void:
	if input is CheckButton:
		input.button_pressed = property.default()
	elif input is LineEdit:
		input.text = str(property.default())
		# we have to update manually for text input fields because of no change event is emited
		_on_property_text_changed(property.default(), property, reset_btn)
	elif input is OptionButton:
		input.select(0)
		_on_option_selected(0, property, reset_btn)
	elif input is Button:
		input.text = to_shortcut(property.default())
		_on_property_text_changed(property.default(), property, reset_btn)


func _on_property_text_changed(new_value: Variant, property: GdUnitProperty, reset_btn: Button) -> void:
	property.set_value(new_value)
	reset_btn.disabled = property.value() == property.default()
	var error: Variant = GdUnitSettings.update_property(property)
	if error:
		var label: Label = _property_error.get_child(0) as Label
		label.set_text(error)
		var control := gui_get_focus_owner()
		_property_error.show()
		if control != null:
			_property_error.position = control.global_position + Vector2(self.position) + Vector2(40, 40)


func _on_option_selected(index: int, property: GdUnitProperty, reset_btn: Button) -> void:
	property.set_value(index)
	reset_btn.disabled = property.value() == property.default()
	GdUnitSettings.update_property(property)


func _on_shortcut_change(input_button: Button, property: GdUnitProperty, reset_btn: Button) -> void:
	_input_capture.set_custom_minimum_size(_properties_shortcuts.get_size())
	_input_capture.visible = true
	_input_capture.show()
	_properties_shortcuts.visible = false
	set_process_input(false)
	_input_capture.reset()
	var input_event: InputEventKey = await _input_capture.input_completed
	input_button.text = input_event.as_text()
	_on_property_text_changed(to_keys(input_event), property, reset_btn)
	_properties_shortcuts.visible = true
	set_process_input(true)


func _init_progress(max_value: int) -> void:
	_progress_bar.visible = true
	_progress_bar.max_value = max_value
	_progress_bar.value = 0


func _progress() -> void:
	_progress_bar.value += 1


func stop_progress() -> void:
	_progress_bar.visible = false


func update_progress(message: String) -> void:
	_progress_text.text = message
	_progress_bar.value += 1
@tool
extends MarginContainer

@onready var _template_editor :CodeEdit = $VBoxContainer/EdiorLayout/Editor
@onready var _tags_editor :CodeEdit = $Tags/MarginContainer/TextEdit
@onready var _title_bar :Panel = $VBoxContainer/sub_category
@onready var _save_button :Button = $VBoxContainer/Panel/HBoxContainer/Save
@onready var _selected_type :OptionButton = $VBoxContainer/EdiorLayout/Editor/MarginContainer/HBoxContainer/SelectType
@onready var _show_tags  :PopupPanel = $Tags


var gd_key_words :PackedStringArray = ["extends", "class_name", "const", "var", "onready", "func", "void", "pass"]
var gdunit_key_words :PackedStringArray = ["GdUnitTestSuite", "before", "after", "before_test", "after_test"]
var _selected_template :int


func _ready() -> void:
	setup_editor_colors()
	setup_fonts()
	setup_supported_types()
	load_template(GdUnitTestSuiteTemplate.TEMPLATE_ID_GD)
	setup_tags_help()


func _notification(what :int) -> void:
	if what == EditorSettings.NOTIFICATION_EDITOR_SETTINGS_CHANGED:
		setup_fonts()


func setup_editor_colors() -> void:
	if not Engine.is_editor_hint():
		return

	var background_color := get_editor_color("text_editor/theme/highlighting/background_color", Color(0.1155, 0.132, 0.1595, 1))
	var text_color := get_editor_color("text_editor/theme/highlighting/text_color", Color(0.8025, 0.81, 0.8225, 1))
	var selection_color := get_editor_color("text_editor/theme/highlighting/selection_color", Color(0.44, 0.73, 0.98, 0.4))

	for e :CodeEdit in [_template_editor, _tags_editor]:
		var editor :CodeEdit = e
		editor.add_theme_color_override("background_color", background_color)
		editor.add_theme_color_override("font_color", text_color)
		editor.add_theme_color_override("font_readonly_color", text_color)
		editor.add_theme_color_override("font_selected_color", selection_color)
		setup_highlighter(editor)


func setup_highlighter(editor :CodeEdit) -> void:
	var highlighter := CodeHighlighter.new()
	editor.set_syntax_highlighter(highlighter)
	var number_color := get_editor_color("text_editor/theme/highlighting/number_color", Color(0.63, 1, 0.88, 1))
	var symbol_color := get_editor_color("text_editor/theme/highlighting/symbol_color", Color(0.67, 0.79, 1, 1))
	var function_color := get_editor_color("text_editor/theme/highlighting/function_color", Color(0.34, 0.7, 1, 1))
	var member_variable_color := get_editor_color("text_editor/theme/highlighting/member_variable_color", Color(0.736, 0.88, 1, 1))
	var comment_color := get_editor_color("text_editor/theme/highlighting/comment_color", Color(0.8025, 0.81, 0.8225, 0.5))
	var keyword_color := get_editor_color("text_editor/theme/highlighting/keyword_color", Color(1, 0.44, 0.52, 1))
	var base_type_color := get_editor_color("text_editor/theme/highlighting/base_type_color", Color(0.26, 1, 0.76, 1))
	var annotation_color := get_editor_color("text_editor/theme/highlighting/gdscript/annotation_color", Color(1, 0.7, 0.45, 1))

	highlighter.clear_color_regions()
	highlighter.clear_keyword_colors()
	highlighter.add_color_region("#", "", comment_color, true)
	highlighter.add_color_region("${", "}", Color.YELLOW)
	highlighter.add_color_region("'", "'", Color.YELLOW)
	highlighter.add_color_region("\"", "\"", Color.YELLOW)
	highlighter.number_color = number_color
	highlighter.symbol_color = symbol_color
	highlighter.function_color = function_color
	highlighter.member_variable_color = member_variable_color
	highlighter.add_keyword_color("@", annotation_color)
	highlighter.add_keyword_color("warning_ignore", annotation_color)
	for word in gd_key_words:
		highlighter.add_keyword_color(word, keyword_color)
	for word in gdunit_key_words:
		highlighter.add_keyword_color(word, base_type_color)


## Using this function to avoid null references to colors on inital Godot installations.
## For more details show https://github.com/MikeSchulze/gdUnit4/issues/533
func get_editor_color(property_name: String, default: Color) -> Color:
	var settings := EditorInterface.get_editor_settings()
	return settings.get_setting(property_name) if settings.has_setting(property_name) else default


func setup_fonts() -> void:
	if _template_editor:
		@warning_ignore("return_value_discarded")
		GdUnitFonts.init_fonts(_template_editor)
		var font_size := GdUnitFonts.init_fonts(_tags_editor)
		_title_bar.size.y = font_size + 16
		_title_bar.custom_minimum_size.y = font_size + 16


func setup_supported_types() -> void:
	_selected_type.clear()
	_selected_type.add_item("GD - GDScript", GdUnitTestSuiteTemplate.TEMPLATE_ID_GD)
	_selected_type.add_item("C# - CSharpScript", GdUnitTestSuiteTemplate.TEMPLATE_ID_CS)


func setup_tags_help() -> void:
	_tags_editor.set_text(GdUnitTestSuiteTemplate.load_tags(_selected_template))


func load_template(template_id :int) -> void:
	_selected_template = template_id
	_template_editor.set_text(GdUnitTestSuiteTemplate.load_template(template_id))


func _on_Restore_pressed() -> void:
	_template_editor.set_text(GdUnitTestSuiteTemplate.default_template(_selected_template))
	GdUnitTestSuiteTemplate.reset_to_default(_selected_template)
	_save_button.disabled = true


func _on_Save_pressed() -> void:
	GdUnitTestSuiteTemplate.save_template(_selected_template, _template_editor.get_text())
	_save_button.disabled = true


func _on_Tags_pressed() -> void:
	_show_tags.popup_centered_ratio(.5)


func _on_Editor_text_changed() -> void:
	_save_button.disabled = false


func _on_SelectType_item_selected(index :int) -> void:
	load_template(_selected_type.get_item_id(index))
	setup_tags_help()
@tool
extends RefCounted

const GdUnitUpdateClient = preload("res://addons/gdUnit4/src/update/GdUnitUpdateClient.gd")

const FONT_H1 := 22
const FONT_H2 := 20
const FONT_H3 := 18
const FONT_H4 := 16
const FONT_H5 := 14
const FONT_H6 := 12

const HORIZONTAL_RULE := "[img=4000x2]res://addons/gdUnit4/src/update/assets/horizontal-line2.png[/img]"
const HEADER_RULE := "[font_size=%d]$1[/font_size]"
const HEADER_CENTERED_RULE := "[font_size=%d][center]$1[/center][/font_size]"

const image_download_folder := "res://addons/gdUnit4/tmp-update/"

const exclude_font_size := "\b(?!(?:(font_size))\b)"

var md_replace_patterns := [
	# comments
	[regex("(?m)^\\n?\\s*<!--[\\s\\S]*?-->\\s*\\n?"), ""],

	# horizontal rules
	[regex("(?m)^[ ]{0,3}---$"), HORIZONTAL_RULE],
	[regex("(?m)^[ ]{0,3}___$"), HORIZONTAL_RULE],
	[regex("(?m)^[ ]{0,3}\\*\\*\\*$"), HORIZONTAL_RULE],

	# headers
	[regex("(?m)^###### (.*)"), HEADER_RULE % FONT_H6],
	[regex("(?m)^##### (.*)"), HEADER_RULE % FONT_H5],
	[regex("(?m)^#### (.*)"), HEADER_RULE % FONT_H4],
	[regex("(?m)^### (.*)"), HEADER_RULE % FONT_H3],
	[regex("(?m)^## (.*)"), (HEADER_RULE + HORIZONTAL_RULE) % FONT_H2],
	[regex("(?m)^# (.*)"), (HEADER_RULE + HORIZONTAL_RULE) % FONT_H1],
	[regex("(?m)^(.+)=={2,}$"), HEADER_RULE % FONT_H1],
	[regex("(?m)^(.+)--{2,}$"), HEADER_RULE % FONT_H2],
	# html headers
	[regex("<h1>((.*?\\R?)+)<\\/h1>"), (HEADER_RULE + HORIZONTAL_RULE) % FONT_H1],
	[regex("<h1[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h1>"), (HEADER_CENTERED_RULE + HORIZONTAL_RULE) % FONT_H1],
	[regex("<h2>((.*?\\R?)+)<\\/h2>"), (HEADER_RULE + HORIZONTAL_RULE) % FONT_H2],
	[regex("<h2[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h2>"), (HEADER_CENTERED_RULE + HORIZONTAL_RULE) % FONT_H1],
	[regex("<h3>((.*?\\R?)+)<\\/h3>"), HEADER_RULE % FONT_H3],
	[regex("<h3[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h3>"), HEADER_CENTERED_RULE % FONT_H3],
	[regex("<h4>((.*?\\R?)+)<\\/h4>"), HEADER_RULE % FONT_H4],
	[regex("<h4[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h4>"), HEADER_CENTERED_RULE % FONT_H4],
	[regex("<h5>((.*?\\R?)+)<\\/h5>"), HEADER_RULE % FONT_H5],
	[regex("<h5[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h5>"), HEADER_CENTERED_RULE % FONT_H5],
	[regex("<h6>((.*?\\R?)+)<\\/h6>"), HEADER_RULE % FONT_H6],
	[regex("<h6[ ]*align[ ]*=[ ]*\"center\">((.*?\\R?)+)<\\/h6>"), HEADER_CENTERED_RULE % FONT_H6],

	# asterics
	#[regex("(\\*)"), "xxx$1xxx"],

	# extract/compile image references
	[regex("!\\[(.*?)\\]\\[(.*?)\\]"), process_image_references],
	# extract images with path and optional tool tip
	[regex("!\\[(.*?)\\]\\((.*?)(( )+(.*?))?\\)"), process_image],

	# links
	[regex("([!]|)\\[(.+)\\]\\(([^ ]+?)\\)"),  "[url={\"url\":\"$3\"}]$2[/url]"],
	# links with tool tip
	[regex("([!]|)\\[(.+)\\]\\(([^ ]+?)( \"(.+)\")?\\)"),  "[url={\"url\":\"$3\", \"tool_tip\":\"$5\"}]$2[/url]"],
	# links to github, as shorted link
	[regex("(https://github.*/?/(\\S+))"), '[url={"url":"$1", "tool_tip":"$1"}]#$2[/url]'],

	# embeded text
	[regex("(?m)^[ ]{0,3}>(.*?)$"), "[img=50x14]res://addons/gdUnit4/src/update/assets/embedded.png[/img][i]$1[/i]"],

	# italic + bold font
	[regex("[_]{3}(.*?)[_]{3}"), "[i][b]$1[/b][/i]"],
	[regex("[\\*]{3}(.*?)[\\*]{3}"), "[i][b]$1[/b][/i]"],
	# bold font
	[regex("<b>(.*?)<\\/b>"), "[b]$1[/b]"],
	[regex("[_]{2}(.*?)[_]{2}"), "[b]$1[/b]"],
	[regex("[\\*]{2}(.*?)[\\*]{2}"), "[b]$1[/b]"],
	# italic font
	[regex("<i>(.*?)<\\/i>"), "[i]$1[/i]"],
	[regex(exclude_font_size+"_(.*?)_"), "[i]$1[/i]"],
	[regex("\\*(.*?)\\*"), "[i]$1[/i]"],

	# strikethrough font
	[regex("<s>(.*?)</s>"), "[s]$1[/s]"],
	[regex("~~(.*?)~~"), "[s]$1[/s]"],
	[regex("~(.*?)~"), "[s]$1[/s]"],

	# handling lists
	# using an image for dots
	[regex("(?m)^[ ]{0,1}[*\\-+] (.*)$"), list_replace(0)],
	[regex("(?m)^[ ]{2,3}[*\\-+] (.*)$"), list_replace(1)],
	[regex("(?m)^[ ]{4,5}[*\\-+] (.*)$"), list_replace(2)],
	[regex("(?m)^[ ]{6,7}[*\\-+] (.*)$"), list_replace(3)],
	[regex("(?m)^[ ]{8,9}[*\\-+] (.*)$"), list_replace(4)],

	# code
	[regex("``([\\s\\S]*?)``"), code_block("$1")],
	[regex("`([\\s\\S]*?)`{1,2}"), code_block("$1")],
]

var code_block_patterns := [
	# code blocks, code blocks looks not like code blocks in richtext
	[regex("```(javascript|python|shell|gdscript|gd)([\\s\\S]*?\n)```"), code_block("$2", true)],
]

var _img_replace_regex := RegEx.new()
var _image_urls := PackedStringArray()
var _on_table_tag := false
var _client: GdUnitUpdateClient


static func regex(pattern: String) -> RegEx:
	var regex_ := RegEx.new()
	var err := regex_.compile(pattern)
	if err != OK:
		push_error("error '%s' checked pattern '%s'" % [err, pattern])
		return null
	return regex_


func _init() -> void:
	@warning_ignore("return_value_discarded")
	_img_replace_regex.compile("\\[img\\]((.*?))\\[/img\\]")


func set_http_client(client: GdUnitUpdateClient) -> void:
	_client = client


@warning_ignore("return_value_discarded")
func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		# finally remove_at the downloaded images
		for image in _image_urls:
			DirAccess.remove_absolute(image)
			DirAccess.remove_absolute(image + ".import")


func list_replace(indent: int) -> String:
	var replace_pattern := "[img=12x12]res://addons/gdUnit4/src/update/assets/dot2.png[/img]" if indent %2 else "[img=12x12]res://addons/gdUnit4/src/update/assets/dot1.png[/img]"
	replace_pattern += " $1"

	for index in indent:
		replace_pattern = replace_pattern.insert(0, "   ")
	return replace_pattern


func code_block(replace: String, border: bool = false) -> String:
	if border:
		return """
			[img=1400x14]res://addons/gdUnit4/src/update/assets/border_top.png[/img]
			[indent][color=GRAY][font_size=16]%s[/font_size][/color][/indent]
			[img=1400x14]res://addons/gdUnit4/src/update/assets/border_bottom.png[/img]
			""".dedent() % replace
	return "[code][bgcolor=DARK_SLATE_GRAY][color=GRAY][font_size=16]%s[/font_size][/color][/bgcolor][/code]" % replace


func convert_text(input: String) -> String:
	input = process_tables(input)

	for pattern: Array in md_replace_patterns:
		var regex_: RegEx = pattern[0]
		var bb_replace: Variant = pattern[1]
		if bb_replace is Callable:
			@warning_ignore("unsafe_method_access")
			input = await bb_replace.call(regex_, input)
		else:
			@warning_ignore("unsafe_cast")
			input = regex_.sub(input, bb_replace as String, true)
	return input


func convert_code_block(input: String) -> String:
	for pattern: Array in code_block_patterns:
		var regex_: RegEx = pattern[0]
		var bb_replace: Variant = pattern[1]
		if bb_replace is Callable:
			@warning_ignore("unsafe_method_access")
			input = await bb_replace.call(regex_, input)
		else:
			@warning_ignore("unsafe_cast")
			input = regex_.sub(input, bb_replace as String, true)
	return input


func to_bbcode(input: String) -> String:
	var re := regex("(?m)```[\\s\\S]*?```")
	var current_pos := 0
	var as_bbcode := ""

	# we split by code blocks to handle this blocks customized
	for result in re.search_all(input):
		# Add text before code block
		if result.get_start() > current_pos:
			as_bbcode += await convert_text(input.substr(current_pos, result.get_start() - current_pos))
		# Add code block
		as_bbcode += await convert_code_block(result.get_string())
		current_pos = result.get_end()

	# Add remaining text after last code block
	if current_pos < input.length():
		as_bbcode += await convert_text(input.substr(current_pos))
	return as_bbcode


func process_tables(input: String) -> String:
	var bbcode := PackedStringArray()
	var lines: Array[String] = Array(input.split("\n") as Array, TYPE_STRING, "", null)
	while not lines.is_empty():
		if is_table(lines[0]):
			bbcode.append_array(parse_table(lines))
			continue
		@warning_ignore("return_value_discarded", "unsafe_cast")
		bbcode.append(lines.pop_front() as String)
	return "\n".join(bbcode)


class Table:
	var _columns: int
	var _rows: Array[Row] = []

	class Row:
		var _cells := PackedStringArray()


		func _init(cells: PackedStringArray, columns: int) -> void:
			_cells = cells
			for i in range(_cells.size(), columns):
				@warning_ignore("return_value_discarded")
				_cells.append("")


		func to_bbcode(cell_sizes: PackedInt32Array, bold: bool) -> String:
			var cells := PackedStringArray()
			for cell_index in _cells.size():
				var cell: String = _cells[cell_index]
				if cell.strip_edges() == "--":
					cell = create_line(cell_sizes[cell_index])
				if bold:
					cell = "[b]%s[/b]" % cell
				@warning_ignore("return_value_discarded")
				cells.append("[cell]%s[/cell]" % cell)
			return "|".join(cells)


		func create_line(length: int) -> String:
			var line := ""
			for i in length:
				line += "-"
			return line


	func _init(columns: int) -> void:
		_columns = columns


	func parse_row(line :String) -> bool:
		# is line containing cells?
		if line.find("|") == -1:
			return false
		_rows.append(Row.new(line.split("|"), _columns))
		return true


	func calculate_max_cell_sizes() -> PackedInt32Array:
		var cells_size := PackedInt32Array()
		for column in _columns:
			@warning_ignore("return_value_discarded")
			cells_size.append(0)

		for row_index in _rows.size():
			var row: Row = _rows[row_index]
			for cell_index in row._cells.size():
				var cell_size: int = cells_size[cell_index]
				var size := row._cells[cell_index].length()
				if size > cell_size:
					cells_size[cell_index] = size
		return cells_size


	@warning_ignore("return_value_discarded")
	func to_bbcode() -> PackedStringArray:
		var cell_sizes := calculate_max_cell_sizes()
		var bb_code := PackedStringArray()

		bb_code.append("[table=%d]" % _columns)
		for row_index in _rows.size():
			bb_code.append(_rows[row_index].to_bbcode(cell_sizes, row_index==0))
		bb_code.append("[/table]\n")
		return bb_code


func parse_table(lines: Array) -> PackedStringArray:
	var line: String = lines[0]
	var table := Table.new(line.count("|") + 1)
	while not lines.is_empty():
		line = lines.pop_front()
		if not table.parse_row(line):
			break
	return table.to_bbcode()


func is_table(line: String) -> bool:
	return line.find("|") != -1


func open_table(line: String) -> String:
	_on_table_tag = true
	return "[table=%d]" % (line.count("|") + 1)


func close_table() -> String:
	_on_table_tag = false
	return "[/table]"


func extract_cells(line: String, bold := false) -> String:
	var cells := ""
	for cell in line.split("|"):
		if bold:
			cell = "[b]%s[/b]" % cell
		cells += "[cell]%s[/cell]" % cell
	return cells


func process_image_references(p_regex: RegEx, p_input: String) -> String:
	#return p_input

	# exists references?
	var matches := p_regex.search_all(p_input)
	if matches.is_empty():
		return p_input
	# collect image references and remove_at it
	var references := Dictionary()
	var link_regex := regex("\\[(\\S+)\\]:(\\S+)([ ]\"(.*)\")?")
	# create copy of original source to replace checked it
	var input := p_input.replace("\r", "")
	var extracted_references :=  p_input.replace("\r", "")
	for reg_match in link_regex.search_all(input):
		var line := reg_match.get_string(0) + "\n"
		var ref := reg_match.get_string(1)
		#var topl_tip = reg_match.get_string(4)
		# collect reference and url
		references[ref] = reg_match.get_string(2)
		extracted_references = extracted_references.replace(line, "")

	# replace image references by collected url's
	for reference_key: String in references.keys():
		var regex_key := regex("\\](\\[%s\\])" % reference_key)
		for reg_match in regex_key.search_all(extracted_references):
			var ref: String = reg_match.get_string(0)
			var image_url: String = "](%s)" % references.get(reference_key)
			extracted_references = extracted_references.replace(ref, image_url)
	return extracted_references


@warning_ignore("return_value_discarded")
func process_image(p_regex: RegEx, p_input: String) -> String:
	#return p_input
	var to_replace := PackedStringArray()
	var tool_tips :=  PackedStringArray()
	# find all matches
	var matches := p_regex.search_all(p_input)
	if matches.is_empty():
		return p_input
	for reg_match in matches:
		# grap the parts to replace and store temporay because a direct replace will distort the offsets
		to_replace.append(p_input.substr(reg_match.get_start(0), reg_match.get_end(0)))
		# grap optional tool tips
		tool_tips.append(reg_match.get_string(5))
	# finally replace all findings
	for replace in to_replace:
		var re := p_regex.sub(replace, "[img]$2[/img]")
		p_input = p_input.replace(replace, re)
	return await _process_external_image_resources(p_input)


func _process_external_image_resources(input: String) -> String:
	@warning_ignore("return_value_discarded")
	DirAccess.make_dir_recursive_absolute(image_download_folder)
	# scan all img for external resources and download it
	for value in _img_replace_regex.search_all(input):
		if value.get_group_count() >= 1:
			var image_url: String = value.get_string(1)
			# if not a local resource we need to download it
			if image_url.begins_with("http"):
				if OS.is_stdout_verbose():
					prints("download image:", image_url)
				var response := await _client.request_image(image_url)
				if response.status() == 200:
					var image := Image.new()
					var error := image.load_png_from_buffer(response.get_body())
					if error != OK:
						prints("Error creating image from response", error)
					# replace characters where format characters
					var new_url := image_download_folder + image_url.get_file().replace("_", "-")
					if new_url.get_extension() != 'png':
						new_url = new_url + '.png'
					var err := image.save_png(new_url)
					if err:
						push_error("Can't save image to '%s'. Error: %s" % [new_url, error_string(err)])
					@warning_ignore("return_value_discarded")
					_image_urls.append(new_url)
					input = input.replace(image_url, new_url)
	return input
class_name GdUnitPatch
extends RefCounted

const PATCH_VERSION = "patch_version"

var _version :GdUnit4Version


func _init(version_ :GdUnit4Version) -> void:
	_version = version_


func version() -> GdUnit4Version:
	return _version


# this function needs to be implement
func execute() -> bool:
	push_error("The function 'execute()' is not implemented at %s" % self)
	return false
class_name GdUnitPatcher
extends RefCounted


const _base_dir := "res://addons/gdUnit4/src/update/patches/"

var _patches := Dictionary()


func scan(current :GdUnit4Version) -> void:
	_scan(_base_dir, current)


func _scan(scan_path :String, current :GdUnit4Version) -> void:
	_patches = Dictionary()
	var patch_paths := _collect_patch_versions(scan_path, current)
	for path in patch_paths:
		prints("scan for patches checked '%s'" % path)
		_patches[path] = _scan_patches(path)


func patch_count() -> int:
	var count := 0
	for key :String in _patches.keys():
		count += _patches[key].size()
	return count


func execute() -> void:
	for key :String in _patches.keys():
		for path :String in _patches[key]:
			var patch :GdUnitPatch = load(key + "/" + path).new()
			if patch:
				prints("execute patch", patch.version(), patch.get_script().resource_path)
				if not patch.execute():
					prints("error checked execution patch %s" % key + "/" + path)


func _collect_patch_versions(scan_path :String, current :GdUnit4Version) -> PackedStringArray:
	if not DirAccess.dir_exists_absolute(scan_path):
		return PackedStringArray()
	var patches := Array()
	var dir := DirAccess.open(scan_path)
	if dir != null:
		@warning_ignore("return_value_discarded")
		dir.list_dir_begin() # TODO GODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
		var next := "."
		while next != "":
			next = dir.get_next()
			if next.is_empty() or next == "." or next == "..":
				continue
			var version := GdUnit4Version.parse(next)
			if version.is_greater(current):
				patches.append(scan_path + next)
	patches.sort()
	return PackedStringArray(patches)


func _scan_patches(path :String) -> PackedStringArray:
	var patches := Array()
	var dir := DirAccess.open(path)
	if dir != null:
		@warning_ignore("return_value_discarded")
		dir.list_dir_begin() # TODOGODOT4 fill missing arguments https://github.com/godotengine/godot/pull/40547
		var next := "."
		while next != "":
			next = dir.get_next()
			# step over directory links and .uid files
			if next.is_empty() or next == "." or next == ".." or next.ends_with(".uid"):
				continue
			patches.append(next)
	# make sorted from lowest to high version
	patches.sort()
	return PackedStringArray(patches)
@tool
extends Container

const GdUnitTools := preload("res://addons/gdUnit4/src/core/GdUnitTools.gd")
const GdUnitUpdateClient := preload("res://addons/gdUnit4/src/update/GdUnitUpdateClient.gd")
const GDUNIT_TEMP := "user://tmp"

@onready var _progress_content: RichTextLabel = %message
@onready var _progress_bar: TextureProgressBar = %progress
@onready var _cancel_btn: Button = %cancel
@onready var _update_btn: Button = %update
@onready var _spinner_img := GdUnitUiTools.get_spinner()


var _debug_mode := false
var _update_client :GdUnitUpdateClient
var _download_url :String


func _ready() -> void:
	init_progress(5)


func _process(_delta :float) -> void:
	if _progress_content != null and _progress_content.is_visible_in_tree():
		_progress_content.queue_redraw()


func init_progress(max_value: int) -> void:
	_cancel_btn.disabled = false
	_update_btn.disabled = false
	_progress_bar.max_value = max_value
	_progress_bar.value = 1
	message_h4("Press [Update] to start.", Color.GREEN, false)


func setup(update_client: GdUnitUpdateClient, download_url: String) -> void:
	_update_client = update_client
	_download_url = download_url


func update_progress(message: String, color := Color.GREEN) -> void:
	message_h4(message, color)
	_progress_bar.value += 1
	if _debug_mode:
		await get_tree().create_timer(3).timeout
	await get_tree().create_timer(.2).timeout


func _colored(message: String, color: Color) -> String:
	return "[color=#%s]%s[/color]" % [color.to_html(), message]


func message_h4(message: String, color: Color, show_spinner := true) -> void:
	_progress_content.clear()
	if show_spinner:
		_progress_content.add_image(_spinner_img)
	_progress_content.append_text(" [font_size=16]%s[/font_size]" % _colored(message, color))


@warning_ignore("return_value_discarded")
func run_update() -> void:
	_cancel_btn.disabled = true
	_update_btn.disabled = true

	await update_progress("Downloading the update.")
	await download_release()
	await update_progress("Extracting")
	var zip_file := temp_dir() + "/update.zip"
	var tmp_path := create_temp_dir("update")
	var result :Variant = extract_zip(zip_file, tmp_path)
	if result == null:
		await update_progress("Update failed! .. Rollback.", Color.INDIAN_RED)
		await get_tree().create_timer(3).timeout
		_cancel_btn.disabled = false
		_update_btn.disabled = false
		init_progress(5)
		hide()
		return

	await update_progress("Uninstall GdUnit4.")
	disable_gdUnit()
	if not _debug_mode:
		delete_directory("res://addons/gdUnit4/")
	# give editor time to react on deleted files
	await get_tree().create_timer(1).timeout

	await update_progress("Install new GdUnit4 version.")
	if _debug_mode:
		copy_directory(tmp_path, "res://debug")
	else:
		copy_directory(tmp_path, "res://")

	await update_progress("New GdUnit version successfully installed, Restarting Godot please wait.")
	await get_tree().create_timer(3).timeout
	enable_gdUnit()
	hide()
	delete_directory("res://addons/.gdunit_update")
	restart_godot()


func restart_godot() -> void:
	prints("Force restart Godot")
	EditorInterface.restart_editor(true)


@warning_ignore("return_value_discarded")
func enable_gdUnit() -> void:
	var enabled_plugins := PackedStringArray()
	if ProjectSettings.has_setting("editor_plugins/enabled"):
		enabled_plugins = ProjectSettings.get_setting("editor_plugins/enabled")
	if not enabled_plugins.has("res://addons/gdUnit4/plugin.cfg"):
		enabled_plugins.append("res://addons/gdUnit4/plugin.cfg")
	ProjectSettings.set_setting("editor_plugins/enabled", enabled_plugins)
	ProjectSettings.save()


func disable_gdUnit() -> void:
	EditorInterface.set_plugin_enabled("gdUnit4", false)


func temp_dir() -> String:
	if not DirAccess.dir_exists_absolute(GDUNIT_TEMP):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(GDUNIT_TEMP)
	return GDUNIT_TEMP


func create_temp_dir(folder_name :String) -> String:
	var new_folder := temp_dir() + "/" + folder_name
	delete_directory(new_folder)
	if not DirAccess.dir_exists_absolute(new_folder):
		@warning_ignore("return_value_discarded")
		DirAccess.make_dir_recursive_absolute(new_folder)
	return new_folder


func delete_directory(path: String, only_content := false) -> void:
	var dir := DirAccess.open(path)
	if dir != null:
		@warning_ignore("return_value_discarded")
		dir.list_dir_begin()
		var file_name := "."
		while file_name != "":
			file_name = dir.get_next()
			if file_name.is_empty() or file_name == "." or file_name == "..":
				continue
			var next := path + "/" +file_name
			if dir.current_is_dir():
				delete_directory(next)
			else:
				# delete file
				var err := dir.remove(next)
				if err:
					printerr("Delete %s failed: %s" % [next, error_string(err)])
		if not only_content:
			var err := dir.remove(path)
			if err:
				printerr("Delete %s failed: %s" % [path, error_string(err)])


func copy_directory(from_dir: String, to_dir: String) -> bool:
	if not DirAccess.dir_exists_absolute(from_dir):
		printerr("Source directory not found '%s'" % from_dir)
		return false
	# check if destination exists
	if not DirAccess.dir_exists_absolute(to_dir):
		# create it
		var err := DirAccess.make_dir_recursive_absolute(to_dir)
		if err != OK:
			printerr("Can't create directory '%s'. Error: %s" % [to_dir, error_string(err)])
			return false
	var source_dir := DirAccess.open(from_dir)
	var dest_dir := DirAccess.open(to_dir)
	if source_dir != null:
		@warning_ignore("return_value_discarded")
		source_dir.list_dir_begin()
		var next := "."

		while next != "":
			next = source_dir.get_next()
			if next == "" or next == "." or next == "..":
				continue
			var source := source_dir.get_current_dir() + "/" + next
			var dest := dest_dir.get_current_dir() + "/" + next
			if source_dir.current_is_dir():
				@warning_ignore("return_value_discarded")
				copy_directory(source + "/", dest)
				continue
			var err := source_dir.copy(source, dest)
			if err != OK:
				printerr("Error checked copy file '%s' to '%s'" % [source, dest])
				return false
		return true
	else:
		printerr("Directory not found: " + from_dir)
		return false


func extract_zip(zip_package: String, dest_path: String) -> Variant:
	var zip: ZIPReader = ZIPReader.new()
	var err := zip.open(zip_package)
	if err != OK:
		printerr("Extracting `%s` failed! Please collect the error log and report this. Error Code: %s" % [zip_package, err])
		return null
	var zip_entries: PackedStringArray = zip.get_files()
	# Get base path and step over archive folder
	var archive_path := zip_entries[0]
	zip_entries.remove_at(0)

	for zip_entry in zip_entries:
		var new_file_path: String = dest_path + "/" + zip_entry.replace(archive_path, "")
		if zip_entry.ends_with("/"):
			@warning_ignore("return_value_discarded")
			DirAccess.make_dir_recursive_absolute(new_file_path)
			continue
		var file: FileAccess = FileAccess.open(new_file_path, FileAccess.WRITE)
		file.store_buffer(zip.read_file(zip_entry))
	@warning_ignore("return_value_discarded")
	zip.close()
	return dest_path


func download_release() -> void:
	var zip_file := GdUnitFileAccess.temp_dir() + "/update.zip"
	var response :GdUnitUpdateClient.HttpResponse
	if _debug_mode:
		response = GdUnitUpdateClient.HttpResponse.new(200, PackedByteArray())
		zip_file = "res://update.zip"
		return

	response = await _update_client.request_zip_package(_download_url, zip_file)
	if response.status() != 200:
		push_warning("Update information cannot be retrieved from GitHub! \n Error code: %d : %s" % [response.status(), response.response()])
		message_h4("Download the update failed! Try it later again.", Color.INDIAN_RED)
		await get_tree().create_timer(3).timeout


func _on_confirmed() -> void:
	await run_update()


func _on_cancel_pressed() -> void:
	hide()


func _on_update_pressed() -> void:
	await run_update()
@tool
extends Node

signal request_completed(response: HttpResponse)

class HttpResponse:
	var _http_status: int
	var _body: PackedByteArray


	func _init(http_status: int, body: PackedByteArray) -> void:
		_http_status = http_status
		_body = body


	func status() -> int:
		return _http_status


	func response() -> Variant:
		if _http_status != 200:
			return _body.get_string_from_utf8()

		var test_json_conv := JSON.new()
		@warning_ignore("return_value_discarded")
		var error := test_json_conv.parse(_body.get_string_from_utf8())
		if error != OK:
			return "HttpResponse: %s Error: %s" % [error_string(error), _body.get_string_from_utf8()]
		return test_json_conv.get_data()

	func get_body() -> PackedByteArray:
		return _body


var _http_request := HTTPRequest.new()


func _ready() -> void:
	add_child(_http_request)
	@warning_ignore("return_value_discarded")
	_http_request.request_completed.connect(_on_request_completed)


func _notification(what: int) -> void:
	if what == NOTIFICATION_PREDELETE:
		if is_instance_valid(_http_request):
			_http_request.queue_free()


#func list_tags() -> void:
#	_http_request.connect("request_completed",Callable(self,"_response_request_tags"))
#	var error = _http_request.request("https://api.github.com/repos/MikeSchulze/gdUnit4/tags")
#	if error != OK:
#		push_error("An error occurred in the HTTP request.")


func request_latest_version() -> HttpResponse:
	var error := _http_request.request("https://api.github.com/repos/MikeSchulze/gdUnit4/tags")
	if error != OK:
		var message := "Request latest version failed, %s" % error_string(error)
		return HttpResponse.new(error, message.to_utf8_buffer())
	return await self.request_completed


func request_releases() -> HttpResponse:
	var error := _http_request.request("https://api.github.com/repos/MikeSchulze/gdUnit4/releases")
	if error != OK:
		var message := "request_releases failed: %d" % error
		return HttpResponse.new(error, message.to_utf8_buffer())
	return await self.request_completed


func request_image(url: String) -> HttpResponse:
	var error := _http_request.request(url)
	if error != OK:
		var message := "request_image failed: %d" % error
		return HttpResponse.new(error, message.to_utf8_buffer())
	return await self.request_completed


func request_zip_package(url: String, file: String) -> HttpResponse:
	_http_request.set_download_file(file)
	var error := _http_request.request(url)
	if error != OK:
		var message := "request_zip_package failed: %d" % error
		return HttpResponse.new(error, message.to_utf8_buffer())
	return await self.request_completed


func extract_latest_version(response: HttpResponse) -> GdUnit4Version:
	var body: Array = response.response()
	return GdUnit4Version.parse(str(body[0]["name"]))


func _on_request_completed(_result: int, response_http_status: int, _headers: PackedStringArray, body: PackedByteArray) -> void:
	if _http_request.get_http_client_status() != HTTPClient.STATUS_DISCONNECTED:
		_http_request.set_download_file("")
	request_completed.emit(HttpResponse.new(response_http_status, body))
@tool
extends MarginContainer

#signal request_completed(response)

const GdMarkDownReader = preload("res://addons/gdUnit4/src/update/GdMarkDownReader.gd")
const GdUnitUpdateClient = preload("res://addons/gdUnit4/src/update/GdUnitUpdateClient.gd")
const GdUnitUpdateProgress = preload("res://addons/gdUnit4/src/update/GdUnitUpdate.gd")

@onready var _md_reader: GdMarkDownReader = GdMarkDownReader.new()
@onready var _update_client: GdUnitUpdateClient = $GdUnitUpdateClient
@onready var _header: Label = $Panel/GridContainer/PanelContainer/header
@onready var _update_button: Button = $Panel/GridContainer/Panel/HBoxContainer/update
@onready var _content: RichTextLabel = $Panel/GridContainer/PanelContainer2/ScrollContainer/MarginContainer/content
@onready var _update_progress :GdUnitUpdateProgress = %update_banner

var _debug_mode := false
var _patcher := GdUnitPatcher.new()
var _current_version := GdUnit4Version.current()


func _ready() -> void:
	_update_button.set_disabled(false)
	_md_reader.set_http_client(_update_client)
	@warning_ignore("return_value_discarded")
	#GdUnitFonts.init_fonts(_content)
	_update_progress.set_visible(false)
	_update_progress.hidden.connect(func() -> void:
		_update_button.set_disabled(false)
	)


func request_releases() -> bool:
	if _debug_mode:
		_update_progress._debug_mode = _debug_mode
		_header.text = "A new version 'v4.4.4' is available"
		_update_button.set_disabled(false)
		return true

	var response :GdUnitUpdateClient.HttpResponse = await _update_client.request_latest_version()
	if response.status() != 200:
		_header.text = "Update information cannot be retrieved from GitHub!"
		message_h4("\n\nError: %s" % response.response(), Color.INDIAN_RED)
		return false
	var latest_version := _update_client.extract_latest_version(response)
	# if same version exit here no update need
	if latest_version.is_greater(_current_version):
		_patcher.scan(_current_version)
		_header.text = "A new version '%s' is available" % latest_version
		var download_zip_url := extract_zip_url(response)
		_update_progress.setup(_update_client, download_zip_url)
		_update_button.set_disabled(false)
		return true
	else:
		_header.text = "No update is available."
		_update_button.set_disabled(true)
		return false


func _colored(message_: String, color: Color) -> String:
	return "[color=#%s]%s[/color]" % [color.to_html(), message_]


func message_h4(message_: String, color: Color, clear := true) -> void:
	if clear:
		_content.clear()
	_content.append_text("[font_size=16]%s[/font_size]" % _colored(message_, color))


func message(message_: String, color: Color) -> void:
	_content.clear()
	_content.append_text(_colored(message_, color))


func _process(_delta: float) -> void:
	if _content != null and _content.is_visible_in_tree():
		_content.queue_redraw()


func show_update() -> void:
	if not GdUnitSettings.is_update_notification_enabled():
		_header.text = "No update is available."
		message_h4("The search for updates is deactivated.", Color.CORNFLOWER_BLUE)
		_update_button.set_disabled(true)
		return

	if not await request_releases():
		return
	_update_button.set_disabled(true)

	prints("Scan for GdUnit4 Update ...")
	message_h4("\n\n\nRequest release infos ... ", Color.SNOW)
	_content.add_image(GdUnitUiTools.get_spinner(), 32, 32)

	var content: String
	if _debug_mode:
		await get_tree().create_timer(.2).timeout
		var template := FileAccess.open("res://addons/gdUnit4/test/update/resources/http_response_releases.txt", FileAccess.READ).get_as_text()
		content = await _md_reader.to_bbcode(template)
	else:
		var response :GdUnitUpdateClient.HttpResponse = await _update_client.request_releases()
		if response.status() == 200:
			content = await extract_releases(response, _current_version)
		else:
			message_h4("\n\n\nError checked request available releases!", Color.INDIAN_RED)
			return

	# finally force rescan to import images as textures
	if Engine.is_editor_hint():
		await rescan()
	message(content, Color.CADET_BLUE)
	_update_button.set_disabled(false)



func extract_zip_url(response: GdUnitUpdateClient.HttpResponse) -> String:
	var body :Array = response.response()
	return body[0]["zipball_url"]


func extract_releases(response: GdUnitUpdateClient.HttpResponse, current_version: GdUnit4Version) -> String:
	await get_tree().process_frame
	var result := ""
	for release :Dictionary in response.response():
		var release_version := str(release["tag_name"])
		if GdUnit4Version.parse(release_version).equals(current_version):
			break
		var release_description := _colored("<h1>GdUnit Release %s</h1>" % release_version, Color.CORNFLOWER_BLUE)
		release_description += "\n"
		release_description += release["body"]
		release_description += "\n\n"
		result += await _md_reader.to_bbcode(release_description)
	return result


func rescan() -> void:
	if Engine.is_editor_hint():
		if OS.is_stdout_verbose():
			prints(".. reimport release resources")
		var fs := EditorInterface.get_resource_filesystem()
		fs.scan()
		while fs.is_scanning():
			if OS.is_stdout_verbose():
				progressBar(fs.get_scanning_progress() * 100 as int)
			await get_tree().process_frame
		await get_tree().process_frame
	await get_tree().create_timer(1).timeout


func progressBar(p_progress: int) -> void:
	if p_progress < 0:
		p_progress = 0
	if p_progress > 100:
		p_progress = 100
	printraw("scan [%-50s] %-3d%%\r" % ["".lpad(int(p_progress/2.0), "#").rpad(50, "-"), p_progress])


@warning_ignore("return_value_discarded")
func _on_update_pressed() -> void:
	_update_button.set_disabled(true)
	# close all opend scripts before start the update
	if not _debug_mode:
		ScriptEditorControls.close_open_editor_scripts()
	# copy update source to a temp because the update is deleting the whole gdUnit folder
	DirAccess.make_dir_absolute("res://addons/.gdunit_update")
	DirAccess.copy_absolute("res://addons/gdUnit4/src/update/GdUnitUpdate.tscn", "res://addons/.gdunit_update/GdUnitUpdate.tscn")
	DirAccess.copy_absolute("res://addons/gdUnit4/src/update/GdUnitUpdate.gd", "res://addons/.gdunit_update/GdUnitUpdate.gd")
	var source := FileAccess.open("res://addons/gdUnit4/src/update/GdUnitUpdate.tscn", FileAccess.READ)
	var content := source.get_as_text().replace("res://addons/gdUnit4/src/update/GdUnitUpdate.gd", "res://addons/.gdunit_update/GdUnitUpdate.gd")
	var dest := FileAccess.open("res://addons/.gdunit_update/GdUnitUpdate.tscn", FileAccess.WRITE)
	dest.store_string(content)
	_update_progress.set_visible(true)


func _on_show_next_toggled(enabled: bool) -> void:
	GdUnitSettings.set_update_notification(enabled)


func _on_cancel_pressed() -> void:
	hide()


func _on_content_meta_clicked(meta: String) -> void:
	var properties: Dictionary = str_to_var(meta)
	if properties.has("url"):
		@warning_ignore("return_value_discarded")
		OS.shell_open(str(properties.get("url")))


func _on_content_meta_hover_started(meta: String) -> void:
	var properties: Dictionary = str_to_var(meta)
	if properties.has("tool_tip"):
		_content.set_tooltip_text(str(properties.get("tool_tip")))


@warning_ignore("unused_parameter")
func _on_content_meta_hover_ended(meta: String) -> void:
	_content.set_tooltip_text("")


func _on_visibility_changed() -> void:
	if not is_visible_in_tree():
		return
	if _update_progress != null:
		_update_progress.set_visible(false)
	await show_update()
extends Control
extends Button

@export var value_control : Control

func _ready():
	pressed.connect(_on_pressed)

func _on_pressed():
	value_control.value = value_control.max_value
extends Button

@export var value_change : int = 1
@export var value_control : Control

func _ready():
	pressed.connect(_on_pressed)

func _on_pressed():
	value_control.value += value_change
class_name CostView
extends RichTextLabel

## The view holding the items being shopped for which the cost is calculated from
## depending on the number and type of items selected.
@export var shop_view : ItemContainerView :
	set(value):
		if shop_view != null:
			shop_view.selected_items_changed.disconnect(_on_view_selected_items_changed)
			
		shop_view = value
		
		if shop_view != null:
			shop_view.selected_items_changed.connect(_on_view_selected_items_changed)

## The template for showing the cost. Keep %d so the calculated cost
## can be added to the string.
@export var text_template : String = "COST: %d"

## The cost of the current transaction being proposed
var cost : float = 0.0 :
	set(value):
		cost = value
		update_text()

func _ready() -> void:
	validate()
	update_text()

## Adds the price of all the selected items in all stack views together to come up with
## a total cost.
## TODO: Modify by price multiplier if any
func calculate_cost(p_stack_views : Array[StackView]) -> float:
	var total_cost := 0.0
	
	for view in p_stack_views:
		if view.item_stack == null || view.item_stack.item == null: continue # No item to calculate
		
		total_cost += view.selected_count * view.item_stack.item.value
	
	return total_cost
	
func update_text() -> void:
	text = text_template % cost
	
func validate() -> bool:
	var no_issues := true
	
	if shop_view == null:
		push_warning("No stock view assigned, shopping cost will not update.")
		no_issues = false
		
	return no_issues

func _on_view_selected_items_changed(p_stack_views : Array[StackView]) -> void:
	cost = calculate_cost(p_stack_views)
extends GdUnitTestSuite
@warning_ignore('unused_parameter')
@warning_ignore('return_value_discarded')

# Predefined test inventories
var empty_inventory: FlexInventory
var single_container_inventory: FlexInventory
var multi_container_inventory: FlexInventory
var full_inventory: FlexInventory
var tagged_items_inventory: FlexInventory
var no_partial_add_inventory: FlexInventory  # New inventory
var limited_type: ItemContainerType
var test_item: FlexItem
var tagged_item: FlexItem
var test_tag: ItemTag

func before_test():
	# Common setup
	limited_type = ItemContainerType.new()
	limited_type.size = 2
	limited_type.allow_partial_adds = true
	test_item = FlexItem.new()
	test_item.stack_maximum = 2
	test_tag = ItemTag.new()
	
	tagged_item = FlexItem.new()
	tagged_item.tags = [test_tag] as Array[ItemTag]
	tagged_item.stack_maximum = 3

	# 1. Empty inventory
	empty_inventory = FlexInventory.new()

	# 2. Single container with empty slots
	single_container_inventory = FlexInventory.new()
	var single_container = ItemContainer.new(limited_type)
	single_container_inventory.item_containers = [single_container]

	# 3. Multiple containers with varying capacities
	multi_container_inventory = FlexInventory.new()
	var container1 = ItemContainer.new(limited_type)  # Size 2
	var container2 = ItemContainer.new()
	var container2_type = ItemContainerType.new()
	container2_type.size = 3
	container2.type = container2_type
	multi_container_inventory.item_containers = [container1, container2]

	# 4. Full inventory with items
	full_inventory = FlexInventory.new()
	var full_container = ItemContainer.new(limited_type)
	full_container.add_items(test_item, 4)  # Fill it completely (stack_maximum = 2) * size of 2 = 4 total
	full_inventory.item_containers = [full_container]

	# 5. Inventory with tagged items
	tagged_items_inventory = FlexInventory.new()
	var tagged_container = ItemContainer.new(limited_type)
	tagged_container.add_items(tagged_item, 2) # 2 out of 3 full
	tagged_items_inventory.item_containers = [tagged_container]

	# 6. Inventory with no partial adds allowed
	no_partial_add_inventory = FlexInventory.new()
	var no_partial_container = ItemContainer.new()
	var no_partial_type = ItemContainerType.new()
	no_partial_type.size = 2
	no_partial_type.allow_partial_adds = false  # Key difference: no partial adds
	no_partial_container.type = no_partial_type
	no_partial_add_inventory.item_containers = [no_partial_container]

	# Default inventory for tests that don't specify one
	assert_bool(limited_type.has_unlimited_space).is_false()

@warning_ignore("unused_parameter")
func test_add_items(p_amount_to_add: int, p_inventory: FlexInventory, p_expected_added: int, p_test_name: String, test_parameters := [
	[5, single_container_inventory, 4, "Single container with limited space"],        # Size 2, 2 items/stack, max 4 (2 stacks × 2)
	[3, multi_container_inventory, 3, "Multiple containers with partial add"],        # Size 2+3=5, 2 items/stack, takes 3 (partial add)
	[10, multi_container_inventory, 10, "Multiple containers with full capacity"],    # Size 2+3=5, 2 items/stack, max 10 (5 stacks × 2)
	[2, full_inventory, 0, "Full inventory add attempt"],                             # Size 2, already full with 4 items
	[0, empty_inventory, 0, "Zero count add to empty inventory"],                     # No containers, max 0
	[5, tagged_items_inventory, 2, "Add to tagged inventory with existing items"],    # Size 2, 2nd stack takes 2 items
	[5, tagged_items_inventory, 2, "Only space for 2 in Tagged Inventory"],           # Size 2, 2nd stack takes 2 items
	[2, empty_inventory, 0, "Add to inventory with no containers"],                   # No containers, max 0
	[4, no_partial_add_inventory, 4, "No partial adds, full capacity add"],           # Size 2, 2 items/stack, max 4 (2 stacks × 2), no partial but fits
	[5, no_partial_add_inventory, 0, "No partial adds, insufficient space"]           # Size 2, 2 items/stack, max 4, but 3 < 4 so 0 added
]) -> void:
	# Use a fresh instance of test_item for consistency
	var item = FlexItem.new()
	item.stack_maximum = 2  # Match the default stack_maximum from before_test

	# Clone the inventory to avoid modifying the original
	var test_inventory = p_inventory.duplicate(true)
	
	var result = test_inventory.add_items(item, p_amount_to_add)
	assert_int(result)\
		.append_failure_message("Should add correct number of items for: " + p_test_name)\
		.is_equal(p_expected_added)

@warning_ignore("unused_parameter")
func test_get_item_count(p_inventory: FlexInventory, p_expected_count: int, p_test_name: String, test_parameters := [
	[empty_inventory, 0, "Empty inventory with no items"],                    # No containers, 0 items
	[single_container_inventory, 0, "Single container with no items"],        # Size 2, empty, 0 items
	[multi_container_inventory, 0, "Multiple containers with no items"],      # Size 2+3, empty, 0 items
	[full_inventory, 4, "Full inventory with 4 items"],                      # Size 2, 2 test_items each, 4 total
	[tagged_items_inventory, 0, "Tagged inventory with different items"],     # Size 2, 2 tagged items, 0 test_items
	[no_partial_add_inventory, 0, "No partial adds inventory, empty"]         # Size 2, empty, 0 test_items
]) -> void:
	# Use the test_item defined in before_test for consistency
	var result = p_inventory.get_item_count(test_item)
	assert_int(result)\
		.append_failure_message("Should return correct item count for: " + p_test_name)\
		.is_equal(p_expected_count)
		
@warning_ignore("unused_parameter")
func test_remove_items(p_amount_to_remove: int, p_inventory: FlexInventory, p_partial_remove: bool, p_expected_removed: int, p_test_name: String, test_parameters := [
	[2, empty_inventory, false, 0, "Empty inventory, no partial remove"],              # No items, 0 removed
	[2, single_container_inventory, true, 0, "Single container empty, partial remove"], # Size 2, empty, 0 removed
	[5, full_inventory, false, 0, "Full inventory, not enough for full remove"],       # 4 items, need 5, no partial, 0 removed
	[5, full_inventory, false, 0, "Full inventory, exceed count, no partial"],         # 4 items, need 5, no partial, 0 removed
	[4, full_inventory, false, 4, "Full inventory, exact count, no partial"],          # 4 items, remove 4, all removed
	[2, full_inventory, true, 2, "Full inventory, partial remove allowed"],            # 4 items, remove 2, 2 removed
	[5, full_inventory, true, 4, "Full inventory, exceed count, partial remove"],      # 4 items, remove up to 4
	[1, tagged_items_inventory, false, 0, "Tagged inventory, different item type"],    # 2 tagged items, 0 test_items, 0 removed
	[2, no_partial_add_inventory, false, 0, "No partial adds, empty inventory"],       # Size 2, empty, 0 removed
]) -> void:
	# Clone the inventory to avoid modifying the original
	var test_inventory = p_inventory.duplicate(true)
	
	# Use test_item from before_test for consistency
	var result = test_inventory.remove_items(test_item, p_amount_to_remove, p_partial_remove)
	assert_int(result)\
		.append_failure_message("Should remove correct number of items for: " + p_test_name)\
		.is_equal(p_expected_removed)

@warning_ignore("unused_parameter")
func test_get_item_space(p_inventory: FlexInventory, p_expected_space: int, p_test_name: String, test_parameters := [
	[empty_inventory, 0, "Empty inventory with no containers"],                    # No containers, 0 space
	[single_container_inventory, 4, "Single container with empty slots"],          # Size 2, 2 items/stack, max 4 (2 × 2)
	[multi_container_inventory, 10, "Multiple containers with empty slots"],       # Size 2+3=5, 2 items/stack, max 10 (5 × 2)
	[full_inventory, 0, "Full inventory with no space"],                          # Size 2, 4 items (2 stacks × 2), 0 space
	[tagged_items_inventory, 2, "Tagged inventory with partial space"],            # Size 2, 2 tagged items (1 stack), 2 space (1 stack × 2)
	[no_partial_add_inventory, 4, "No partial adds inventory with empty slots"]    # Size 2, 2 items/stack, max 4 (2 × 2)
]) -> void:
	# Use test_item from before_test for consistency
	var result = p_inventory.get_item_space(test_item)
	assert_int(result)\
		.append_failure_message("Should return correct item space for: " + p_test_name)\
		.is_equal(p_expected_space)

@warning_ignore("unused_parameter")
func test_get_total_stacks(p_inventory: FlexInventory, p_expected_stacks: int, p_test_name: String, test_parameters := [
	[empty_inventory, 0, "Empty inventory with no containers"],                    # No containers, 0 stacks
	[single_container_inventory, 2, "Single container with 2 stacks"],             # Size 2, 2 stacks
	[multi_container_inventory, 5, "Multiple containers with 5 stacks"],           # Size 2+3, 5 stacks
	[full_inventory, 2, "Full inventory with 2 stacks"],                          # Size 2, 2 stacks
	[tagged_items_inventory, 2, "Tagged inventory with 2 stacks"],                 # Size 2, 2 stacks
	[no_partial_add_inventory, 2, "No partial adds inventory with 2 stacks"]       # Size 2, 2 stacks
]) -> void:
	var result = p_inventory.get_total_stacks()
	assert_int(result)\
		.append_failure_message("Should return correct number of stacks for: " + p_test_name)\
		.is_equal(p_expected_stacks)
		
@warning_ignore("unused_parameter")
func test_get_item_count_with_tag(p_inventory: FlexInventory, p_tag: ItemTag, p_expected_count: int, p_test_name: String, test_parameters := [
	[empty_inventory, test_tag, 0, "Empty inventory with no tagged items"],           # No containers, 0 tagged items
	[single_container_inventory, test_tag, 0, "Single container with no tagged items"],# Size 2, empty, 0 tagged items
	[multi_container_inventory, test_tag, 0, "Multiple containers with no tagged items"], # Size 2+3, empty, 0 tagged items
	[full_inventory, test_tag, 0, "Full inventory with untagged items"],              # 4 test_items, no test_tag, 0 tagged
	[tagged_items_inventory, test_tag, 2, "Tagged inventory with 2 tagged items"],    # 2 tagged_items with test_tag
	[no_partial_add_inventory, test_tag, 0, "No partial adds inventory, no tagged items"] # Size 2, empty, 0 tagged items
]) -> void:
	var result = p_inventory.get_item_count_with_tag(p_tag)
	assert_int(result)\
		.append_failure_message("Should return correct tagged item count for: " + p_test_name)\
		.is_equal(p_expected_count)

func test_money_change_signal():
	var signal_results: Array = []
	empty_inventory.money_changed.connect(func(money): signal_results.append(money))
	empty_inventory.money = 10.0
	assert_float(signal_results[0])\
		.append_failure_message("There should be signal results equal to the money set")\
		.is_equal(empty_inventory.money)

func test_add_container_sets_inventory() -> void:
	# Create a fresh inventory and container
	var test_inventory = FlexInventory.new()
	var test_container = ItemContainer.new(limited_type)
	
	# Add the container and check if inventory is set
	test_inventory.add_container(test_container)
	assert_object(test_container.inventory)\
		.append_failure_message("Container inventory should be set to FlexInventory after add_container")\
		.is_equal(test_inventory)
	assert_array(test_inventory.item_containers)\
		.append_failure_message("Container should be in item_containers after add_container")\
		.contains_exactly([test_container])

	# Add it again (shouldn't duplicate, but re-check inventory)
	test_inventory.add_container(test_container)
	assert_object(test_container.inventory)\
		.append_failure_message("Container inventory should remain set after redundant add_container")\
		.is_equal(test_inventory)
	assert_array(test_inventory.item_containers)\
		.append_failure_message("Container should not be duplicated in item_containers")\
		.contains_exactly([test_container])

func test_remove_container_clears_inventory() -> void:
	# Create a fresh inventory with a container
	var test_inventory = FlexInventory.new()
	var test_container = ItemContainer.new(limited_type)
	test_inventory.add_container(test_container)
	
	# Verify initial state
	assert_object(test_container.inventory)\
		.append_failure_message("Container inventory should be set before removal")\
		.is_equal(test_inventory)
	assert_array(test_inventory.item_containers)\
		.append_failure_message("Container should be in item_containers before removal")\
		.contains_exactly([test_container])
	
	# Remove the container and check results
	var result = test_inventory.remove_container(test_container)
	assert_bool(result)\
		.append_failure_message("remove_container should return true when container is removed")\
		.is_true()
	assert_object(test_container.inventory)\
		.append_failure_message("Container inventory should be null after removal")\
		.is_null()
	assert_array(test_inventory.item_containers)\
		.append_failure_message("item_containers should be empty after removal")\
		.is_empty()
	
	# Try removing it again (should fail)
	result = test_inventory.remove_container(test_container)
	assert_bool(result)\
		.append_failure_message("remove_container should return false when container is not present")\
		.is_false()
	assert_object(test_container.inventory)\
		.append_failure_message("Container inventory should remain null after failed removal")\
		.is_null()

@warning_ignore("unused_parameter")
func test_get_space(p_inventory: FlexInventory, p_item: FlexItem, p_expected_space: int, p_test_name: String, test_parameters := [
	[empty_inventory, test_item, 0, "Empty inventory has no containers"],                    # No containers
	[single_container_inventory, test_item, 4, "Single container size 2, stack max 2"],     # Size 2 × stack 2 = 4
	[multi_container_inventory, test_item, 10, "Multi container sizes 2+3, stack max 2"],   # (Size 2 + 3) × stack 2 = 10
	[full_inventory, test_item, 0, "Full inventory has no space"],                          # Size 2, but full
	[tagged_items_inventory, test_item, 2, "Tagged container size 2, has 2 items"],         # Size 2, 2 slots left
	[no_partial_add_inventory, test_item, 4, "No partial container size 2, empty"],         # Size 2 × stack 2 = 4
	[tagged_items_inventory, tagged_item, 4, "Tagged container for tagged item"],           # Size 2 × stack 3 = 6 - 2 existing = 4
	[full_inventory, tagged_item, 0, "Full inventory for tagged item"]                      # Size 2, but full
]) -> void:
	var result = p_inventory.get_space(p_item)
	assert_int(result)\
		.append_failure_message("Should return correct space for: " + p_test_name)\
		.is_equal(p_expected_space)
# GdUnitTestSuite for FlexInventory.get_item_count_with_tag with hierarchy support
class_name TestFlexInventoryGetItemCountWithTag
extends GdUnitTestSuite

# Predefined tag instances for consistent testing (reference-based equality)
var equipment_tag: ItemTag
var weapon_tag: ItemTag
var sword_tag: ItemTag  # Subcategory of weapon
var armor_tag: ItemTag
var potion_tag: ItemTag
var inventory: FlexInventory

# Setup before each test
func before_test() -> void:
	equipment_tag = ItemTag.new("Equipment")
	equipment_tag.description = "General equipment items"
	equipment_tag.color = Color.GRAY
	
	weapon_tag = ItemTag.new("Weapon", equipment_tag)
	weapon_tag.description = "Tags weapons and tools"
	weapon_tag.color = Color.RED
	
	sword_tag = ItemTag.new("Sword", weapon_tag)
	sword_tag.description = "Tags bladed weapons"
	sword_tag.color = Color.DARK_RED
	
	armor_tag = ItemTag.new("Armor", equipment_tag)
	armor_tag.description = "Tags protective gear"
	armor_tag.color = Color.BLUE
	
	potion_tag = ItemTag.new("Potion")
	potion_tag.description = "Tags consumable potions"
	potion_tag.color = Color.GREEN
	
	inventory = FlexInventory.new()
	inventory.item_containers = [] as Array[ItemContainer]

# Helper function to create a container with tagged items from a dictionary
func create_container(tag_counts: Dictionary[ItemTag, int]) -> ItemContainer:
	var container = ItemContainer.new()
	var container_type = ItemContainerType.new()
	container_type.size = 10
	container.type = container_type
	
	for tag in tag_counts.keys():
		if tag != null:
			var count = tag_counts[tag]
			var flex_item = FlexItem.new()
			var tag_array: Array[ItemTag] = []
			tag_array.append(tag)
			flex_item.tags = tag_array
			var flex_stack = FlexStack.new()
			flex_stack.item = flex_item
			flex_stack.count = count
			container._slots.append(flex_stack)
	
	return container

# Parameterized test for common scenarios
@warning_ignore("unused_parameter")
func test_get_item_count_with_tag_scenarios(
	p_containers_data: Array,              # Untyped Array to avoid nested typing issues
	p_tag: ItemTag,                        # Tag to query
	p_expected_count: int,                 # Expected total count
	p_test_name: String,                   # Test case description
	test_parameters := [
		# Empty inventory
		[ [], weapon_tag, 0, "Empty inventory with valid tag" ],
		
		# Direct match: weapon_tag items queried with weapon_tag
		[ [ {"tag": weapon_tag, "count": 3} ], weapon_tag, 3, "Direct tag match" ],
		
		# Subcategory: sword_tag items queried with parent weapon_tag
		[ [ {"tag": sword_tag, "count": 2} ], weapon_tag, 2, "Subcategory match (weapon counts sword)" ],
		
		# Parent tag: equipment_tag counts weapon_tag and armor_tag
		[ [ {"tag": weapon_tag, "count": 2}, {"tag": armor_tag, "count": 1} ], equipment_tag, 3, "Parent tag matches subcategories" ],
		
		# No match: potion_tag items queried with unrelated weapon_tag
		[ [ {"tag": potion_tag, "count": 5} ], weapon_tag, 0, "No matching tags" ],
		
		# Zero count: weapon_tag 0 doesn’t count, sword_tag does under equipment_tag
		[ [ {"tag": weapon_tag, "count": 0}, {"tag": sword_tag, "count": 2} ], equipment_tag, 2, "Zero count with subcategory" ],
		
		# Two-level hierarchy: sword_tag counted by grandparent equipment_tag
		[ [ {"tag": sword_tag, "count": 1} ], equipment_tag, 1, "Two-level hierarchy (equipment counts sword)" ]
	]) -> void:
	inventory.item_containers = [] as Array[ItemContainer]
	
	# Process each dictionary in p_containers_data into a typed Dictionary[ItemTag, int]
	for data_entry in p_containers_data:
		if data_entry.is_empty():
			continue
		var tag_dict: Dictionary[ItemTag, int] = {}
		var entry_dict: Dictionary = data_entry  # Cast to untyped Dictionary for access
		tag_dict[entry_dict["tag"] as ItemTag] = entry_dict["count"] as int
		inventory.item_containers.append(create_container(tag_dict))
	
	var result = inventory.get_item_count_with_tag(p_tag)
	assert_int(result)\
		.append_failure_message("Failed for: " + p_test_name)\
		.is_equal(p_expected_count)

# Test null tag input
func test_null_tag_input() -> void:
	inventory.item_containers = [create_container({weapon_tag: 3, armor_tag: 2} as Dictionary[ItemTag, int])] as Array[ItemContainer]
	var result = inventory.get_item_count_with_tag(null)
	assert_int(result)\
		.append_failure_message("Expected 0 for null tag")\
		.is_equal(0)

# Test item with multiple tags including hierarchy
func test_item_with_multiple_tags() -> void:
	inventory.item_containers = [] as Array[ItemContainer]
	var container = ItemContainer.new()
	var container_type = ItemContainerType.new()
	container_type.size = 10
	container.type = container_type
	
	var flex_item = FlexItem.new()
	var tag_array: Array[ItemTag] = []
	tag_array.append(sword_tag)
	tag_array.append(potion_tag)
	flex_item.tags = tag_array
	var flex_stack = FlexStack.new()
	flex_stack.item = flex_item
	flex_stack.count = 4
	container._slots.append(flex_stack)
	inventory.item_containers.append(container)
	
	var sword_count = inventory.get_item_count_with_tag(sword_tag)
	assert_int(sword_count)\
		.append_failure_message("Sword tag should count direct match")\
		.is_equal(4)
	
	var weapon_count = inventory.get_item_count_with_tag(weapon_tag)
	assert_int(weapon_count)\
		.append_failure_message("Weapon tag should count sword as subcategory")\
		.is_equal(4)
	
	var equipment_count = inventory.get_item_count_with_tag(equipment_tag)
	assert_int(equipment_count)\
		.append_failure_message("Equipment tag should count sword as subcategory")\
		.is_equal(4)
	
	var potion_count = inventory.get_item_count_with_tag(potion_tag)
	assert_int(potion_count)\
		.append_failure_message("Potion tag should count direct match")\
		.is_equal(4)

# Test large inventory with hierarchy
func test_large_inventory() -> void:
	inventory.item_containers = [] as Array[ItemContainer]
	for i in range(5):
		inventory.item_containers.append(create_container({
			weapon_tag: 100,
			sword_tag: 50,
			armor_tag: 75
		} as Dictionary[ItemTag, int]))
	
	var equipment_count = inventory.get_item_count_with_tag(equipment_tag)
	assert_int(equipment_count)\
		.append_failure_message("Expected correct sum for large inventory with subcategories")\
		.is_equal(5 * (100 + 50 + 75))
	
	var weapon_count = inventory.get_item_count_with_tag(weapon_tag)
	assert_int(weapon_count)\
		.append_failure_message("Weapon tag should count weapon and sword")\
		.is_equal(5 * (100 + 50))

# Test after modifying container contents
func test_after_container_modification() -> void:
	inventory.item_containers = [create_container({weapon_tag: 3} as Dictionary[ItemTag, int])] as Array[ItemContainer]
	assert_int(inventory.get_item_count_with_tag(equipment_tag))\
		.is_equal(3)
	
	var container = inventory.item_containers[0]
	var new_stack = FlexStack.new()
	new_stack.item = FlexItem.new()
	var tag_array: Array[ItemTag] = []
	tag_array.append(sword_tag)
	new_stack.item.tags = tag_array
	new_stack.count = 2
	container._slots.append(new_stack)
	
	var result = inventory.get_item_count_with_tag(equipment_tag)
	assert_int(result)\
		.append_failure_message("Expected updated count with subcategory after modification")\
		.is_equal(5)
# GdUnit 4.5 Test Suite for ItemContainer initialization
class_name TestItemContainerInit
extends GdUnitTestSuite

# Test resources
var item_container: ItemContainer

# Setup before each test
func before_test() -> void:
	pass  # No persistent setup needed; each test creates its own instance

# Parameterized test: Verify handle_empty_space() runs on init for each EmptyMode and null type
func test_handle_empty_space_on_init(
	empty_mode: Variant,  # Using Variant to allow null
	expected_slots_size: int,
	test_parameters := [
		[ItemContainerType.EmptyMode.FILL, 10],   # FILL: 10 slots filled with empty stacks
		[ItemContainerType.EmptyMode.REMOVE, 0],  # REMOVE: 0 slots (no initial stacks)
		[ItemContainerType.EmptyMode.IGNORE, 0],  # IGNORE: 0 slots (no initial stacks)
		[null, 0],                                # Null type: 0 slots (default behavior)
	]
) -> void:
	# Arrange: Create ItemContainerType or use null
	var container_type = null
	if empty_mode != null:
		container_type = ItemContainerType.new()
		container_type.size = 10  # Set size to 10 for FILL mode to fill up to
		container_type.empty_mode = empty_mode
	
	# Act: Initialize ItemContainer
	item_container = ItemContainer.new(container_type)
	
	# Assert: Check that handle_empty_space() ran as expected
	assert_that(item_container.get_stacks().size())\
		.append_failure_message("Slots size should match expected for mode: %s" % (empty_mode if empty_mode != null else "NULL"))\
		.is_equal(expected_slots_size)
	
	# Additional checks based on mode
	if empty_mode != null:
		match empty_mode:
			ItemContainerType.EmptyMode.FILL:
				# Verify all slots are empty FlexStacks with correct slot and container
				assert_that(item_container.get_stacks().size())\
					.append_failure_message("FILL mode should create 10 slots")\
					.is_equal(10)
				for i in item_container.get_stacks().size():
					var stack = item_container.get_stacks()[i]
					assert_that(stack.item)\
						.append_failure_message("Stack at index %d should have null item in FILL mode" % i)\
						.is_null()
					assert_that(stack.count)\
						.append_failure_message("Stack at index %d should have count 0 in FILL mode" % i)\
						.is_equal(0)
					assert_that(stack.container)\
						.append_failure_message("Stack at index %d should have container set to ItemContainer" % i)\
						.is_equal(item_container)
					assert_that(stack.slot)\
						.append_failure_message("Stack at index %d should have slot set to its index" % i)\
						.is_equal(i)
			ItemContainerType.EmptyMode.REMOVE, ItemContainerType.EmptyMode.IGNORE:
				# Verify no stacks exist initially
				assert_that(item_container.get_stacks().is_empty())\
					.append_failure_message("%s mode should have no stacks" % ("REMOVE" if empty_mode == ItemContainerType.EmptyMode.REMOVE else "IGNORE"))\
					.is_true()
	else:
		# Null type case
		assert_that(item_container.type)\
			.append_failure_message("Null type should result in null ItemContainerType")\
			.is_null()
		assert_that(item_container.get_stacks().is_empty())\
			.append_failure_message("Null type should have no stacks")\
			.is_true()
	
	# Log for debugging (visible in Godot Output, potentially in GdUnit Inspector in debug mode)
	var mode_name = "NULL" if empty_mode == null else ["REMOVE", "IGNORE", "FILL"][empty_mode]
	print("Initialized %s mode, slots size: %d" % [mode_name, item_container.get_stacks().size()])
class_name TestInventoryResource
extends GdUnitTestSuite

var _item: FlexItem
var _base_resource: InventoryResource

# Mock class for testing
class MockInventoryResource extends InventoryResource:
	var _can_accept := false
	var _space := 0
	
	func _init(can_accept := false, space := 0):
		_can_accept = can_accept
		_space = space
	
	func can_accept_item(p_item: FlexItem) -> bool:
		return _can_accept
	
	func get_space(_p_item: FlexItem) -> int:
		return _space
	
	func add_items(p_item: FlexItem, p_count: int) -> int:
		return p_count if _can_accept and _space >= p_count else 0

func before_test():
	_item = FlexItem.new()
	_base_resource = InventoryResource.new()

func test_add_items(count: int, expected: int, test_parameters := [
	[0, 0],  # Base case
	[1, 0],  # Should fail in base class
	[100, 0]  # Should fail with large number
]) -> void:
	assert_int(_base_resource.add_items(_item, count)).is_equal(expected)

func test_has_space(space: int, count: int, can_accept: bool, expected: bool, test_parameters := [
	[0, 0, true, true],    # Zero items, has space
	[10, 5, true, true],   # Has enough space
	[5, 10, true, false],  # Not enough space
	[10, 5, false, false], # Can't accept item
	[0, 0, false, false]   # Can't accept zero items
]) -> void:
	var resource := MockInventoryResource.new(can_accept, space)
	assert_bool(resource.has_space_for_items(_item, count)).is_equal(expected)

func test_can_accept(expected: bool, test_parameters := [
	[false]  # Base class always returns false
]) -> void:
	assert_bool(_base_resource.can_accept_item(_item)).is_equal(expected)

func test_get_space(expected: int, test_parameters := [
	[0]  # Base class always returns 0
]) -> void:
	assert_int(_base_resource.get_space(_item)).is_equal(expected)

# Non-parameterized tests for hierarchy
func test_get_root_hierarchy() -> void:
	var root := MockInventoryResource.new()
	var child1 := MockInventoryResource.new()
	var child2 := MockInventoryResource.new()
	
	child2.parent = child1
	child1.parent = root
	
	assert_that(child2.get_root()).is_same(root)
	assert_that(child1.get_root()).is_same(root)
	assert_that(root.get_root()).is_same(root)

func test_get_root_no_parent() -> void:
	var resource := MockInventoryResource.new()
	assert_that(resource.get_root()).is_same(resource)
extends GdUnitTestSuite
@warning_ignore('unused_parameter')
@warning_ignore('return_value_discarded')

var empty_container : ItemContainer
var no_match_container : ItemContainer
var single_match_container : ItemContainer
var multi_match_container : ItemContainer
var mixed_container : ItemContainer
var zero_count_container : ItemContainer
var null_items_container : ItemContainer
var completely_full_container : ItemContainer # Akl slots filled to stack maximum for given items
var multi_10_container : ItemContainer
# New containers for additional cases
var full_10_container : ItemContainer  # Full capacity with test_item_10_per_stack only
var all_slots_occupied_container : ItemContainer # All slots occupied with varying counts
var tag_restricted_container : ItemContainer

var tag_type : ItemTag
var item_with_tag : FlexItem
var test_item_1_per_stack : FlexItem
var test_item_10_per_stack : FlexItem

func before() -> void:
	test_item_1_per_stack = FlexItem.new()
	test_item_1_per_stack.stack_maximum = 1
	test_item_10_per_stack = FlexItem.new()
	test_item_10_per_stack.stack_maximum = 10
	
	tag_type = ItemTag.new()
	item_with_tag = FlexItem.new("hasTag", null, [tag_type], 100)

func before_test() -> void:
	var container_type := ItemContainerType.new()
	container_type.size = 12
	container_type.empty_mode = ItemContainerType.EmptyMode.IGNORE
	
	var restrictive_type := ItemContainerType.new()
	restrictive_type.allowed_tags = [tag_type]
	restrictive_type.size = 1
	restrictive_type.empty_mode = ItemContainerType.EmptyMode.IGNORE
	
	empty_container = ItemContainer.new(container_type)
	empty_container._slots = []
	
	no_match_container = ItemContainer.new(container_type)
	no_match_container._slots = [
		FlexStack.new(test_item_10_per_stack, 5),
		FlexStack.new(test_item_10_per_stack, 3)
	]
	
	single_match_container = ItemContainer.new(container_type)
	single_match_container._slots = [
		FlexStack.new(test_item_1_per_stack, 1)
	]
	
	multi_match_container = ItemContainer.new(container_type)
	multi_match_container._slots = [
		FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_1_per_stack, 0)
	]
	
	mixed_container = ItemContainer.new(container_type)
	mixed_container._slots = [
		FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 5),
		FlexStack.new(test_item_1_per_stack, 1)
	]
	
	zero_count_container = ItemContainer.new(container_type)
	zero_count_container._slots = [
		FlexStack.new(test_item_1_per_stack, 0),
		FlexStack.new(test_item_1_per_stack, 0)
	]
	
	null_items_container = ItemContainer.new(container_type)
	null_items_container._slots = [
		FlexStack.new(null, 0),
		FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(null, 0)
	]
	
	# Container is completely full. No room for new items.
	completely_full_container = ItemContainer.new(container_type)
	completely_full_container._slots = [
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1),
	]
	var full_size := completely_full_container.get_stacks().size()
	assert_int(full_size).append_failure_message("Container expected to be full in before_test").is_equal(container_type.size)
	
	multi_10_container = ItemContainer.new(container_type)
	multi_10_container._slots = [
		FlexStack.new(test_item_10_per_stack, 5),
		FlexStack.new(test_item_10_per_stack, 3),
		FlexStack.new(test_item_1_per_stack, 1)
	]
	
	# New item_container: Full capacity with test_item_10_per_stack only
	full_10_container = ItemContainer.new(container_type)
	full_10_container._slots = [
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_10_per_stack, 10)
	]
	
	all_slots_occupied_container = ItemContainer.new(container_type)
	all_slots_occupied_container._slots = [
		FlexStack.new(test_item_10_per_stack, 1), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 3), FlexStack.new(test_item_1_per_stack, 0),
		FlexStack.new(test_item_10_per_stack, 5), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 7), FlexStack.new(test_item_1_per_stack, 0),
		FlexStack.new(test_item_10_per_stack, 9), FlexStack.new(test_item_1_per_stack, 1),
		FlexStack.new(test_item_10_per_stack, 10), FlexStack.new(test_item_1_per_stack, 1)
	]
	
	tag_restricted_container = ItemContainer.new(restrictive_type)
	
# Basic init tests - checks on the item containers
func test_init() -> void:
	assert_int(empty_container.get_stacks().size()).append_failure_message("Container should be empty").is_equal(0)
	assert_int(tag_restricted_container.get_stacks().size()).append_failure_message("Container should be empty").is_equal(0)

@warning_ignore("unused_parameter")
func test_get_space_for_item(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_expected : int,
	test_parameters := [
		[empty_container, test_item_1_per_stack, 12],
		[empty_container, test_item_10_per_stack, 120],
		[no_match_container, test_item_1_per_stack, 10],
		[no_match_container, test_item_10_per_stack, 112],
		[single_match_container, test_item_1_per_stack, 11],
		[multi_match_container, test_item_1_per_stack, 10],
		[mixed_container, test_item_1_per_stack, 9],
		[mixed_container, test_item_10_per_stack, 95],
		[zero_count_container, test_item_1_per_stack, 12],
		[null_items_container, test_item_1_per_stack, 11],
		[completely_full_container, test_item_1_per_stack, 0],
		[completely_full_container, test_item_10_per_stack, 0],
		[multi_10_container, test_item_1_per_stack, 9],
		[multi_10_container, test_item_10_per_stack, 102],
		[full_10_container, test_item_10_per_stack, 0],
		[all_slots_occupied_container, test_item_1_per_stack, 2],  # 2 stacks with space, 1 item per stack = 2 total
		[all_slots_occupied_container, test_item_10_per_stack, 45], # 9 + 7 + 5 + 3 + 1 in 6 stacks, 2 empty slot with other item
	]
) -> void:
	var result : int = p_item_container.get_space_for_item(p_item)
	assert_that(result).is_greater_equal(0)
	assert_that(result).append_failure_message("The expected amount of remaining space is %s" % p_expected).is_equal(p_expected)

@warning_ignore("untyped_declaration")
func test_get_stacks_with_item(
	p_container : ItemContainer,
	p_expected : int,
	p_item : FlexItem,
	test_parameters := [
		[empty_container, 0, test_item_1_per_stack],
		[no_match_container, 0, test_item_1_per_stack],
		[no_match_container, 2, test_item_10_per_stack],
		[single_match_container, 1, test_item_1_per_stack],
		[multi_match_container, 2, test_item_1_per_stack],
		[mixed_container, 2, test_item_1_per_stack],
		[mixed_container, 1, test_item_10_per_stack],
		[zero_count_container, 0, test_item_1_per_stack],
		[null_items_container, 1, test_item_1_per_stack],
		[completely_full_container, 6, test_item_1_per_stack],
		[completely_full_container, 6, test_item_10_per_stack],
		[multi_10_container, 1, test_item_1_per_stack],
		[multi_10_container, 2, test_item_10_per_stack],
		[full_10_container, 12, test_item_10_per_stack],
		[all_slots_occupied_container, 4, test_item_1_per_stack],  # 4 stacks with count > 0
		[all_slots_occupied_container, 6, test_item_10_per_stack], # 6 stacks with count > 0
	]
):
	var result : Array[FlexStack] = p_container.get_stacks_with_item(p_item)
	assert_int(result.size()).is_equal(p_expected)

func test_get_item_count(
	p_container : ItemContainer,
	p_expected : int,
	p_item : FlexItem,
	test_parameters = [
		[empty_container, 0, test_item_1_per_stack],
		[empty_container, 0, test_item_10_per_stack],
		[no_match_container, 0, test_item_1_per_stack],
		[no_match_container, 8, test_item_10_per_stack],
		[single_match_container, 1, test_item_1_per_stack],
		[multi_match_container, 2, test_item_1_per_stack],
		[mixed_container, 2, test_item_1_per_stack],
		[mixed_container, 5, test_item_10_per_stack],
		[zero_count_container, 0, test_item_1_per_stack],
		[null_items_container, 1, test_item_1_per_stack],
		[completely_full_container, 6, test_item_1_per_stack],
		[completely_full_container, 60, test_item_10_per_stack],
		[multi_10_container, 1, test_item_1_per_stack],
		[multi_10_container, 8, test_item_10_per_stack],
		[full_10_container, 120, test_item_10_per_stack],
		[all_slots_occupied_container, 4, test_item_1_per_stack],  # 1 + 0 + 1 + 0 + 1 + 1
		[all_slots_occupied_container, 35, test_item_10_per_stack], # 1 + 3 + 5 + 7 + 9 + 10
	]
) -> void:
	var result : int = p_container.get_item_count(p_item)
	assert_int(result).is_equal(p_expected)

func test_add_items(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_try_amount : int,
	p_expected : int,
	test_parameters = [
		[empty_container, test_item_1_per_stack, 1, 1],
		[empty_container, test_item_1_per_stack, 5, 5],
		[empty_container, test_item_1_per_stack, 13, 12],
		[empty_container, test_item_10_per_stack, 10, 10],
		[empty_container, test_item_10_per_stack, 50, 50],
		[empty_container, test_item_10_per_stack, 130, 120],
		[single_match_container, test_item_1_per_stack, 1, 1],
		[multi_match_container, test_item_1_per_stack, 2, 2],
		[completely_full_container, test_item_1_per_stack, 1, 0], # No space
		[full_10_container, test_item_10_per_stack, 1, 0],
		[empty_container, test_item_1_per_stack, 0, 0],
		[empty_container, test_item_1_per_stack, -1, 0],
		[all_slots_occupied_container, test_item_1_per_stack, 1, 1], # Adds to existing stack of 0
		[all_slots_occupied_container, test_item_10_per_stack, 1, 1], # Adds to existing stack count < item.stack_maximum
	]
):
	var result = p_item_container.add_items(p_item, p_try_amount)
	assert_int(result).is_equal(p_expected)

func test_get_empty_stacks(
	p_item_container : ItemContainer,
	p_expected : int,
	test_parameters = [
		[empty_container, 0],
		[no_match_container, 0],
		[single_match_container, 0],
		[multi_match_container, 1],
		[mixed_container, 0],
		[zero_count_container, 2],
		[null_items_container, 2],
		[completely_full_container, 0],
		[multi_10_container, 0],
		[full_10_container, 0],
		[all_slots_occupied_container, 2],  # 2 stacks with count 0
	]
):
	var result : Array[FlexStack] = p_item_container.get_empty_stacks()
	assert_int(result.size()).is_equal(p_expected)

func test_get_unused_count(
	p_item_container : ItemContainer,
	p_expected : int,
	test_parameters = [
		[empty_container, 12],
		[no_match_container, 10],
		[single_match_container, 11],
		[multi_match_container, 10],
		[mixed_container, 9],
		[zero_count_container, 12],
		[null_items_container, 11],
		[completely_full_container, 0],
		[multi_10_container, 9],
		[full_10_container, 0],
		[all_slots_occupied_container, 2],  # 2 empty stacks, 0 undeclared
	]
):
	var result = p_item_container.get_unused_count()
	assert_int(result).is_equal(p_expected)

## Gets the indexes for the desired stacks inside of the ItemContainer's _slots array
func test_get_indexes(
	p_item_container : ItemContainer,
	p_stacks : Array[FlexStack],
	p_expected : Dictionary[FlexStack, int],
	test_parameters = [
		[empty_container, [], {}],  # No stacks, empty dict
		[no_match_container, [no_match_container._slots[0]], {no_match_container._slots[0]: 0}],  # First stack
		[single_match_container, [single_match_container._slots[0]], {single_match_container._slots[0]: 0}],  # Only stack
		[multi_match_container, [multi_match_container._slots[1], multi_match_container._slots[2]], {multi_match_container._slots[1]: 1, multi_match_container._slots[2]: 2}],  # Second and third stacks
		[mixed_container, [mixed_container._slots[0], mixed_container._slots[2]], {mixed_container._slots[0]: 0, mixed_container._slots[2]: 2}],  # First and third stacks
		[zero_count_container, [zero_count_container._slots[0]], {zero_count_container._slots[0]: 0}],  # First stack
		[null_items_container, [null_items_container._slots[1]], {null_items_container._slots[1]: 1}],  # Middle stack
		[completely_full_container, [completely_full_container._slots[0], completely_full_container._slots[11]], {completely_full_container._slots[0]: 0, completely_full_container._slots[11]: 11}],  # First and last stacks
		[multi_10_container, [multi_10_container._slots[0], multi_10_container._slots[2]], {multi_10_container._slots[0]: 0, multi_10_container._slots[2]: 2}],  # First and third stacks
		[full_10_container, [full_10_container._slots[5]], {full_10_container._slots[5]: 5}],  # Sixth stack
		[all_slots_occupied_container, [all_slots_occupied_container._slots[0], all_slots_occupied_container._slots[3]], {all_slots_occupied_container._slots[0]: 0, all_slots_occupied_container._slots[3]: 3}],  # First and fourth stacks
		[mixed_container, [FlexStack.new(test_item_1_per_stack, 1)], {FlexStack.new(test_item_1_per_stack, 1): -1}],  # External stack not in item_container
	]
):
	var result : Dictionary = p_item_container.get_indexes(p_stacks)
	assert_dict(result).is_equal(p_expected)

func test_check_if_room(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_amount : int,
	p_expected : bool,
	test_parameters = [
		[empty_container, test_item_1_per_stack, 1, true],       # Space: 12 >= 1
		[empty_container, test_item_10_per_stack, 120, true],    # Space: 120 >= 120
		[empty_container, test_item_1_per_stack, 13, false],     # Space: 12 < 13
		[no_match_container, test_item_1_per_stack, 10, true],   # Space: 10 >= 10
		[no_match_container, test_item_10_per_stack, 50, true],  # Space: 112 >= 50
		[no_match_container, test_item_10_per_stack, 113, false],# Space: 112 < 113
		[single_match_container, test_item_1_per_stack, 11, true],# Space: 11 >= 11
		[multi_match_container, test_item_1_per_stack, 5, true],  # Space: 10 >= 5
		[mixed_container, test_item_1_per_stack, 9, true],       # Space: 9 >= 9
		[mixed_container, test_item_10_per_stack, 95, true],     # Space: 95 >= 95
		[mixed_container, test_item_10_per_stack, 96, false],    # Space: 95 < 96
		[zero_count_container, test_item_1_per_stack, 12, true], # Space: 12 >= 12
		[null_items_container, test_item_1_per_stack, 10, true], # Space: 11 >= 10
		[completely_full_container, test_item_1_per_stack, 1, false], # Space: 0 < 1
		[completely_full_container, test_item_10_per_stack, 1, false], # Space: 0 < 1
		[multi_10_container, test_item_1_per_stack, 9, true],    # Space: 9 >= 9
		[multi_10_container, test_item_10_per_stack, 102, true], # Space: 102 >= 102
		[multi_10_container, test_item_10_per_stack, 103, false],# Space: 102 < 103
		[full_10_container, test_item_10_per_stack, 1, false],   # Space: 0 < 1
		[all_slots_occupied_container, test_item_1_per_stack, 2, true],  # Space: 2 >= 2
		[all_slots_occupied_container, test_item_1_per_stack, 3, false], # Space: 2 < 3
		[all_slots_occupied_container, test_item_10_per_stack, 45, true], # Space: 45 >= 45
		[all_slots_occupied_container, test_item_10_per_stack, 46, false], # Space: 46 < 45
	]
):
	var result : bool = p_item_container.check_if_room(p_item, p_amount)
	assert_bool(result).is_equal(p_expected)

## Tries to remove the item count from the item item_container, if p_allow_partial is false, then it will
## only allow removing if the full count is in the ItemContainer
func test_remove_items(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_amount : int,
	p_allow_partial : bool,
	p_expected : int,
	test_parameters = [
		[empty_container, test_item_1_per_stack, 1, false, 0],       # No items, 0 removed
		[no_match_container, test_item_1_per_stack, 1, false, 0],    # No items, 0 removed
		[no_match_container, test_item_10_per_stack, 5, false, 5],   # Total 8 >= 5, 5 removed
		[no_match_container, test_item_10_per_stack, 10, false, 0],  # Total 8 < 10, 0 removed
		[no_match_container, test_item_10_per_stack, 6, true, 6],    # Total 8 >= 6, 6 removed (partial allowed)
		[single_match_container, test_item_1_per_stack, 1, false, 1],# Total 1 >= 1, 1 removed
		[single_match_container, test_item_1_per_stack, 2, false, 0],# Total 1 < 2, 0 removed
		[multi_match_container, test_item_1_per_stack, 2, false, 2], # Total 2 >= 2, 2 removed
		[multi_match_container, test_item_1_per_stack, 3, false, 0], # Total 2 < 3, 0 removed
		[mixed_container, test_item_1_per_stack, 2, false, 2],       # Total 2 >= 2, 2 removed
		[mixed_container, test_item_10_per_stack, 5, false, 5],      # Total 5 >= 5, 5 removed
		[mixed_container, test_item_10_per_stack, 6, false, 0],      # Total 5 < 6, 0 removed
		[mixed_container, test_item_10_per_stack, 3, true, 3],       # Total 5 >= 3, 3 removed (partial)
		[zero_count_container, test_item_1_per_stack, 1, false, 0],  # Total 0 < 1, 0 removed
		[null_items_container, test_item_1_per_stack, 1, false, 1],  # Total 1 >= 1, 1 removed
		[completely_full_container, test_item_1_per_stack, 6, false, 6], # Total 6 >= 6, 6 removed
		[completely_full_container, test_item_1_per_stack, 7, false, 0], # Total 6 < 7, 0 removed
		[completely_full_container, test_item_10_per_stack, 60, false, 60], # Total 60 >= 60, 60 removed
		[completely_full_container, test_item_10_per_stack, 61, false, 0],  # Total 60 < 61, 0 removed
		[completely_full_container, test_item_10_per_stack, 50, true, 50],  # Total 60 >= 50, 50 removed (partial)
		[multi_10_container, test_item_1_per_stack, 1, false, 1],    # Total 1 >= 1, 1 removed
		[multi_10_container, test_item_10_per_stack, 8, false, 8],   # Total 8 >= 8, 8 removed
		[multi_10_container, test_item_10_per_stack, 9, false, 0],   # Total 8 < 9, 0 removed
		[full_10_container, test_item_10_per_stack, 120, false, 120],# Total 120 >= 120, 120 removed
		[full_10_container, test_item_10_per_stack, 121, false, 0],  # Total 120 < 121, 0 removed
		[all_slots_occupied_container, test_item_1_per_stack, 4, false, 4],  # Total 4 >= 4, 4 removed
		[all_slots_occupied_container, test_item_1_per_stack, 5, false, 0],  # Total 4 < 5, 0 removed
		[all_slots_occupied_container, test_item_1_per_stack, 3, true, 3],   # Total 4 >= 3, 3 removed (partial)
		[all_slots_occupied_container, test_item_10_per_stack, 35, false, 35],# Total 35 >= 35, 35 removed
		[all_slots_occupied_container, test_item_10_per_stack, 36, false, 0], # Total 35 < 36, 0 removed
	]
):
	var result : int = p_item_container.remove_items(p_item, p_amount, p_allow_partial)
	assert_int(result).is_equal(p_expected)

func test_find_positions_of_item(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_stacks : Array[FlexStack],
	p_expected : Array[int],
	test_parameters = [
		[empty_container, test_item_1_per_stack, empty_container._slots, []],         # No stacks
		[no_match_container, test_item_1_per_stack, no_match_container._slots, []],   # No matches
		[no_match_container, test_item_10_per_stack, no_match_container._slots, [0, 1]], # Two stacks
		[single_match_container, test_item_1_per_stack, single_match_container._slots, [0]], # One stack
		[multi_match_container, test_item_1_per_stack, multi_match_container._slots, [0, 1, 2]], # Three stacks
		[mixed_container, test_item_1_per_stack, mixed_container._slots, [0, 2]],     # Two stacks
		[mixed_container, test_item_10_per_stack, mixed_container._slots, [1]],       # One stack
		[zero_count_container, test_item_1_per_stack, zero_count_container._slots, [0, 1]], # Two stacks (count 0 included)
		[null_items_container, test_item_1_per_stack, null_items_container._slots, [1]], # One stack
		[completely_full_container, test_item_1_per_stack, completely_full_container._slots, [1, 3, 5, 7, 9, 11]], # Six stacks
		[completely_full_container, test_item_10_per_stack, completely_full_container._slots, [0, 2, 4, 6, 8, 10]], # Six stacks
		[multi_10_container, test_item_1_per_stack, multi_10_container._slots, [2]],  # One stack
		[multi_10_container, test_item_10_per_stack, multi_10_container._slots, [0, 1]], # Two stacks
		[full_10_container, test_item_10_per_stack, full_10_container._slots, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]], # Twelve stacks
		[all_slots_occupied_container, test_item_1_per_stack, all_slots_occupied_container._slots, [1, 3, 5, 7, 9, 11]], # Six stacks
		[all_slots_occupied_container, test_item_10_per_stack, all_slots_occupied_container._slots, [0, 2, 4, 6, 8, 10]], # Six stacks
	]
):
	var result : Array[int] = p_item_container.find_positions_of_item(p_item, p_stacks)
	assert_array(result).is_equal(p_expected)


func test_does_it_allow(
	p_item_container : ItemContainer,
	p_item : FlexItem,
	p_expected : bool,
	test_parameters = [
		[empty_container, test_item_1_per_stack, true],       # No allowed_tags, always true
		[empty_container, null, false],                       # Null item, false
		[no_match_container, test_item_10_per_stack, true],   # No allowed_tags, true
		[single_match_container, test_item_1_per_stack, true],# No allowed_tags, true
		[multi_match_container, test_item_1_per_stack, true], # No allowed_tags, true
		[mixed_container, test_item_1_per_stack, true],       # No allowed_tags, true
		[mixed_container, test_item_10_per_stack, true],      # No allowed_tags, true
		[zero_count_container, test_item_1_per_stack, true],  # No allowed_tags, true
		[null_items_container, test_item_1_per_stack, true],  # No allowed_tags, true
		[completely_full_container, test_item_1_per_stack, true], # No allowed_tags, true
		[completely_full_container, test_item_10_per_stack, true], # No allowed_tags, true
		[multi_10_container, test_item_1_per_stack, true],    # No allowed_tags, true
		[multi_10_container, test_item_10_per_stack, true],   # No allowed_tags, true
		[full_10_container, test_item_10_per_stack, true],    # No allowed_tags, true
		[all_slots_occupied_container, test_item_1_per_stack, true],  # No allowed_tags, true
		[all_slots_occupied_container, test_item_10_per_stack, true], # No allowed_tags, true
		[tag_restricted_container, test_item_1_per_stack, false], # Not in allowed_tags
		[tag_restricted_container, item_with_tag, true] # Has the tag!
	]
):
	var result : bool = p_item_container.does_it_allow(p_item)
	assert_bool(result).is_equal(p_expected)

func test_clear(
	p_item_container : ItemContainer,
	p_expected : int,
	test_parameters = [
		[empty_container, 0],              # No slots to clear
		[no_match_container, 2],           # 2 slots
		[single_match_container, 1],       # 1 slot
		[multi_match_container, 3],        # 3 slots
		[mixed_container, 3],              # 3 slots
		[zero_count_container, 2],         # 2 slots
		[null_items_container, 3],         # 3 slots
		[completely_full_container, 12],   # 12 slots
		[multi_10_container, 3],           # 3 slots
		[full_10_container, 12],           # 12 slots
		[all_slots_occupied_container, 12],# 12 slots
		[tag_restricted_container, 0],     # No slots to clear
	]
):
	var result : int = p_item_container.clear()
	assert_int(result).is_equal(p_expected)

func test_get_item_types(
	p_item_container : ItemContainer,
	p_stacks : Array[FlexStack],
	p_expected : Array[FlexItem],
	test_parameters = [
		[empty_container, empty_container._slots, []],              # No slots, no items
		[no_match_container, no_match_container._slots, [test_item_10_per_stack]], # One item type
		[single_match_container, single_match_container._slots, [test_item_1_per_stack]], # One item type
		[multi_match_container, multi_match_container._slots, [test_item_1_per_stack]], # One item type (repeated)
		[mixed_container, mixed_container._slots, [test_item_1_per_stack, test_item_10_per_stack]], # Two item types
		[zero_count_container, zero_count_container._slots, [test_item_1_per_stack]], # One item type (count 0)
		[null_items_container, null_items_container._slots, [test_item_1_per_stack]], # One item type (with nulls)
		[completely_full_container, completely_full_container._slots, [test_item_10_per_stack, test_item_1_per_stack]], # Two item types
		[multi_10_container, multi_10_container._slots, [test_item_10_per_stack, test_item_1_per_stack]], # Two item types
		[full_10_container, full_10_container._slots, [test_item_10_per_stack]], # One item type
		[all_slots_occupied_container, all_slots_occupied_container._slots, [test_item_10_per_stack, test_item_1_per_stack]], # Two item types
		[tag_restricted_container, tag_restricted_container._slots, []], # No slots, no items
		# Custom stacks case
		[mixed_container, [FlexStack.new(test_item_1_per_stack, 1), FlexStack.new(null, 0)], [test_item_1_per_stack]], # Subset with null
	]
):
	var result : Array[FlexItem] = p_item_container.get_item_types(p_stacks)
	assert_array(result).is_equal(p_expected)

func test_get_stacks_with_tag(
	p_item_container : ItemContainer,
	p_tag : ItemTag,
	p_expected : Array[FlexStack],
	test_parameters := [
		[empty_container, tag_type, []],  # No items, empty array
		[no_match_container, tag_type, []],  # No items with tag
		[single_match_container, tag_type, []],  # No tags match
		[multi_match_container, tag_type, []],  # No tags match
		[mixed_container, tag_type, []],  # No tags match
		[zero_count_container, tag_type, []],  # No tags match
		[null_items_container, tag_type, []],  # No tags match (null items ignored)
		[completely_full_container, tag_type, []],  # No tags match
		[multi_10_container, tag_type, []],  # No tags match
		[full_10_container, tag_type, []],  # No tags match
		[all_slots_occupied_container, tag_type, []],  # No tags match
		[tag_restricted_container, tag_type, []],  # No items yet
		# Add a item_container with tagged items
		[mixed_container, tag_type, []],  # Before adding tagged item
		# Modify a item_container to include the tagged item
		[tag_restricted_container, tag_type, [FlexStack.new(item_with_tag, 1)]],  # After adding tagged item (requires setup)
	]
) -> void:
	# Special setup for the last test case to add an item with the tag
	if p_item_container == tag_restricted_container and p_expected.size() > 0:
		p_item_container.add_items(item_with_tag, 1)
	
	var result : Array[FlexStack] = p_item_container.get_stacks_with_tag(p_tag)
	assert_array(result).is_equal(p_expected)
	
	# Cleanup for tag_restricted_container to avoid affecting other tests
	if p_item_container == tag_restricted_container and p_expected.size() > 0:
		p_item_container.clear()

func test_get_item_count_with_tag(
	p_item_container : ItemContainer,
	p_tag : ItemTag,
	p_expected : int,
	test_parameters := [
		[empty_container, tag_type, 0],  # No items, total 0
		[no_match_container, tag_type, 0],  # No items with tag, total 0
		[single_match_container, tag_type, 0],  # No tags match, total 0
		[multi_match_container, tag_type, 0],  # No tags match, total 0
		[mixed_container, tag_type, 0],  # No tags match, total 0
		[zero_count_container, tag_type, 0],  # No tags match, total 0
		[null_items_container, tag_type, 0],  # No tags match (null items ignored), total 0
		[completely_full_container, tag_type, 0],  # No tags match, total 0
		[multi_10_container, tag_type, 0],  # No tags match, total 0
		[full_10_container, tag_type, 0],  # No tags match, total 0
		[all_slots_occupied_container, tag_type, 0],  # No tags match, total 0
		[tag_restricted_container, tag_type, 0],  # No items yet, total 0
		# Add cases with tagged items
		[tag_restricted_container, tag_type, 1],  # After adding 1 tagged item
		[tag_restricted_container, tag_type, 3],  # After adding 3 tagged items
	]
) -> void:
	# Dynamic setup for cases with tagged items
	if p_item_container == tag_restricted_container and p_expected > 0:
		p_item_container.add_items(item_with_tag, p_expected)
	
	var result : int = p_item_container.get_item_count_with_tag(p_tag)
	assert_int(result).is_equal(p_expected)
	
	# Cleanup to reset state
	if p_item_container == tag_restricted_container and p_expected > 0:
		p_item_container.clear()
# GdUnit 4.5.0 Test Suite for CostView (No Mocks, with FlexStack/FlexItem)
extends GdUnitTestSuite

class_name TestCostView

# Test subject
var cost_display: CostView

# Real dependencies
var shop_view: ItemContainerView
var stack_view: StackView
var stack: FlexStack
var item: FlexItem

# Setup before each test
func before_test() -> void:
	cost_display = auto_free(CostView.new())
	shop_view = auto_free(ItemContainerView.new())
	stack_view = auto_free(StackView.new())
	item = auto_free(FlexItem.new())
	
	# Initialize item with a value and create stack
	item.value = 10.0
	stack = auto_free(FlexStack.new(item, 10))  # Assuming FlexStack.new(item, count)
	stack_view.item_stack = stack
	

# Test default initialization
func test_initial_state() -> void:
	cost_display._ready()
	assert_float(cost_display.cost).is_equal(0.0)
	assert_str(cost_display.text_template).is_equal("COST: %d")
	assert_str(cost_display.text).is_equal("COST: 0")  # After _ready()

# Test setting shop_view property
func test_shop_view_setter() -> void:
	# Initial null state
	assert_object(cost_display.shop_view).is_null()
	
	# Set shop_view and verify connection
	cost_display.shop_view = shop_view
	assert_object(cost_display.shop_view).is_same(shop_view)
	
	# Verify signal connection using assert_signal with explicit Callable
	assert_bool(shop_view.selected_items_changed.is_connected(cost_display._on_view_selected_items_changed)).is_true()
	
	# Change shop_view and verify disconnection from old, connection to new
	var new_shop_view = auto_free(ItemContainerView.new())
	cost_display.shop_view = new_shop_view
	assert_bool(shop_view.selected_items_changed.is_connected(cost_display._on_view_selected_items_changed)).is_false()
	assert_bool(new_shop_view.selected_items_changed.is_connected(cost_display._on_view_selected_items_changed)).is_true()

# Test calculate_cost with real StackView data
func test_calculate_cost() -> void:
	# Test with different selected_count values
	stack_view.selected_count = 2
	var stack_views = [stack_view] as Array[StackView]
	assert_float(cost_display.calculate_cost(stack_views)).is_equal(20.0)  # 2 * 10.0
	
	stack_view.selected_count = 0
	assert_float(cost_display.calculate_cost(stack_views)).is_equal(0.0)
	
	# Test with empty array
	assert_float(cost_display.calculate_cost([])).is_equal(0.0)

# Test update_text with different cost values
func test_update_text() -> void:
	cost_display.cost = 15.0
	assert_str(cost_display.text).is_equal("COST: 15")
	
	cost_display.text_template = "Price: %d"
	cost_display.cost = 42.0
	assert_str(cost_display.text).is_equal("Price: 42")
	
	cost_display.cost = 0.0
	assert_str(cost_display.text).is_equal("Price: 0")

# Test validate with and without shop_view
func test_validate() -> void:
	# No shop_view assigned
	cost_display.shop_view = null
	assert_bool(cost_display.validate()).is_false()
	
	# With shop_view assigned
	cost_display.shop_view = shop_view
	assert_bool(cost_display.validate()).is_true()

# Test _on_view_selected_items_changed updates cost
func test_selected_items_changed_signal() -> void:
	# Setup stack_view data
	stack_view.selected_count = 3
	var stack_views = [stack_view] as Array[StackView]
	
	# Connect shop_view and trigger signal
	cost_display.shop_view = shop_view
	cost_display._on_view_selected_items_changed(stack_views)
	assert_float(cost_display.cost).is_equal(30.0)  # 3 * 10.0
	assert_str(cost_display.text).is_equal("COST: 30")
extends GdUnitTestSuite

var shop : Shop
var view : ItemContainerView
var display : StackView
var source : ItemContainer
var stack_1 : FlexStack
var stack_2 : FlexStack

var view_template : PackedScene = preload("uid://cihvnkle5hx0m")
var item : FlexItem

const STACK_COUNT = 10

func before():
	item = FlexItem.new()
	item.stack_maximum = 100

func after():
	print_orphan_nodes()

func before_test():
	shop = auto_free(Shop.new())
	add_child(shop)
	view = auto_free(view_template.instantiate())
	add_child(view)
	
	## Create a StackView with a Test Stack
	display = auto_free(StackView.new())
	add_child(display)
	
	stack_1 = FlexStack.new()
	stack_1.item = item
	stack_1.count = STACK_COUNT
	stack_2 = FlexStack.new()
	
	source = ItemContainer.new()
	source.type = ItemContainerType.new()
	source._slots = [stack_1, stack_2]
	
	## Dependencies
	var view_1_inventory = FlexInventory.new([source], 0.0)
	view.inventory = view_1_inventory
	view.item_container = source
	assert_array(view.stack_views).append_failure_message("Expected to be setup").is_not_empty()

## The purpose of the test is to check what happens when dragging from a container to itself
func test_transfer_to_same_container():
	var display_0_count = view.stack_views[0].item_stack.count
	var display_1_count = view.stack_views[1].item_stack.count
	
	var transfer = StackTransfer.new(view.inventory, [FlexStack.new(item, display_1_count)])
	
	assert_object(transfer).is_not_null()
	view._drop_data(Vector2(0,0), transfer)
	
	# Expect nothing to happen
	assert_int(view.stack_views[0].item_stack.count).is_equal(display_0_count)
	assert_int(view.stack_views[1].item_stack.count).is_equal(display_1_count)
	assert_int(view.item_container.get_item_count(item)).is_equal(STACK_COUNT)
	
	# Final confirmation
	assert_object(transfer.preferred_container).is_equal(view.item_container)
	assert_int(transfer.status).append_failure_message("StackTransfer has not finished successfully yet.").is_equal(StackTransfer.Status.SUCCEEDED)
extends GdUnitTestSuite
## Array Extensions Tests

func test_move_before():
	var array1 = [0,1,2]
	var move1 = FlexArrayExtensions.move(2,0, array1)
	assert_array(move1).is_equal([2,0,1])
	
func test_move_after():
	var array1 = [0,1,2]
	
	var move2 = FlexArrayExtensions.move(0,2, array1)
	assert_array(move2).is_equal([1,2,0])
	
func test_move_after_101():
	var array_1 = []
	
	for i in range(0,101,1):
		array_1.append(i)
		
	var move = FlexArrayExtensions.move(0,100, array_1)
	assert_int(move[0]).append_failure_message("The first value is the 2nd value (1) of the original array").is_equal(1)
	assert_int(move[100]).append_failure_message("0 value has moved to the end of the array").is_equal(0)
	
	var move_backwards = FlexArrayExtensions.move(100, 0, array_1)
	assert_int(move_backwards[0]).append_failure_message("The 100 has moved to the front of the array").is_equal(100)
	assert_int(move_backwards[100]).append_failure_message("The 100th value is the 99th value pushed back").is_equal(99)

func test_move_multi_3():
	var array1 = [0,1,2]
	
	var move1_back = FlexArrayExtensions.move_multi(2, [0,1], array1, false)

	assert_array(move1_back).is_equal([0,1,2])
	
	var move1_front = FlexArrayExtensions.move_multi(2, [0,1], array1, true)
	
	assert_array(move1_front).is_equal([2,0,1])
	
func test_move_multi_5():
	var array1 = [0,1,2,3,4]
	
	var move1_back = FlexArrayExtensions.move_multi(4, [0,1,2], array1, false)
	
	assert_array(move1_back).is_equal([3,0,1,2,4])
	
	var move1_front = FlexArrayExtensions.move_multi(4, [0,1,2], array1, true)
	
	assert_array(move1_front).is_equal([3,4,0,1,2])
	
func test_move_multi_mixed():
	var array10 = []
	
	for i in range(0,10,1):
		array10.append(i)
		
	var move10_back = FlexArrayExtensions.move_multi(5, [7,3,0,9], array10, false)
	
	assert_array(move10_back).is_equal([1,2,4,7,3,0,9,5,6,8])
	
	var move10_front = FlexArrayExtensions.move_multi(5, [7,3,0,9], array10, true)
	
	assert_array(move10_front).is_equal([1,2,4,5,7,3,0,9,6,8])
	
func test_move_multi_big():
	var array101 = []
	
	for i in range(0,101,1):
		array101.append(i)
		
	var move101_back = FlexArrayExtensions.move_multi(0, [50,30,15,100], array101, false)
	
	assert_int(move101_back[0]).is_equal(50)
	assert_int(move101_back[1]).is_equal(30)
	assert_int(move101_back[2]).is_equal(15)
	assert_int(move101_back[3]).is_equal(100)
	assert_int(move101_back[4]).is_equal(0)
	assert_int(move101_back[100]).is_equal(99)
	assert_int(move101_back[50]).is_equal(48)
	
	var move101_front = FlexArrayExtensions.move_multi(0, [50,30,15,100], array101, true)
	
	assert_int(move101_front[0]).is_equal(0)
	assert_int(move101_front[1]).is_equal(50)
	assert_int(move101_front[2]).is_equal(30)
	assert_int(move101_front[3]).is_equal(15)
	assert_int(move101_front[4]).is_equal(100)
	assert_int(move101_front[100]).is_equal(99)
	assert_int(move101_front[50]).is_equal(48)

func insert_new_nulls():
	var array3 = [0,1,2]
	
	var pushed = FlexArrayExtensions.insert_new_nulls(1, 2, array3)
	assert_array(pushed).is_equal([0, null, null, 1,2])

func insert_new_nulls_big():
	var array20 = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
	
	var pushed25 = FlexArrayExtensions.insert_new_nulls(11,5, array20)
	assert_array(pushed25).is_equal([0,1,2,3,4,5,6,7,8,9,10,null,null,null,null,null,11,12,13,14,15,16,17,18,19])
extends GdUnitTestSuite
@warning_ignore('unused_parameter')
@warning_ignore('return_value_discarded')

# Predefined FlexStack instances
var empty_stack: FlexStack
var normal_stack: FlexStack
var full_stack: FlexStack
var infinite_stack: FlexStack

# Predefined FlexItem instances
var test_item: FlexItem
var alternate_item: FlexItem

func before_test():
	# Setup FlexItems
	test_item = FlexItem.new()
	test_item.stack_maximum = 20
	
	alternate_item = FlexItem.new()
	alternate_item.stack_maximum = 20

	# Setup FlexStacks
	empty_stack = FlexStack.new()
	
	normal_stack = FlexStack.new()
	normal_stack.item = test_item
	normal_stack.count = 5
	
	full_stack = FlexStack.new()
	full_stack.item = test_item
	full_stack.count = test_item.stack_maximum
	
	infinite_stack = FlexStack.new()
	infinite_stack.item = test_item
	infinite_stack.infinite = true
	infinite_stack.count = 0

@warning_ignore("unused_parameter")
func test_validate(p_stack: FlexStack, p_count: int, p_expected: bool, p_test_name: String, test_parameters := [
	[empty_stack, -1, false, "Empty stack with negative count"],           # Invalid count
	[empty_stack, 0, true, "Empty stack with zero count"],                 # Valid empty
	[empty_stack, 1, true, "Empty stack with positive count"],             # Valid, no item yet
	[normal_stack, -1, false, "Normal stack with negative count"],         # Invalid count
	[normal_stack, 0, true, "Normal stack with zero count"],               # Valid empty
	[normal_stack, test_item.stack_maximum, true, "Normal stack at maximum"], # Valid at limit
	[full_stack, test_item.stack_maximum + 1, false, "Full stack exceeds maximum"], # Invalid, over limit
	[infinite_stack, -1, true, "Infinite stack with negative count"]       # Valid, infinite ignores count
]) -> void:
	var test_stack = p_stack.duplicate(true)  # Clone to avoid modifying original
	test_stack.count = p_count
	var result = test_stack.validate()
	assert_bool(result)\
		.append_failure_message("Validation failed for: " + p_test_name)\
		.is_equal(p_expected)

@warning_ignore("unused_parameter")
func test_clear(p_stack: FlexStack, p_test_name: String, test_parameters := [
	[empty_stack, "Clear empty stack"],           # Already empty
	[normal_stack, "Clear normal stack"],         # Has item and count
	[full_stack, "Clear full stack"],             # Full stack
	[infinite_stack, "Clear infinite stack"]      # Infinite stack
]) -> void:
	var test_stack = p_stack.duplicate(true)  # Clone to avoid modifying original
	test_stack.clear()
	assert_int(test_stack.count)\
		.append_failure_message("Count should be 0 after clear for: " + p_test_name)\
		.is_equal(0)
	assert_object(test_stack.item)\
		.append_failure_message("Item should be null after clear for: " + p_test_name)\
		.is_null()

@warning_ignore("unused_parameter")
func test_get_effective_count(p_stack: FlexStack, p_count: int, p_expected: int, p_test_name: String, test_parameters := [
	[empty_stack, 0, 0, "Empty stack with zero count"],                # Normal zero count
	[normal_stack, 5, 5, "Normal stack with set count"],               # Normal count
	[full_stack, test_item.stack_maximum, test_item.stack_maximum, "Full stack at max"], # At maximum
	[infinite_stack, 0, INF, "Infinite stack with zero count"],        # Infinite overrides count
	[infinite_stack, 5, INF, "Infinite stack with positive count"],    # Infinite overrides count
	[infinite_stack, -1, INF, "Infinite stack with negative count"]    # Infinite still applies
]) -> void:
	var test_stack = p_stack.duplicate(true)  # Clone to avoid modifying original
	test_stack.count = p_count
	var result = test_stack.get_effective_count()
	assert_int(result)\
		.append_failure_message("Effective count incorrect for: " + p_test_name)\
		.is_equal(p_expected)

@warning_ignore("unused_parameter")
func test_count_changed_signal(p_stack: FlexStack, p_new_count: int, p_expected_emitted: bool, p_test_name: String, test_parameters := [
	[empty_stack, 0, false, "Empty stack, no change"],                 # Same count, no signal
	[empty_stack, 5, true, "Empty stack to positive"],                 # Count changes, signal emitted
	[normal_stack, 5, false, "Normal stack, no change"],               # Same count, no signal
	[full_stack, 0, true, "Full stack to zero"],                       # Count changes, signal emitted
	[infinite_stack, 10, true, "Infinite stack count change"]          # Count changes, signal emitted (though irrelevant)
]) -> void:
	var test_stack = p_stack.duplicate(true)  # Clone to avoid modifying original
	var signal_results: Array = []
	test_stack.count_changed.connect(func(stack): signal_results.append(stack))
	test_stack.count = p_new_count
	if p_expected_emitted:
		assert_array(signal_results)\
			.append_failure_message("Count changed signal should emit once for: " + p_test_name)\
			.has_size(1)
		assert_object(signal_results[0])\
			.append_failure_message("Emitted stack should match test stack for: " + p_test_name)\
			.is_same(test_stack)
	else:
		assert_array(signal_results)\
			.append_failure_message("Count changed signal should not emit for: " + p_test_name)\
			.is_empty()

@warning_ignore("unused_parameter")
func test_item_changed_signal(p_stack: FlexStack, p_new_item: FlexItem, p_expected_emitted: bool, p_test_name: String, test_parameters := [
	[empty_stack, null, false, "Empty stack, no change from null"],           # Same null, no signal
	[empty_stack, test_item, true, "Empty stack to item"],                    # Item added, signal emitted
	[normal_stack, null, true, "Normal stack to null"],                       # Item removed, signal emitted
	[normal_stack, alternate_item, true, "Normal stack to different item"],   # Different instance, signal emitted
	[full_stack, test_item, false, "Full stack, same item"]                   # Same item, no signal
]) -> void:
	var test_stack = p_stack.duplicate(true)  # Clone to avoid modifying original
	var signal_results: Array = []
	test_stack.item_changed.connect(func(stack): signal_results.append(stack))
	test_stack.item = p_new_item
	if p_expected_emitted:
		assert_array(signal_results)\
			.append_failure_message("Item changed signal should emit once for: " + p_test_name)\
			.has_size(1)
		assert_object(signal_results[0])\
			.append_failure_message("Emitted stack should match test stack for: " + p_test_name)\
			.is_same(test_stack)
	else:
		assert_array(signal_results)\
			.append_failure_message("Item changed signal should not emit for: " + p_test_name)\
			.is_empty()

@warning_ignore("unused_parameter")
func test_get_space(p_stack: FlexStack, p_item: FlexItem, p_expected: int, p_test_name: String, test_parameters := [
	[empty_stack, test_item, test_item.stack_maximum, "Empty stack with test item"],  # Full space available
	[normal_stack, test_item, test_item.stack_maximum - normal_stack.count, "Normal stack with test item"],  # Partial space available
	[full_stack, test_item, 0, "Full stack with test item"],  # No space available
	[infinite_stack, test_item, int(INF), "Infinite stack with test item"],  # Infinite space available
	[empty_stack, alternate_item, test_item.stack_maximum, "Empty stack with alternate item"],  # Full space available for different item
	[normal_stack, alternate_item, 0, "Normal stack with alternate item"]  # No space available for different item
]) -> void:
	var result = p_stack.get_space(p_item)
	assert_int(result)\
		.append_failure_message("Space calculation incorrect for: " + p_test_name)\
		.is_equal(p_expected)
# GdUnit 4.5 Test Suite for ItemContainerView and StackView interaction
class_name TestItemContainerView
extends GdUnitTestSuite

# Test resources
var item_container_type_fill: ItemContainerType
var item_container_type_remove: ItemContainerType
var item_container_type_ignore: ItemContainerType
var item_container_fill: ItemContainer
var item_container_remove: ItemContainer
var item_container_ignore: ItemContainer
var item_container_view: ItemContainerView
var flex_item: FlexItem
var flex_stack: FlexStack

var item_container_template: PackedScene = load("uid://cihvnkle5hx0m")

# Setup before each test
func before_test() -> void:
	# Create ItemContainerType for FILL mode
	item_container_type_fill = ItemContainerType.new()
	item_container_type_fill.size = 10
	item_container_type_fill.empty_mode = ItemContainerType.EmptyMode.FILL
	item_container_fill = ItemContainer.new(item_container_type_fill)

	# Create ItemContainerType for REMOVE mode
	item_container_type_remove = ItemContainerType.new()
	item_container_type_remove.size = 10
	item_container_type_remove.empty_mode = ItemContainerType.EmptyMode.REMOVE
	item_container_remove = ItemContainer.new(item_container_type_remove)

	# Create ItemContainerType for IGNORE mode
	item_container_type_ignore = ItemContainerType.new()
	item_container_type_ignore.size = 10
	item_container_type_ignore.empty_mode = ItemContainerType.EmptyMode.IGNORE
	item_container_ignore = ItemContainer.new(item_container_type_ignore)

	# FlexItem for testing with explicit stack_maximum
	flex_item = FlexItem.new()
	flex_item.name = "Test Item"
	flex_item.stack_maximum = 10
	
	# FlexStack with the item
	flex_stack = FlexStack.new()
	flex_stack.item = flex_item
	flex_stack.count = 5

	# Instantiate item_container_view from template
	item_container_view = item_container_template.instantiate()
	add_child(item_container_view)

# Cleanup after each test
func after_test() -> void:
	if is_instance_valid(item_container_view):
		item_container_view.free()

# Parameterized test: Check StackView behavior across all empty_mode types
func test_stack_view_behavior(
	mode_container: ItemContainer,
	initial_count: int,
	action: String,
	expected_stacks: int,
	expected_views: int,
	test_parameters := [
		# REMOVE mode: Add 5, set count to 0 -> 0 stacks/views
		[item_container_remove, 5, "count_zero", 0, 0],
		# REMOVE mode: Add 5, set item to null -> 0 stacks/views
		[item_container_remove, 5, "item_null", 0, 0],
		# IGNORE mode: Add 5, set count to 0 -> 1 stack/view
		[item_container_ignore, 5, "count_zero", 1, 1],
		# IGNORE mode: Add 5, set item to null -> 1 stack/view
		[item_container_ignore, 5, "item_null", 1, 1],
		# FILL mode: Add 5, set count to 0 -> 10 stacks, 1 view
		[item_container_fill, 5, "count_zero", 10, 10],
		# FILL mode: Add 5, set item to null -> 10 stacks, 1 view
		[item_container_fill, 5, "item_null", 10, 10],
		# Additional coverage:
		[item_container_fill, 0, "count_zero", 10, 10],  # Add 0 items
		[item_container_remove, 15, "count_zero", 0, 0],  # Exceed stack_maximum
	]
) -> void:
	# Arrange
	item_container_view.item_container = mode_container
	item_container_view._ready()
	
	mode_container.try_add(flex_item, initial_count)
	var expected_initial_stacks : int
	
	if mode_container == item_container_fill:
		expected_initial_stacks = 10
	else:
		expected_initial_stacks = ceil(initial_count as float / 10) # Needs enough items to fit the container ex. 15 items, 10 max per stack, means 1.5 ceil to 2 for 2 stacks
		
	assert_that(mode_container.get_stacks().size()).is_equal(expected_initial_stacks)
	assert_that(item_container_view.stack_views.size()).append_failure_message("Expected to have the same number %s of stack views as stacks" % expected_initial_stacks).is_equal(expected_initial_stacks)
	
	if initial_count > 0:
		# Loop through the stack views to adjust
		var modified_views : int = 0
		
		for stack_view in item_container_view.stack_views:
			if mode_container.type.empty_mode != ItemContainerType.EmptyMode.FILL:
				assert_that(stack_view.item_stack.item).is_not_null()
			
			# Act
			if action == "count_zero":
				stack_view.item_stack.count = 0
			elif action == "item_null":
				stack_view.item_stack.item = null
				
			modified_views += 1
		
		# Assert
		assert_int(modified_views).append_failure_message("Expected to have changed %s StackView" % expected_initial_stacks).is_equal(expected_initial_stacks)
		await await_idle_frame()
		assert_that(item_container_view.stack_views.size()).is_equal(expected_views)
		assert_that(mode_container.get_stacks().size()).is_equal(expected_stacks)
	else:
		await await_idle_frame()  # Ensure no changes for zero initial count

# Test: Check StackView behavior with FILL empty_mode (simple)
func test_stack_view_behavior_fill_mode_simple() -> void:
	assert_that(item_container_fill.get_stacks().size()).is_equal(10)
	item_container_fill.try_add(flex_item, 5)
	assert_that(item_container_fill.get_stacks().size()).is_equal(10)

# Parameterized test: Verify StackView creation and removal with stack_added/removed signals
func test_stack_view_signal_sync(
	action: String,
	count: int,
	expected_views: int,
	test_parameters := [
		["add", 5, 1],     # Add 5 items, expect 1 StackView
		["remove", 5, 0],  # Remove all, expect 0 StackViews
		["add", 10, 1],    # Add 10 items, expect 1 StackView
		["add", 0, 0],     # Add 0 items, expect 0 StackViews
		["add", 15, 2],    # Add 15 items, expect 1 StackView (stack_maximum = 10)
	]
) -> void:
	# Use the remove contaner type so that empty stacks automatically remove
	item_container_view.item_container = item_container_remove
	item_container_view._ready()

	item_container_remove.try_add(flex_item, count)
	var expected_stacks : int = ceil(count as float / 10) as int
	assert_int(item_container_remove.get_stacks().size()).append_failure_message("Should have one stack per 10 count at least").is_equal(expected_stacks)
	assert_int(item_container_view.stack_views.size()).append_failure_message("Should have at least one stack").is_equal(expected_stacks)
	
	if action == "remove":
		item_container_remove.try_remove(flex_item, 5)
	
	await await_idle_frame()
	assert_that(item_container_view.stack_views.size()).append_failure_message("The number of views should not be %s" % expected_views).is_equal(expected_views)
	assert_that(item_container_remove.get_stacks().size()).append_failure_message("The number of stacks in the item_container should now be %s" % expected_views).is_equal(expected_views)

# Test: Validate initial setup with multiple stacks
func test_initial_setup_with_stacks() -> void:
	item_container_view.item_container = item_container_ignore
	item_container_view._ready()

	item_container_ignore.try_add(flex_item, 5)
	var second_item = FlexItem.new()
	second_item.name = "Second Item"
	second_item.stack_maximum = 10
	item_container_ignore.try_add(second_item, 3)
	
	item_container_view.item_container = null
	item_container_view.item_container = item_container_ignore
	
	await await_idle_frame()
	assert_that(item_container_view.stack_views.size()).is_equal(2)
	assert_that(item_container_view.stack_views[0].item_stack.item.name).is_equal("Test Item")
	assert_that(item_container_view.stack_views[1].item_stack.item.name).is_equal("Second Item")

# Parameterized test: Verify drag-and-drop acceptance
func test_drag_drop_acceptance(
	data: Variant,
	expected_result: bool,
	test_parameters := [
		[StackTransfer.new(null, []), true],  # Valid StackTransfer
		["invalid_data", false],              # Invalid type
		[null, false],                        # Null data
		[FlexItem.new(), false],              # Invalid type (FlexItem)
	]
) -> void:
	item_container_view.item_container = item_container_ignore
	item_container_view._ready()
	assert_that(item_container_view._can_drop_data(Vector2.ZERO, data)).is_equal(expected_result)

# Test: Verify selected_items_changed signal emission
func test_selected_items_changed_signal() -> void:
	item_container_view.item_container = item_container_ignore
	item_container_view._ready()

	item_container_ignore.try_add(flex_item, 5)
	var stack_view = item_container_view.stack_views[0]
	var signal_emitted = [false]
	item_container_view.selected_items_changed.connect(func(views): signal_emitted[0] = true)
	
	stack_view.selected_count = 3
	
	await await_idle_frame()
	assert_that(signal_emitted[0]).is_true()
	assert_that(stack_view.selected_count).is_equal(3)

# Test: Verify clear() removes all StackViews
func test_clear_removes_all_views() -> void:
	item_container_view.item_container = item_container_ignore
	item_container_view._ready()

	item_container_ignore.try_add(flex_item, 5)
	item_container_ignore.try_add(flex_item, 5)
	assert_that(item_container_view.stack_views.size()).is_equal(1)
	assert_that(item_container_ignore.get_stacks().size()).is_equal(1)
	assert_that(item_container_ignore.get_stacks()[0].count).is_equal(10)
	
	item_container_view.clear()
	
	assert_that(item_container_view.stack_views.size()).is_equal(0)
	assert_that(item_container_view.grid_container.get_child_count()).is_equal(0)
extends GdUnitTestSuite
# Test Shop

var shop : Shop
var shop_bus : ShopBus
var shopper : Node
var shopper_inventory : FlexInventory

# Emissions
var shopper_changed_emissions : Array
var shopper_inventory_changed_emissions : Array

func before_test():
	shop = auto_free(Shop.new())
	add_child(shop)
	
	shop.inventory_stock = FlexInventory.new()
	
	shopper = auto_free(Node.new())
	add_child(shopper)
	
	shopper_inventory = FlexInventory.new([ItemContainer.new()], 0)
	
	shop_bus = ShopBus.new()
	shop_bus.shop = shop
	
	shopper_changed_emissions = []
	shopper_inventory_changed_emissions = []
	shop.shopper_changed.connect(func(p_shopper): shopper_changed_emissions.append(p_shopper))
	shop.shopper_inventory_changed.connect(func(p_inventory): shopper_inventory_changed_emissions.append(p_inventory))

func test_change_shopper():
	# Arrange - Set initial different values
	var initial_shopper = auto_free(Node.new())
	var initial_inventory = FlexInventory.new()
	shop.shopper = initial_shopper
	shop.shopper_inventory = initial_inventory
	
	# Clear any emissions from setup
	shopper_changed_emissions.clear()
	shopper_inventory_changed_emissions.clear()
	
	# Act
	shop.change_shopper(shopper, shopper_inventory)
	
	# Assert
	# Check property assignments
	assert_object(shop.shopper).is_same(shopper)
	assert_object(shop.shopper_inventory).is_same(shopper_inventory)
	
	# Check signal emissions
	assert_array(shopper_changed_emissions).has_size(1)
	assert_object(shopper_changed_emissions[0]).is_same(shopper)
	
	assert_array(shopper_inventory_changed_emissions).has_size(1)
	assert_object(shopper_inventory_changed_emissions[0]).is_same(shopper_inventory)
	
	# Clean up
	auto_free(initial_shopper)
	auto_free(initial_inventory)
extends GdUnitTestSuite

var shop_bus : ShopBus

# Signals
var shop_changed_emission : Array

func before_test():
	shop_bus = ShopBus.new()
	
	# Signal Testers
	shop_changed_emission = []
	shop_bus.shop_changed.connect(func(shop): shop_changed_emission.append(shop))

func test_set_active_shop():
	monitor_signals(shop_bus)
	var test_shop = auto_free(Shop.new())
	shop_bus.shop = test_shop
	assert_int(shop_changed_emission.size()).append_failure_message("Emit once on set property").is_equal(1)
	test_shop.free()
# test_items_transfer_combine_duplicate_stacks.gd
extends GdUnitTestSuite
class_name TestItemsTransferCombineDuplicateStacks

# Helper to create a FlexStack (assumes FlexItem and FlexStack are accessible)
func create_stack(item_name: String, count: int, stack_maximum: int = 64) -> FlexStack:
	var item := FlexItem.new()
	item.name = item_name
	item.stack_maximum = stack_maximum
	return FlexStack.new(item, count)

# Helper to create an infinite FlexStack
func create_infinite_stack(item_name: String, count: int) -> FlexStack:
	var item := FlexItem.new()
	item.name = item_name
	var stack := FlexStack.new(item, count)
	stack.infinite = true
	return stackclass_name TestStackRedistributionManager
extends GdUnitTestSuite

# Test resources
var _item: FlexItem
var _manager: StackRedistributionManager
var _inventory: FlexInventory
var _container: ItemContainer
var _stack: FlexStack
var _signal_results: Array

func before():
	# Create base test item
	_item = FlexItem.new()
	_item.stack_maximum = 5
	
	# Create container type
	var container_type = ItemContainerType.new()
	container_type.size = 10  # Enough space for redistribution tests
	container_type.empty_mode = ItemContainerType.EmptyMode.IGNORE
	
	# Create inventory hierarchy
	_inventory = FlexInventory.new()
	_container = ItemContainer.new(container_type)  # Pass type in constructor
	_stack = FlexStack.new()
	
	# Setup container in inventory
	_inventory.item_containers = [_container]
	_container.parent = _inventory
	_container._slots = [_stack]
	_stack.parent = _container
	
	# Verify initial setup
	var issues = _container.validate()
	assert_array(issues)\
		.append_failure_message("Container should have no validation issues")\
		.is_empty()

func before_test():
	# Reset state for each test
	_manager = StackRedistributionManager.new(_inventory)
	_stack.item = _item
	_stack.count = 0
	_signal_results = []
	
	# Verify container state before test
	var issues = _container.validate()
	assert_array(issues)\
		.append_failure_message("Container should maintain valid state")\
		.is_empty()
	
	# Connect signals to result collectors
	_manager.redistribution_completed.connect(
		func(resource: InventoryResource): _signal_results.append("completed:%s" % resource.resource_name)
	)
	_manager.redistribution_failed.connect(
		func(resource: InventoryResource, stack: FlexStack, overflow: int): 
			_signal_results.append("failed:%s:%d" % [resource.resource_name, overflow])
	)

func test_redistribution(
	initial_count: int, 
	max_count: int,
	expected_stack_count: int,
	expected_container_count: int,
	should_succeed: bool,
	test_parameters := [
		[7, 5, 5, 2, true],    
		[10, 5, 5, 5, true],   
		[15, 5, 5, 0, false],  
		[3, 5, 3, 0, true],    
		[0, 5, 0, 0, true],    
	]
) -> void:
	# Reset state
	_item.stack_maximum = max_count
	_stack.count = initial_count
	_container.remove_items(_item, _container.get_item_count(_item))  # Clear container
	
	var initial_total = initial_count
	
	var report := IllegalCountReport.new(_stack, _item, initial_count, max_count)
	_inventory.illegal_count_detected.emit(report)
	
	var result := _manager.redistribute_items(_stack, _item, initial_count)
	
	if should_succeed:
		assert_bool(result).append_failure_message("Redistribution should succeed").is_true()
		assert_array(_signal_results)\
			.append_failure_message("Should emit completion signal")\
			.contains_exactly(["completed:%s" % _stack.resource_name])
		assert_int(_stack.count)\
			.append_failure_message("Source stack should have correct count")\
			.is_equal(expected_stack_count)
		assert_int(_container.get_item_count(_item))\
			.append_failure_message("Container should have overflow items")\
			.is_equal(expected_container_count)
		assert_int(_stack.count + _container.get_item_count(_item))\
			.append_failure_message("Total items should be conserved")\
			.is_equal(initial_total)
	else:
		assert_bool(result).append_failure_message("Redistribution should fail").is_false()
		assert_array(_signal_results)\
			.append_failure_message("Should emit failure signal")\
			.contains_exactly(["failed:%s:%d" % [_stack.resource_name, initial_count - max_count]])
		assert_int(_stack.count)\
			.append_failure_message("Stack count should remain unchanged on failure")\
			.is_equal(initial_count)
extends GdUnitTestSuite
@warning_ignore('unused_parameter')
@warning_ignore('return_value_discarded')

# Test instances of StackTransfer
var valid_transfer: StackTransfer
var empty_transfer: StackTransfer
var null_source_transfer: StackTransfer
var invalid_items_transfer: StackTransfer

# Test data
var item_1: FlexItem
var item_10: FlexItem
var source_stack_1: FlexStack  # Stack with max 1 item
var source_stack_10: FlexStack # Stack with max 10 items
var target_stack_empty: FlexStack
var target_stack_10: FlexStack # Additional generic stack with max 10
var settings: InventorySettings

func before() -> void:
	item_1 = FlexItem.new()
	item_1.stack_maximum = 1
	item_10 = FlexItem.new()
	item_10.stack_maximum = 10
	settings = InventorySettings.new()

func before_test() -> void:
	# Setup source stacks with direct settings
	source_stack_1 = FlexStack.new()
	source_stack_1.item = item_1
	source_stack_1.count = 1
	configure_test_stack(source_stack_1, settings)
	
	source_stack_10 = FlexStack.new()
	source_stack_10.item = item_10
	source_stack_10.count = 10
	configure_test_stack(source_stack_10, settings)
	
	target_stack_empty = FlexStack.new()
	configure_test_stack(target_stack_empty, settings)
	
	target_stack_10 = FlexStack.new()
	target_stack_10.item = item_10
	configure_test_stack(target_stack_10, settings)
	
	# Initialize transfers
	valid_transfer = StackTransfer.new(StackSelection.new(source_stack_1, 1))
	empty_transfer = StackTransfer.new(StackSelection.new(FlexStack.new(), 0))
	null_source_transfer = StackTransfer.new(null)
	
	var null_stack = FlexStack.new()
	invalid_items_transfer = StackTransfer.new(StackSelection.new(null_stack, 5))

func test_init():
	var selection = StackSelection.new(source_stack_1, 1)
	var transfer = StackTransfer.new(selection)
	assert_object(transfer.source)\
		.append_failure_message("Transfer source should not be null")\
		.is_not_null()
	assert_int(transfer.source.amount)\
		.append_failure_message("Transfer source amount should match selection amount")\
		.is_equal(1)

func test_stack_validation(
	p_stack: FlexStack,
	p_should_validate: bool,
	test_parameters := [
		[source_stack_1, true],      # Stack with max 1 should validate
		[source_stack_10, true],     # Stack with max 10 should validate
		[target_stack_empty, true],  # Empty stack should validate
		[target_stack_10, true],     # Target stack with max 10 should validate
		[FlexStack.new(), false],    # Unconfigured stack should not validate
	]
) -> void:
	# Perform validation
	var validation_result = p_stack.validate()
	
	# Assert expected validation result
	assert_bool(validation_result)\
		.append_failure_message("Stack %s validation result should be %s" % [p_stack.resource_name if p_stack else "null", p_should_validate])\
		.is_equal(p_should_validate)
	
	# If should validate, verify key properties
	if p_should_validate:
		assert_object(p_stack.get_inventory_settings())\
			.append_failure_message("Stack %s should have valid settings" % p_stack.resource_name)\
			.is_not_null()
		
		if p_stack.item != null:
			assert_bool(p_stack.count <= p_stack.item.stack_maximum)\
				.append_failure_message("Stack %s count should not exceed maximum" % p_stack.resource_name)\
				.is_true()
			
			assert_bool(p_stack.count >= 0)\
				.append_failure_message("Stack %s count should not be negative" % p_stack.resource_name)\
				.is_true()

func test_move(
	p_transfer: StackTransfer,
	p_expected_status: StackTransfer.Result,
	p_expected_transferred: int,
	p_expected_message: String,
	test_parameters := [
		[valid_transfer, StackTransfer.Result.SUCCESS, 1, ""],
		[empty_transfer, StackTransfer.Result.FAILED, 0, "Invalid source selection"],
		[null_source_transfer, StackTransfer.Result.FAILED, 0, "Invalid source selection"],
		[invalid_items_transfer, StackTransfer.Result.FAILED, 0, "Cannot transfer empty stack"],
	]
) -> void:
	if p_transfer == null:
		assert_object(p_transfer)\
			.append_failure_message("Transfer should not be null")\
			.is_not_null()
		return
	
	p_transfer.target = target_stack_empty
	var result = p_transfer.execute()
	assert_int(result)\
		.append_failure_message("Transfer result should match expected status")\
		.is_equal(p_expected_status)
	assert_int(p_transfer.transferred)\
		.append_failure_message("Number of items transferred should match expected")\
		.is_equal(p_expected_transferred)

func test_swap(
	p_transfer: StackTransfer,
	p_target_stack: FlexStack,
	p_expected_result: StackTransfer.Result,
	test_parameters := [
		[valid_transfer, target_stack_empty, StackTransfer.Result.SUCCESS],
		[empty_transfer, target_stack_empty, StackTransfer.Result.FAILED],
		[null_source_transfer, target_stack_empty, StackTransfer.Result.FAILED],
		[invalid_items_transfer, target_stack_empty, StackTransfer.Result.FAILED],
	]
) -> void:
	p_transfer.target = p_target_stack
	var result = p_transfer.execute()
	assert_int(result)\
		.append_failure_message("Swap result should match expected result")\
		.is_equal(p_expected_result)

func test_resource_transfer_conservation(
	p_source_count: int,
	p_transfer_amount: int,
	p_expected_source_remaining: int,
	p_expected_target_count: int,
	p_expected_result : StackTransfer.Result,
	test_parameters := [
		[10, 5, 5, 5, StackTransfer.Result.SUCCESS],    # Partial transfer
		[10, 10, 0, 10, StackTransfer.Result.SUCCESS],  # Full transfer
		[5, 10, 0, 5, StackTransfer.Result.SUCCESS],    # Attempt over-transfer
		[1, 1, 0, 1, StackTransfer.Result.SUCCESS],     # Single item transfer
		[0, 5, 0, 5, StackTransfer.Result.FAILED],     # Empty source transfer
	]
) -> void:
	# Reset stacks for test
	source_stack_10.count = p_source_count
	target_stack_10.count = 0
	var should_validate = p_expected_result == StackTransfer.Result.SUCCESS
	
	# Add debug verification
	assert_bool(target_stack_10.can_add_items(source_stack_10.item, p_transfer_amount))\
		.append_failure_message("Target stack should be able to accept items if count above 0")\
		.is_equal(should_validate)
	
	# Verify initial setup
	assert_bool(source_stack_10.validate())\
		.append_failure_message("Source stack should be valid before transfer")\
		.is_true()
	assert_bool(target_stack_10.validate())\
		.append_failure_message("Target stack should be valid before transfer")\
		.is_true()
	
	# Setup transfer with validation
	var selection := StackSelection.new(source_stack_10, p_transfer_amount)
	assert_bool(selection.is_valid())\
		.append_failure_message("Selection should be valid")\
		.is_true()

	var transfer := StackTransfer.new(selection)
	transfer.target = target_stack_10

	# Add pre-transfer validation
	assert_bool(transfer._validate())\
		.append_failure_message("Transfer should be valid before execution")\
		.is_equal(should_validate)
	
	# Perform transfer
	var result = transfer.execute()
	assert_int(result)\
		.append_failure_message("Transfer should complete successfully")\
		.is_equal(p_expected_result)
	
	if not result == StackTransfer.Result.SUCCESS:
		return
		
	# Verify conservation of items
	assert_int(source_stack_10.count)\
		.append_failure_message("Actual remaining count does not match expected.")\
		.is_equal(p_expected_source_remaining)
	assert_int(target_stack_10.count)\
		.append_failure_message("Actual target stack count does not match")\
		.is_equal(p_expected_target_count)
	assert_int(source_stack_10.count + target_stack_10.count)\
		.append_failure_message("Total of source and target does not match the expected total items.")\
		.is_equal(p_source_count)



## Helper to configure a stack for testing without full hierarchy
func configure_test_stack(stack: FlexStack, settings: InventorySettings) -> void:
	stack._settings = settings
extends GdUnitTestSuite

var _item: FlexItem
var _stack: FlexStack
var _selection: StackSelection
var _transfer: StackTransfer

func before_test():
	_item = FlexItem.new()
	_item.icon = load("icon.svg")  # Replace with actual test icon path
	_item.stack_maximum = 99

func test_preview_creation(stack_count: int, selection_count: int, is_infinite: bool, expected_label: String, expected_child_count: int, test_parameters := [
	[10, 1, false, "", 1],      # Single item selection - no label
	[10, 5, false, "5", 2],     # Normal selection with count
	[10, 10, true, "10", 2],     # Infinite stack selection
	[0, 0, false, "", 1]        # Empty selection - no label
]) -> void:
	# Setup stack with parameters
	_stack = FlexStack.new(_item, stack_count)
	_stack.infinite = is_infinite
	_selection = StackSelection.new(_stack, selection_count)
	_transfer = StackTransfer.new(_selection)
	
	# Create preview and register for auto-free (Control inherits from Node)
	var preview := TransferPreviewFactory.create_preview(_transfer)
	auto_free(preview)
	
	# Verify preview structure
	assert_that(preview).is_not_null()
	assert_that(preview.get_child_count()).is_equal(expected_child_count)
	
	# Verify icon
	var icon := preview.get_child(0) as TextureRect
	assert_that(icon).is_not_null()
	assert_that(icon.texture).is_equal(_item.icon)
	
	# Verify label if expected
	if expected_child_count > 1:
		var label := preview.get_child(1) as Label
		assert_that(label).is_not_null()
		assert_that(label.text).is_equal(expected_label)

func test_custom_settings(icon_size: Vector2, font_size: int, count_pos: Vector2, test_parameters := [
	[Vector2(48, 48), 16, Vector2(36, 36)],  # Larger preview
	[Vector2(24, 24), 8, Vector2(18, 18)],   # Smaller preview
]) -> void:
	_stack = FlexStack.new(_item, 10)
	_selection = StackSelection.new(_stack, 5)  # Consistent 5-item selection for settings tests
	_transfer = StackTransfer.new(_selection)
	
	var custom_settings = {
		"icon_size": icon_size,
		"font_size": font_size,
		"count_position": count_pos
	}
	
	var preview := TransferPreviewFactory.create_preview(_transfer, custom_settings)
	auto_free(preview)
	
	assert_that(preview.custom_minimum_size).is_equal(icon_size)
	var label := preview.get_child(1) as Label
	assert_that(label.position).is_equal(count_pos)
	var actual_font_size = label.get_theme_font_size("font_size")
	assert_that(actual_font_size).is_equal(font_size)
